Index: pom.xml
===================================================================
--- pom.xml	(revision 5689)
+++ pom.xml	(working copy)
@@ -359,6 +359,11 @@
         <version>${mx4j-version}</version>
       </dependency>
       <dependency>
+        <groupId>org.slf4j</groupId>
+        <artifactId>slf4j-api</artifactId>
+        <version>${slf4j-version}</version>
+      </dependency>
+      <dependency>
         <groupId>xerces</groupId>
         <artifactId>xercesImpl</artifactId>
         <version>${xerces-version}</version>
@@ -412,5 +417,6 @@
     <mx4j-version>3.0.1</mx4j-version>
     <slf4j-version>1.3.1</slf4j-version>
     <eclipse-compiler-version>3.1.1</eclipse-compiler-version>
+    <servlet-version>2.5-20081211</servlet-version>
   </properties>
 </project>

Property changes on: extras/threadpool
___________________________________________________________________
Modified: svn:ignore
   - .classpath
.project
target
.settings

   + 
*.diff
*.iml
*.ipr
*.iws
*.log
*.patch
*.swp
*~
.classpath
.fbprefs
.pmd
.project
.settings
target


Index: extras/threadpool/src/main/java/org/mortbay/thread/concurrent/ThreadPool.java
===================================================================
--- extras/threadpool/src/main/java/org/mortbay/thread/concurrent/ThreadPool.java	(revision 5689)
+++ extras/threadpool/src/main/java/org/mortbay/thread/concurrent/ThreadPool.java	(working copy)
@@ -184,5 +184,16 @@
         if (!super.awaitTermination(60,TimeUnit.SECONDS))
             super.shutdownNow();
     }
+
+    /* ------------------------------------------------------------ */
+    public void addLifeCycleListener(LifeCycle.Listener listener)
+    {
+        throw new UnsupportedOperationException();
+    }
     
+    /* ------------------------------------------------------------ */
+    public void removeLifeCycleListener(LifeCycle.Listener listener)
+    {
+    }
+    
 }
Index: extras/threadpool/pom.xml
===================================================================
--- extras/threadpool/pom.xml	(revision 5689)
+++ extras/threadpool/pom.xml	(working copy)
@@ -9,15 +9,7 @@
   <groupId>org.mortbay.jetty</groupId>
   <artifactId>jetty-java5-threadpool</artifactId>
   <name>Jetty Java5 Threadpool</name>
-  <url>http://jetty.mortbay.org</url>
-  <licenses>
-    <license>
-      <name>Apache License Version 2</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0</url>
-    </license>
-  </licenses>
   <build>
-    <defaultGoal>install</defaultGoal>
     <plugins>
        <plugin>
         <artifactId>maven-compiler-plugin</artifactId>

Property changes on: extras/sslengine
___________________________________________________________________
Modified: svn:ignore
   - .project
.classpath
.settings
target

   + 
*.diff
*.iml
*.ipr
*.iws
*.log
*.patch
*.swp
*~
.classpath
.fbprefs
.pmd
.project
.settings
target


Index: extras/sslengine/src/test/java/org/mortbay/jetty/security/SSLEngineTest.java
===================================================================
--- extras/sslengine/src/test/java/org/mortbay/jetty/security/SSLEngineTest.java	(revision 5689)
+++ extras/sslengine/src/test/java/org/mortbay/jetty/security/SSLEngineTest.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 // JettyTest.java --
 //
 // Junit test that shows the Jetty SSL bug.
@@ -8,15 +22,24 @@
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.PrintWriter;
+import java.net.HttpURLConnection;
 import java.net.Socket;
+import java.net.URL;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
 
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
 import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
@@ -26,6 +49,8 @@
 import org.mortbay.jetty.Server;
 import org.mortbay.jetty.handler.AbstractHandler;
 import org.mortbay.jetty.security.SslSelectChannelConnector;
+import org.mortbay.jetty.servlet.ServletHandler;
+import org.mortbay.jetty.servlet.ServletHolder;
 
 /**
  * HttpServer Tester.
@@ -36,6 +61,7 @@
     // ---------------------------------------------
 
     // Useful constants
+    private static final int BODY_SIZE = 300;
     private static final String HELLO_WORLD="Hello world\r\n";
     private static final String JETTY_VERSION=Server.getVersion();
     private static final String PROTOCOL_VERSION="2.0";
@@ -54,24 +80,26 @@
     private static final String RESPONSE0="HTTP/1.1 200 OK\n"+"Content-Length: "+HELLO_WORLD.length()+"\n"+"Server: Jetty("+JETTY_VERSION+")\n"+'\n'+"Hello world\n";
     private static final String RESPONSE1="HTTP/1.1 200 OK\n"+"Connection: close\n"+"Server: Jetty("+JETTY_VERSION+")\n"+'\n'+"Hello world\n";
 
-    private static final TrustManager[] s_dummyTrustManagers=new TrustManager[]
-    { new X509TrustManager()
+
+    private static class CredulousTM implements TrustManager, X509TrustManager
     {
-        public java.security.cert.X509Certificate[] getAcceptedIssuers()
+        public X509Certificate[] getAcceptedIssuers()
         {
             return null;
         }
 
-        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType)
-
+        public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException
         {
+            return;
         }
 
-        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType)
-
+        public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException
         {
+            return;
         }
-    } };
+    }
+    
+    private static final TrustManager[] s_dummyTrustManagers=new TrustManager[]  { new CredulousTM() };
 
     // ~ Methods
     // ----------------------------------------------------------------
@@ -96,23 +124,23 @@
         server.setConnectors(new Connector[]
         { connector });
         server.setHandler(new HelloWorldHandler());
-        server.start();
-
         final int numConns=200;
-        Socket[] client=new Socket[numConns];
+        Socket[] socket=new Socket[numConns];
+        
+        try
+        {
+            server.start();
 
-        SSLContext ctx=SSLContext.getInstance("SSLv3");
-        ctx.init(null,s_dummyTrustManagers,new java.security.SecureRandom());
+            SSLContext ctx=SSLContext.getInstance("SSLv3");
+            ctx.init(null,s_dummyTrustManagers,new java.security.SecureRandom());
 
-        int port=connector.getLocalPort();
+            int port=connector.getLocalPort();
 
-        try
-        {
             for (int i=0; i<numConns; ++i)
             {
                 // System.err.println("write:"+i);
-                client[i]=ctx.getSocketFactory().createSocket("localhost",port);
-                OutputStream os=client[i].getOutputStream();
+                socket[i]=ctx.getSocketFactory().createSocket("localhost",port);
+                OutputStream os=socket[i].getOutputStream();
 
                 os.write(REQUEST0.getBytes());
                 os.write(REQUEST0.getBytes());
@@ -122,7 +150,7 @@
             for (int i=0; i<numConns; ++i)
             {
                 // System.err.println("flush:"+i);
-                OutputStream os=client[i].getOutputStream();
+                OutputStream os=socket[i].getOutputStream();
                 os.write(REQUEST1.getBytes());
                 os.flush();
             }
@@ -131,7 +159,7 @@
             {
                 // System.err.println("read:"+i);
                 // Read the response.
-                String responses=readResponse(client[i]);
+                String responses=readResponse(socket[i]);
                 // Check the response
                 assertEquals(String.format("responses %d",i),RESPONSE0+RESPONSE0+RESPONSE1,responses);
             }
@@ -140,9 +168,9 @@
         {
             for (int i=0; i<numConns; ++i)
             {
-                if (client[i]!=null)
+                if (socket[i]!=null)
                 {
-                    client[i].close();
+                    socket[i].close();
                 }
             }
             server.stop();
@@ -189,9 +217,6 @@
 
     private static class HelloWorldHandler extends AbstractHandler
     {
-        // ~ Methods
-        // ------------------------------------------------------------
-
         public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch) throws IOException, ServletException
         {
             PrintWriter out=response.getWriter();
@@ -206,4 +231,115 @@
             }
         }
     }
+
+    public void testServletPost() throws Exception
+    {
+        Server server=new Server();
+        SslSelectChannelConnector connector=new SslSelectChannelConnector();
+
+        String keystore = System.getProperty("user.dir")+File.separator+"src"+File.separator+"test"+File.separator+"resources"+File.separator+"keystore";
+        
+        connector.setPort(0);
+        connector.setKeystore(keystore);
+        connector.setPassword("storepwd");
+        connector.setKeyPassword("keypwd");
+        connector.setTruststore(keystore);
+        connector.setTrustPassword("storepwd");
+
+        server.setConnectors(new Connector[]
+        { connector });
+
+        ServletHandler handler = new ServletHandler();
+        TestServlet servlet = new TestServlet();
+        handler.addServletWithMapping(new ServletHolder(servlet),"/test");
+        server.addHandler(handler);
+        
+        try
+        {
+            SSLContext context = SSLContext.getInstance("SSL");
+            context.init(null,s_dummyTrustManagers,new java.security.SecureRandom());
+            HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());
+
+            server.start();
+
+            URL url = new URL("https://localhost:"+connector.getLocalPort()+"/test");
+
+            HttpURLConnection conn = (HttpURLConnection)url.openConnection();
+            if (conn instanceof HttpsURLConnection)
+            {
+                ((HttpsURLConnection)conn).setHostnameVerifier(new HostnameVerifier()
+                {
+                    public boolean verify(String urlHostName, SSLSession session)
+                    {
+                        return true;
+                    }
+                });
+            }
+
+            conn.setConnectTimeout(10000);
+            conn.setReadTimeout(100000);
+            conn.setDoInput(true);
+            conn.setDoOutput(true);
+            conn.setRequestMethod("POST");
+            conn.setRequestProperty("Content-Type","text/plain"); //$NON-NLS-1$
+            conn.setChunkedStreamingMode(128);
+            conn.connect();
+            byte[] b = new byte[BODY_SIZE];
+            for (int i = 0; i < BODY_SIZE; i++)
+            {
+                b[i] = 'x';
+            }
+            OutputStream os = conn.getOutputStream();
+            os.write(b);
+            os.flush();
+            int rc = conn.getResponseCode();
+
+            int len = 0;
+            InputStream is = conn.getInputStream();
+            int bytes=0;
+            while ((len = is.read(b)) > -1)
+                bytes+=len;
+            is.close();
+
+            assertEquals(BODY_SIZE,servlet.bytes);
+            assertEquals(BODY_SIZE,bytes);
+            
+        }
+        finally
+        {
+            server.stop();
+        }
+    }
+
+    public static class TestServlet extends HttpServlet
+    {
+        public int bytes=0;
+        
+        @Override
+        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
+        {
+            resp.setContentType("text/plain");
+            resp.setBufferSize(128);
+            byte[] b = new byte[BODY_SIZE];
+            int len = 0;
+            InputStream is = req.getInputStream();
+
+            // !!!! UNDER HTTPS, FIRST CHUNK IS READ HERE BUT THEN SERVER IS
+            // WAITING FOR
+            // !!!! MORE DATA
+            while ((len = is.read(b)) > -1)
+            {
+                bytes+=len;
+            }
+
+            OutputStream os = resp.getOutputStream();
+            for (int i = 0; i < BODY_SIZE; i++)
+            {
+                b[i] = 'x';
+            }
+            os.write(b);
+            resp.flushBuffer();
+
+        }
+    }
 }
Index: extras/sslengine/src/main/java/org/mortbay/jetty/security/SslSelectChannelConnector.java
===================================================================
--- extras/sslengine/src/main/java/org/mortbay/jetty/security/SslSelectChannelConnector.java	(revision 5689)
+++ extras/sslengine/src/main/java/org/mortbay/jetty/security/SslSelectChannelConnector.java	(working copy)
@@ -1,643 +1,695 @@
-package org.mortbay.jetty.security;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.SocketChannel;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-
-import org.mortbay.io.Buffer;
-import org.mortbay.io.Connection;
-import org.mortbay.io.EndPoint;
-import org.mortbay.io.bio.SocketEndPoint;
-import org.mortbay.io.nio.NIOBuffer;
-import org.mortbay.io.nio.SelectChannelEndPoint;
-import org.mortbay.io.nio.SelectorManager.SelectSet;
-import org.mortbay.jetty.HttpConnection;
-import org.mortbay.jetty.HttpParser;
-import org.mortbay.jetty.HttpSchemes;
-import org.mortbay.jetty.Request;
-import org.mortbay.jetty.nio.SelectChannelConnector;
-import org.mortbay.log.Log;
-import org.mortbay.resource.Resource;
-
-/* ------------------------------------------------------------ */
-/**
- * SslSelectChannelConnector.
- * 
- * @author Nik Gonzalez <ngonzalez@exist.com>
- * @author Greg Wilkins <gregw@mortbay.com>
- */
-public class SslSelectChannelConnector extends SelectChannelConnector
-{
-    /**
-     * The name of the SSLSession attribute that will contain any cached
-     * information.
-     */
-    static final String CACHED_INFO_ATTR=CachedInfo.class.getName();
-
-    /** Default value for the keystore location path. */
-    public static final String DEFAULT_KEYSTORE=System.getProperty("user.home")+File.separator+".keystore";
-
-    /** String name of key password property. */
-    public static final String KEYPASSWORD_PROPERTY="jetty.ssl.keypassword";
-
-    /** String name of keystore password property. */
-    public static final String PASSWORD_PROPERTY="jetty.ssl.password";
-
-    /** Default value for the cipher Suites. */
-    private String _excludeCipherSuites[]=null;
-
-    /** Default value for the keystore location path. */
-    private String _keystore=DEFAULT_KEYSTORE;
-    private String _keystoreType="JKS"; // type of the key store
-
-    /** Set to true if we require client certificate authentication. */
-    private boolean _needClientAuth=false;
-    private boolean _wantClientAuth=false;
-
-    private transient Password _password;
-    private transient Password _keyPassword;
-    private transient Password _trustPassword;
-    private String _protocol="TLS";
-    private String _algorithm="SunX509"; // cert algorithm
-    private String _provider;
-    private String _secureRandomAlgorithm; // cert algorithm
-    private String _sslKeyManagerFactoryAlgorithm=(Security.getProperty("ssl.KeyManagerFactory.algorithm")==null?"SunX509":Security
-            .getProperty("ssl.KeyManagerFactory.algorithm")); // cert
-                                                                // algorithm
-
-    private String _sslTrustManagerFactoryAlgorithm=(Security.getProperty("ssl.TrustManagerFactory.algorithm")==null?"SunX509":Security
-            .getProperty("ssl.TrustManagerFactory.algorithm")); // cert
-                                                                // algorithm
-
-    private String _truststore;
-    private String _truststoreType="JKS"; // type of the key store
-    private SSLContext _context;
-
-    private int _packetBufferSize;
-    private int _applicationBufferSize;
-    private ConcurrentLinkedQueue<Buffer> _packetBuffers = new ConcurrentLinkedQueue<Buffer>();
-    private ConcurrentLinkedQueue<Buffer> _applicationBuffers = new ConcurrentLinkedQueue<Buffer>();
-    
-    /* ------------------------------------------------------------ */
-    /* (non-Javadoc)
-     * @see org.mortbay.jetty.AbstractBuffers#getBuffer(int)
-     */
-    public Buffer getBuffer(int size)
-    {
-        Buffer buffer;
-        if (size==_applicationBufferSize)
-        {   
-            buffer = _applicationBuffers.poll();
-            if (buffer==null)
-                buffer=new NIOBuffer(size,false); 
-        }
-        else if (size==_packetBufferSize)
-        {   
-            buffer = _packetBuffers.poll();
-            if (buffer==null)
-                buffer=new NIOBuffer(size,getUseDirectBuffers()); 
-        }
-        else 
-            buffer=super.getBuffer(size);
-        
-        return buffer;
-    }
-    
-
-    /* ------------------------------------------------------------ */
-    /* (non-Javadoc)
-     * @see org.mortbay.jetty.AbstractBuffers#returnBuffer(org.mortbay.io.Buffer)
-     */
-    public void returnBuffer(Buffer buffer)
-    {
-        if (_loss++>BUFFER_LOSS_RATE)
-        {
-            _loss=0;
-            return;
-        }
-        buffer.clear();
-        int size=buffer.capacity();
-        ByteBuffer bbuf = ((NIOBuffer)buffer).getByteBuffer();
-        bbuf.position(0);
-        bbuf.limit(size);
-        
-        if (size==_applicationBufferSize)
-            _applicationBuffers.add(buffer);
-        else if (size==_packetBufferSize)
-            _packetBuffers.add(buffer);
-    }
-    
-    
-
-    /**
-     * Return the chain of X509 certificates used to negotiate the SSL Session.
-     * <p>
-     * Note: in order to do this we must convert a
-     * javax.security.cert.X509Certificate[], as used by JSSE to a
-     * java.security.cert.X509Certificate[],as required by the Servlet specs.
-     * 
-     * @param sslSession
-     *                the javax.net.ssl.SSLSession to use as the source of the
-     *                cert chain.
-     * @return the chain of java.security.cert.X509Certificates used to
-     *         negotiate the SSL connection. <br>
-     *         Will be null if the chain is missing or empty.
-     */
-    private static X509Certificate[] getCertChain(SSLSession sslSession)
-    {
-        try
-        {
-            javax.security.cert.X509Certificate javaxCerts[]=sslSession.getPeerCertificateChain();
-            if (javaxCerts==null||javaxCerts.length==0)
-                return null;
-
-            int length=javaxCerts.length;
-            X509Certificate[] javaCerts=new X509Certificate[length];
-
-            java.security.cert.CertificateFactory cf=java.security.cert.CertificateFactory.getInstance("X.509");
-            for (int i=0; i<length; i++)
-            {
-                byte bytes[]=javaxCerts[i].getEncoded();
-                ByteArrayInputStream stream=new ByteArrayInputStream(bytes);
-                javaCerts[i]=(X509Certificate)cf.generateCertificate(stream);
-            }
-
-            return javaCerts;
-        }
-        catch (SSLPeerUnverifiedException pue)
-        {
-            return null;
-        }
-        catch (Exception e)
-        {
-            Log.warn(Log.EXCEPTION,e);
-            return null;
-        }
-    }
-
-    /* ------------------------------------------------------------ */
-    /**
-     * Allow the Listener a chance to customise the request. before the server
-     * does its stuff. <br>
-     * This allows the required attributes to be set for SSL requests. <br>
-     * The requirements of the Servlet specs are:
-     * <ul>
-     * <li> an attribute named "javax.servlet.request.cipher_suite" of type
-     * String.</li>
-     * <li> an attribute named "javax.servlet.request.key_size" of type Integer.</li>
-     * <li> an attribute named "javax.servlet.request.X509Certificate" of type
-     * java.security.cert.X509Certificate[]. This is an array of objects of type
-     * X509Certificate, the order of this array is defined as being in ascending
-     * order of trust. The first certificate in the chain is the one set by the
-     * client, the next is the one used to authenticate the first, and so on.
-     * </li>
-     * </ul>
-     * 
-     * @param endpoint
-     *                The Socket the request arrived on. This should be a
-     *                {@link SocketEndPoint} wrapping a {@link SSLSocket}.
-     * @param request
-     *                HttpRequest to be customised.
-     */
-    public void customize(EndPoint endpoint, Request request) throws IOException
-    {
-        super.customize(endpoint,request);
-        request.setScheme(HttpSchemes.HTTPS);
-        
-        SslHttpChannelEndPoint sslHttpChannelEndpoint=(SslHttpChannelEndPoint)endpoint;
-        SSLEngine sslEngine=sslHttpChannelEndpoint.getSSLEngine();
-
-        try
-        {
-            SSLSession sslSession=sslEngine.getSession();
-            String cipherSuite=sslSession.getCipherSuite();
-            Integer keySize;
-            X509Certificate[] certs;
-
-            CachedInfo cachedInfo=(CachedInfo)sslSession.getValue(CACHED_INFO_ATTR);
-            if (cachedInfo!=null)
-            {
-                keySize=cachedInfo.getKeySize();
-                certs=cachedInfo.getCerts();
-            }
-            else
-            {
-                keySize=new Integer(ServletSSL.deduceKeyLength(cipherSuite));
-                certs=getCertChain(sslSession);
-                cachedInfo=new CachedInfo(keySize,certs);
-                sslSession.putValue(CACHED_INFO_ATTR,cachedInfo);
-            }
-
-            if (certs!=null)
-                request.setAttribute("javax.servlet.request.X509Certificate",certs);
-
-            request.setAttribute("javax.servlet.request.cipher_suite",cipherSuite);
-            request.setAttribute("javax.servlet.request.key_size",keySize);
-        }
-        catch (Exception e)
-        {
-            Log.warn(Log.EXCEPTION,e);
-        }
-    }
-
-    /* ------------------------------------------------------------ */
-    public SslSelectChannelConnector()
-    {
-        // Buffer sizes should be from SSL session, but not known at this stage.
-        // size should be 16k, but appears to need 16k+1 byte? Giving it 16k+2k
-        // just
-        // to be safe. TODO investigate
-        
-    }
-
-    /**
-     * 
-     * @deprecated As of Java Servlet API 2.0, with no replacement.
-     * 
-     */
-    public String[] getCipherSuites()
-    {
-        return getExcludeCipherSuites();
-    }
-
-    public String[] getExcludeCipherSuites()
-    {
-        return _excludeCipherSuites;
-    }
-
-    /**
-     * 
-     * @deprecated As of Java Servlet API 2.0, with no replacement.
-     * 
-     * @author Tony Jiang
-     */
-    public void setCipherSuites(String[] cipherSuites)
-    {
-        setExcludeCipherSuites(cipherSuites);
-    }
-
-    public void setExcludeCipherSuites(String[] cipherSuites)
-    {
-        this._excludeCipherSuites=cipherSuites;
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setPassword(String password)
-    {
-        _password=Password.getPassword(PASSWORD_PROPERTY,password,null);
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setTrustPassword(String password)
-    {
-        _trustPassword=Password.getPassword(PASSWORD_PROPERTY,password,null);
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setKeyPassword(String password)
-    {
-        _keyPassword=Password.getPassword(KEYPASSWORD_PROPERTY,password,null);
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getAlgorithm()
-    {
-        return (this._algorithm);
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setAlgorithm(String algorithm)
-    {
-        this._algorithm=algorithm;
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getProtocol()
-    {
-        return _protocol;
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setProtocol(String protocol)
-    {
-        _protocol=protocol;
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setKeystore(String keystore)
-    {
-        _keystore=keystore;
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getKeystore()
-    {
-        return _keystore;
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getKeystoreType()
-    {
-        return (_keystoreType);
-    }
-
-    /* ------------------------------------------------------------ */
-    public boolean getNeedClientAuth()
-    {
-        return _needClientAuth;
-    }
-
-    /* ------------------------------------------------------------ */
-    public boolean getWantClientAuth()
-    {
-        return _wantClientAuth;
-    }
-
-    /* ------------------------------------------------------------ */
-    /**
-     * Set the value of the needClientAuth property
-     * 
-     * @param needClientAuth
-     *                true iff we require client certificate authentication.
-     */
-    public void setNeedClientAuth(boolean needClientAuth)
-    {
-        _needClientAuth=needClientAuth;
-    }
-
-    public void setWantClientAuth(boolean wantClientAuth)
-    {
-        _wantClientAuth=wantClientAuth;
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setKeystoreType(String keystoreType)
-    {
-        _keystoreType=keystoreType;
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getProvider()
-    {
-        return _provider;
-    }
-
-    public String getSecureRandomAlgorithm()
-    {
-        return (this._secureRandomAlgorithm);
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getSslKeyManagerFactoryAlgorithm()
-    {
-        return (this._sslKeyManagerFactoryAlgorithm);
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getSslTrustManagerFactoryAlgorithm()
-    {
-        return (this._sslTrustManagerFactoryAlgorithm);
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getTruststore()
-    {
-        return _truststore;
-    }
-
-    /* ------------------------------------------------------------ */
-    public String getTruststoreType()
-    {
-        return _truststoreType;
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setProvider(String _provider)
-    {
-        this._provider=_provider;
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setSecureRandomAlgorithm(String algorithm)
-    {
-        this._secureRandomAlgorithm=algorithm;
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setSslKeyManagerFactoryAlgorithm(String algorithm)
-    {
-        this._sslKeyManagerFactoryAlgorithm=algorithm;
-    }
-
-    /* ------------------------------------------------------------ */
-    public void setSslTrustManagerFactoryAlgorithm(String algorithm)
-    {
-        this._sslTrustManagerFactoryAlgorithm=algorithm;
-    }
-
-    public void setTruststore(String truststore)
-    {
-        _truststore=truststore;
-    }
-
-    public void setTruststoreType(String truststoreType)
-    {
-        _truststoreType=truststoreType;
-    }
-
-    /* ------------------------------------------------------------ */
-    /**
-     * By default, we're confidential, given we speak SSL. But, if we've been
-     * told about an confidential port, and said port is not our port, then
-     * we're not. This allows separation of listeners providing INTEGRAL versus
-     * CONFIDENTIAL constraints, such as one SSL listener configured to require
-     * client certs providing CONFIDENTIAL, whereas another SSL listener not
-     * requiring client certs providing mere INTEGRAL constraints.
-     */
-    public boolean isConfidential(Request request)
-    {
-        final int confidentialPort=getConfidentialPort();
-        return confidentialPort==0||confidentialPort==request.getServerPort();
-    }
-
-    /* ------------------------------------------------------------ */
-    /**
-     * By default, we're integral, given we speak SSL. But, if we've been told
-     * about an integral port, and said port is not our port, then we're not.
-     * This allows separation of listeners providing INTEGRAL versus
-     * CONFIDENTIAL constraints, such as one SSL listener configured to require
-     * client certs providing CONFIDENTIAL, whereas another SSL listener not
-     * requiring client certs providing mere INTEGRAL constraints.
-     */
-    public boolean isIntegral(Request request)
-    {
-        final int integralPort=getIntegralPort();
-        return integralPort==0||integralPort==request.getServerPort();
-    }
-
-    /* ------------------------------------------------------------------------------- */
-    protected SelectChannelEndPoint newEndPoint(SocketChannel channel, SelectSet selectSet, SelectionKey key) throws IOException
-    {
-        return new SslHttpChannelEndPoint(this,channel,selectSet,key,createSSLEngine());
-    }
-
-    /* ------------------------------------------------------------------------------- */
-    protected Connection newConnection(SocketChannel channel, SelectChannelEndPoint endpoint)
-    {
-        HttpConnection connection=(HttpConnection)super.newConnection(channel,endpoint);
-        ((HttpParser)connection.getParser()).setForceContentBuffer(true);
-        return connection;
-    }
-
-    /* ------------------------------------------------------------ */
-    protected SSLEngine createSSLEngine() throws IOException
-    {
-        SSLEngine engine=null;
-        try
-        {
-            engine=_context.createSSLEngine();
-            
-            if (_wantClientAuth)
-                engine.setWantClientAuth(_wantClientAuth);
-            if (_needClientAuth)
-                engine.setNeedClientAuth(_needClientAuth);
-            
-            if (_excludeCipherSuites!=null&&_excludeCipherSuites.length>0)
-            {
-                List<String> excludedCSList=Arrays.asList(_excludeCipherSuites);
-                String[] enabledCipherSuites=engine.getEnabledCipherSuites();
-                List<String> enabledCSList=new ArrayList<String>(Arrays.asList(enabledCipherSuites));
-
-                for (String cipherName : excludedCSList)
-                {
-                    if (enabledCSList.contains(cipherName))
-                    {
-                        enabledCSList.remove(cipherName);
-                    }
-                }
-                enabledCipherSuites=enabledCSList.toArray(new String[enabledCSList.size()]);
-
-                engine.setEnabledCipherSuites(enabledCipherSuites);
-            }
-
-        }
-        catch (Exception e)
-        {
-            Log.warn("Error creating sslEngine -- closing this connector",e);
-            close();
-            throw new IllegalStateException(e);
-        }
-        return engine;
-    }
-
-   
-    protected void doStart() throws Exception
-    {
-        _context=createSSLContext();
-        
-        SSLEngine engine=createSSLEngine();
-        SSLSession ssl_session=engine.getSession();
-        
-        setHeaderBufferSize(ssl_session.getApplicationBufferSize());
-        setRequestBufferSize(ssl_session.getApplicationBufferSize());
-        setResponseBufferSize(ssl_session.getApplicationBufferSize());
-        
-        super.doStart();
-    }
-
-    protected SSLContext createSSLContext() throws Exception
-    {
-        if (_password==null)
-            _password=new Password("");
-        if (_keyPassword==null)
-            _keyPassword=_password;
-        if (_trustPassword==null)
-            _trustPassword=_password;
-
-        if (_truststore==null)
-        {
-            _truststore=_keystore;
-            _truststoreType=_keystoreType;
-        }
-
-        KeyManager[] keyManagers=null;
-        if (_keystore!=null)
-        {
-            KeyStore keyStore=KeyStore.getInstance(_keystoreType);
-            if (_password==null)
-                throw new SSLException("_password is not set");
-            keyStore.load(Resource.newResource(_keystore).getInputStream(),_password.toString().toCharArray());
-
-            KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(_sslKeyManagerFactoryAlgorithm);
-            if (_keyPassword==null)
-                throw new SSLException("_keypassword is not set");
-            keyManagerFactory.init(keyStore,_keyPassword.toString().toCharArray());
-            keyManagers=keyManagerFactory.getKeyManagers();
-        }
-
-        TrustManager[] trustManagers=null;
-        if (_truststore!=null)
-        {
-            KeyStore trustStore=KeyStore.getInstance(_truststoreType);
-            trustStore.load(Resource.newResource(_truststore).getInputStream(),_trustPassword.toString().toCharArray());
-
-            TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(_sslTrustManagerFactoryAlgorithm);
-            trustManagerFactory.init(trustStore);
-            trustManagers=trustManagerFactory.getTrustManagers();
-        }
-
-        SecureRandom secureRandom=_secureRandomAlgorithm==null?null:SecureRandom.getInstance(_secureRandomAlgorithm);
-        SSLContext context=_provider==null?SSLContext.getInstance(_protocol):SSLContext.getInstance(_protocol,_provider);
-        context.init(keyManagers,trustManagers,secureRandom);
-        return context;
-    }
-
-    /**
-     * Simple bundle of information that is cached in the SSLSession. Stores the
-     * effective keySize and the client certificate chain.
-     */
-    private class CachedInfo
-    {
-        private X509Certificate[] _certs;
-        private Integer _keySize;
-
-        CachedInfo(Integer keySize, X509Certificate[] certs)
-        {
-            this._keySize=keySize;
-            this._certs=certs;
-        }
-
-        X509Certificate[] getCerts()
-        {
-            return _certs;
-        }
-
-        Integer getKeySize()
-        {
-            return _keySize;
-        }
-    }
-
-}
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
+package org.mortbay.jetty.security;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+
+import org.mortbay.io.Buffer;
+import org.mortbay.io.Connection;
+import org.mortbay.io.EndPoint;
+import org.mortbay.io.bio.SocketEndPoint;
+import org.mortbay.io.nio.DirectNIOBuffer;
+import org.mortbay.io.nio.IndirectNIOBuffer;
+import org.mortbay.io.nio.NIOBuffer;
+import org.mortbay.io.nio.SelectChannelEndPoint;
+import org.mortbay.io.nio.SelectorManager.SelectSet;
+import org.mortbay.jetty.HttpConnection;
+import org.mortbay.jetty.HttpParser;
+import org.mortbay.jetty.HttpSchemes;
+import org.mortbay.jetty.Request;
+import org.mortbay.jetty.nio.SelectChannelConnector;
+import org.mortbay.log.Log;
+import org.mortbay.resource.Resource;
+
+/* ------------------------------------------------------------ */
+/**
+ * SslSelectChannelConnector.
+ * 
+ * @author Nik Gonzalez <ngonzalez@exist.com>
+ * @author Greg Wilkins <gregw@mortbay.com>
+ */
+public class SslSelectChannelConnector extends SelectChannelConnector
+{
+    /**
+     * The name of the SSLSession attribute that will contain any cached
+     * information.
+     */
+    static final String CACHED_INFO_ATTR=CachedInfo.class.getName();
+
+    /** Default value for the keystore location path. */
+    public static final String DEFAULT_KEYSTORE=System.getProperty("user.home")+File.separator+".keystore";
+
+    /** String name of key password property. */
+    public static final String KEYPASSWORD_PROPERTY="jetty.ssl.keypassword";
+
+    /** String name of keystore password property. */
+    public static final String PASSWORD_PROPERTY="jetty.ssl.password";
+
+    /** Default value for the cipher Suites. */
+    private String _excludeCipherSuites[]=null;
+
+    /** Default value for the keystore location path. */
+    private String _keystore=DEFAULT_KEYSTORE;
+    private String _keystoreType="JKS"; // type of the key store
+
+    /** Set to true if we require client certificate authentication. */
+    private boolean _needClientAuth=false;
+    private boolean _wantClientAuth=false;
+
+    private transient Password _password;
+    private transient Password _keyPassword;
+    private transient Password _trustPassword;
+    private String _protocol="TLS";
+    private String _algorithm="SunX509"; // cert algorithm
+    private String _provider;
+    private String _secureRandomAlgorithm; // cert algorithm
+    private String _sslKeyManagerFactoryAlgorithm=(Security.getProperty("ssl.KeyManagerFactory.algorithm")==null?"SunX509":Security
+            .getProperty("ssl.KeyManagerFactory.algorithm")); // cert
+                                                                // algorithm
+
+    private String _sslTrustManagerFactoryAlgorithm=(Security.getProperty("ssl.TrustManagerFactory.algorithm")==null?"SunX509":Security
+            .getProperty("ssl.TrustManagerFactory.algorithm")); // cert
+                                                                // algorithm
+
+    private String _truststore;
+    private String _truststoreType="JKS"; // type of the key store
+    private SSLContext _context;
+
+    private int _packetBufferSize;
+    private int _applicationBufferSize;
+    private ConcurrentLinkedQueue<Buffer> _packetBuffers = new ConcurrentLinkedQueue<Buffer>();
+    private ConcurrentLinkedQueue<Buffer> _applicationBuffers = new ConcurrentLinkedQueue<Buffer>();
+    private boolean _allowRenegotiate=false;
+    
+    /* ------------------------------------------------------------ */
+    /* (non-Javadoc)
+     * @see org.mortbay.jetty.AbstractBuffers#getBuffer(int)
+     */
+    public Buffer getBuffer(int size)
+    {
+        Buffer buffer;
+        if (size==_applicationBufferSize)
+        {   
+            buffer = _applicationBuffers.poll();
+            if (buffer==null)
+                buffer=new IndirectNIOBuffer(size); 
+        }
+        else if (size==_packetBufferSize)
+        {   
+            buffer = _packetBuffers.poll();
+            if (buffer==null)
+                buffer=getUseDirectBuffers()
+                    ?(NIOBuffer)new DirectNIOBuffer(size)
+                    :(NIOBuffer)new IndirectNIOBuffer(size);
+        }
+        else 
+            buffer=super.getBuffer(size);
+        
+        return buffer;
+    }
+    
+
+    /* ------------------------------------------------------------ */
+    /* (non-Javadoc)
+     * @see org.mortbay.jetty.AbstractBuffers#returnBuffer(org.mortbay.io.Buffer)
+     */
+    public void returnBuffer(Buffer buffer)
+    {
+        buffer.clear();
+        int size=buffer.capacity();
+        ByteBuffer bbuf = ((NIOBuffer)buffer).getByteBuffer();
+        bbuf.position(0);
+        bbuf.limit(size);
+        
+        if (size==_applicationBufferSize)
+            _applicationBuffers.add(buffer);
+        else if (size==_packetBufferSize)
+            _packetBuffers.add(buffer);
+        else 
+            super.returnBuffer(buffer);
+    }
+    
+    
+
+    /**
+     * Return the chain of X509 certificates used to negotiate the SSL Session.
+     * <p>
+     * Note: in order to do this we must convert a
+     * javax.security.cert.X509Certificate[], as used by JSSE to a
+     * java.security.cert.X509Certificate[],as required by the Servlet specs.
+     * 
+     * @param sslSession
+     *                the javax.net.ssl.SSLSession to use as the source of the
+     *                cert chain.
+     * @return the chain of java.security.cert.X509Certificates used to
+     *         negotiate the SSL connection. <br>
+     *         Will be null if the chain is missing or empty.
+     */
+    private static X509Certificate[] getCertChain(SSLSession sslSession)
+    {
+        try
+        {
+            javax.security.cert.X509Certificate javaxCerts[]=sslSession.getPeerCertificateChain();
+            if (javaxCerts==null||javaxCerts.length==0)
+                return null;
+
+            int length=javaxCerts.length;
+            X509Certificate[] javaCerts=new X509Certificate[length];
+
+            java.security.cert.CertificateFactory cf=java.security.cert.CertificateFactory.getInstance("X.509");
+            for (int i=0; i<length; i++)
+            {
+                byte bytes[]=javaxCerts[i].getEncoded();
+                ByteArrayInputStream stream=new ByteArrayInputStream(bytes);
+                javaCerts[i]=(X509Certificate)cf.generateCertificate(stream);
+            }
+
+            return javaCerts;
+        }
+        catch (SSLPeerUnverifiedException e)
+        {
+            Log.ignore(e);
+            return null;
+        }
+        catch (Exception e)
+        {
+            Log.warn(Log.EXCEPTION,e);
+            return null;
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * Allow the Listener a chance to customise the request. before the server
+     * does its stuff. <br>
+     * This allows the required attributes to be set for SSL requests. <br>
+     * The requirements of the Servlet specs are:
+     * <ul>
+     * <li> an attribute named "javax.servlet.request.cipher_suite" of type
+     * String.</li>
+     * <li> an attribute named "javax.servlet.request.key_size" of type Integer.</li>
+     * <li> an attribute named "javax.servlet.request.X509Certificate" of type
+     * java.security.cert.X509Certificate[]. This is an array of objects of type
+     * X509Certificate, the order of this array is defined as being in ascending
+     * order of trust. The first certificate in the chain is the one set by the
+     * client, the next is the one used to authenticate the first, and so on.
+     * </li>
+     * </ul>
+     * 
+     * @param endpoint
+     *                The Socket the request arrived on. This should be a
+     *                {@link SocketEndPoint} wrapping a {@link SSLSocket}.
+     * @param request
+     *                HttpRequest to be customised.
+     */
+    public void customize(EndPoint endpoint, Request request) throws IOException
+    {
+        super.customize(endpoint,request);
+        request.setScheme(HttpSchemes.HTTPS);
+        
+        SslHttpChannelEndPoint sslHttpChannelEndpoint=(SslHttpChannelEndPoint)endpoint;
+        SSLEngine sslEngine=sslHttpChannelEndpoint.getSSLEngine();
+
+        try
+        {
+            SSLSession sslSession=sslEngine.getSession();
+            String cipherSuite=sslSession.getCipherSuite();
+            Integer keySize;
+            X509Certificate[] certs;
+
+            CachedInfo cachedInfo=(CachedInfo)sslSession.getValue(CACHED_INFO_ATTR);
+            if (cachedInfo!=null)
+            {
+                keySize=cachedInfo.getKeySize();
+                certs=cachedInfo.getCerts();
+            }
+            else
+            {
+                keySize=new Integer(ServletSSL.deduceKeyLength(cipherSuite));
+                certs=getCertChain(sslSession);
+                cachedInfo=new CachedInfo(keySize,certs);
+                sslSession.putValue(CACHED_INFO_ATTR,cachedInfo);
+            }
+
+            if (certs!=null)
+                request.setAttribute("javax.servlet.request.X509Certificate",certs);
+
+            request.setAttribute("javax.servlet.request.cipher_suite",cipherSuite);
+            request.setAttribute("javax.servlet.request.key_size",keySize);
+        }
+        catch (Exception e)
+        {
+            Log.warn(Log.EXCEPTION,e);
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    public SslSelectChannelConnector()
+    {
+        // Buffer sizes should be from SSL session, but not known at this stage.
+        // size should be 16k, but appears to need 16k+1 byte? Giving it 16k+2k
+        // just
+        // to be safe. TODO investigate
+        
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * @return True if SSL re-negotiation is allowed (default false)
+     */
+    public boolean isAllowRenegotiate()
+    {
+        return _allowRenegotiate;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * Set if SSL re-negotiation is allowed. CVE-2009-3555 discovered
+     * a vulnerability in SSL/TLS with re-negotiation.  If your JVM
+     * does not have CVE-2009-3555 fixed, then re-negotiation should 
+     * not be allowed.
+     * @param allowRenegotiate true if re-negotiation is allowed (default false)
+     */
+    public void setAllowRenegotiate(boolean allowRenegotiate)
+    {
+        _allowRenegotiate = allowRenegotiate;
+    }
+    
+    /**
+     * 
+     * @deprecated As of Java Servlet API 2.0, with no replacement.
+     * 
+     */
+    public String[] getCipherSuites()
+    {
+        return getExcludeCipherSuites();
+    }
+
+    public String[] getExcludeCipherSuites()
+    {
+        return _excludeCipherSuites;
+    }
+
+    /**
+     * 
+     * @deprecated As of Java Servlet API 2.0, with no replacement.
+     * 
+     * @author Tony Jiang
+     */
+    public void setCipherSuites(String[] cipherSuites)
+    {
+        setExcludeCipherSuites(cipherSuites);
+    }
+
+    public void setExcludeCipherSuites(String[] cipherSuites)
+    {
+        this._excludeCipherSuites=cipherSuites;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setPassword(String password)
+    {
+        _password=Password.getPassword(PASSWORD_PROPERTY,password,null);
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setTrustPassword(String password)
+    {
+        _trustPassword=Password.getPassword(PASSWORD_PROPERTY,password,null);
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setKeyPassword(String password)
+    {
+        _keyPassword=Password.getPassword(KEYPASSWORD_PROPERTY,password,null);
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getAlgorithm()
+    {
+        return (this._algorithm);
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setAlgorithm(String algorithm)
+    {
+        this._algorithm=algorithm;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getProtocol()
+    {
+        return _protocol;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setProtocol(String protocol)
+    {
+        _protocol=protocol;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setKeystore(String keystore)
+    {
+        _keystore=keystore;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getKeystore()
+    {
+        return _keystore;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getKeystoreType()
+    {
+        return (_keystoreType);
+    }
+
+    /* ------------------------------------------------------------ */
+    public boolean getNeedClientAuth()
+    {
+        return _needClientAuth;
+    }
+
+    /* ------------------------------------------------------------ */
+    public boolean getWantClientAuth()
+    {
+        return _wantClientAuth;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * Set the value of the needClientAuth property
+     * 
+     * @param needClientAuth
+     *                true iff we require client certificate authentication.
+     */
+    public void setNeedClientAuth(boolean needClientAuth)
+    {
+        _needClientAuth=needClientAuth;
+    }
+
+    public void setWantClientAuth(boolean wantClientAuth)
+    {
+        _wantClientAuth=wantClientAuth;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setKeystoreType(String keystoreType)
+    {
+        _keystoreType=keystoreType;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getProvider()
+    {
+        return _provider;
+    }
+
+    public String getSecureRandomAlgorithm()
+    {
+        return (this._secureRandomAlgorithm);
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getSslKeyManagerFactoryAlgorithm()
+    {
+        return (this._sslKeyManagerFactoryAlgorithm);
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getSslTrustManagerFactoryAlgorithm()
+    {
+        return (this._sslTrustManagerFactoryAlgorithm);
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getTruststore()
+    {
+        return _truststore;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getTruststoreType()
+    {
+        return _truststoreType;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setProvider(String _provider)
+    {
+        this._provider=_provider;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setSecureRandomAlgorithm(String algorithm)
+    {
+        this._secureRandomAlgorithm=algorithm;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setSslKeyManagerFactoryAlgorithm(String algorithm)
+    {
+        this._sslKeyManagerFactoryAlgorithm=algorithm;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setSslTrustManagerFactoryAlgorithm(String algorithm)
+    {
+        this._sslTrustManagerFactoryAlgorithm=algorithm;
+    }
+
+    public void setTruststore(String truststore)
+    {
+        _truststore=truststore;
+    }
+
+    public void setTruststoreType(String truststoreType)
+    {
+        _truststoreType=truststoreType;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * By default, we're confidential, given we speak SSL. But, if we've been
+     * told about an confidential port, and said port is not our port, then
+     * we're not. This allows separation of listeners providing INTEGRAL versus
+     * CONFIDENTIAL constraints, such as one SSL listener configured to require
+     * client certs providing CONFIDENTIAL, whereas another SSL listener not
+     * requiring client certs providing mere INTEGRAL constraints.
+     */
+    public boolean isConfidential(Request request)
+    {
+        final int confidentialPort=getConfidentialPort();
+        return confidentialPort==0||confidentialPort==request.getServerPort();
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * By default, we're integral, given we speak SSL. But, if we've been told
+     * about an integral port, and said port is not our port, then we're not.
+     * This allows separation of listeners providing INTEGRAL versus
+     * CONFIDENTIAL constraints, such as one SSL listener configured to require
+     * client certs providing CONFIDENTIAL, whereas another SSL listener not
+     * requiring client certs providing mere INTEGRAL constraints.
+     */
+    public boolean isIntegral(Request request)
+    {
+        final int integralPort=getIntegralPort();
+        return integralPort==0||integralPort==request.getServerPort();
+    }
+
+    /* ------------------------------------------------------------------------------- */
+    protected SelectChannelEndPoint newEndPoint(SocketChannel channel, SelectSet selectSet, SelectionKey key) throws IOException
+    {
+        SslHttpChannelEndPoint endp = new SslHttpChannelEndPoint(this,channel,selectSet,key,createSSLEngine());
+        endp.setAllowRenegotiate(_allowRenegotiate);
+        return endp;
+    }
+
+    /* ------------------------------------------------------------------------------- */
+    protected Connection newConnection(SocketChannel channel, SelectChannelEndPoint endpoint)
+    {
+        HttpConnection connection=(HttpConnection)super.newConnection(channel,endpoint);
+        ((HttpParser)connection.getParser()).setForceContentBuffer(true);
+        return connection;
+    }
+
+    /* ------------------------------------------------------------ */
+    protected SSLEngine createSSLEngine() throws IOException
+    {
+        SSLEngine engine=null;
+        try
+        {
+            engine=_context.createSSLEngine();
+            engine.setUseClientMode(false);
+            
+            if (_wantClientAuth)
+                engine.setWantClientAuth(_wantClientAuth);
+            if (_needClientAuth)
+                engine.setNeedClientAuth(_needClientAuth);
+            
+            if (_excludeCipherSuites!=null&&_excludeCipherSuites.length>0)
+            {
+                List<String> excludedCSList=Arrays.asList(_excludeCipherSuites);
+                String[] enabledCipherSuites=engine.getEnabledCipherSuites();
+                List<String> enabledCSList=new ArrayList<String>(Arrays.asList(enabledCipherSuites));
+
+                for (String cipherName : excludedCSList)
+                {
+                    if (enabledCSList.contains(cipherName))
+                    {
+                        enabledCSList.remove(cipherName);
+                    }
+                }
+                enabledCipherSuites=enabledCSList.toArray(new String[enabledCSList.size()]);
+
+                engine.setEnabledCipherSuites(enabledCipherSuites);
+            }
+        }
+        catch (Exception e)
+        {
+            Log.warn("Error creating sslEngine -- closing this connector",e);
+            close();
+            throw new IllegalStateException(e);
+        }
+        return engine;
+    }
+   
+    protected void doStart() throws Exception
+    {
+        _context=createSSLContext();
+        SSLEngine engine=_context.createSSLEngine();
+        SSLSession session=engine.getSession();
+        if (getHeaderBufferSize()<session.getApplicationBufferSize())
+            setHeaderBufferSize(session.getApplicationBufferSize());
+        if (getRequestBufferSize()<session.getApplicationBufferSize())
+            setRequestBufferSize(session.getApplicationBufferSize());
+        super.doStart();
+    }
+
+    protected SSLContext createSSLContext() throws Exception
+    {
+        if (_truststore==null)
+        {
+            _truststore=_keystore;
+            _truststoreType=_keystoreType;
+        }
+
+        InputStream keystoreInputStream = null;
+
+        KeyManager[] keyManagers=null;
+        KeyStore keyStore = null;
+        try
+        {
+            if (_keystore!=null)
+            {
+                keystoreInputStream=Resource.newResource(_keystore).getInputStream();
+                keyStore = KeyStore.getInstance(_keystoreType);
+                keyStore.load(keystoreInputStream,_password==null?null:_password.toString().toCharArray());
+            }
+        }
+        finally
+        {
+            if (keystoreInputStream != null)
+                keystoreInputStream.close();
+        }
+
+        KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(_sslKeyManagerFactoryAlgorithm);
+        keyManagerFactory.init(keyStore,_keyPassword==null?(_password==null?null:_password.toString().toCharArray()):_keyPassword.toString().toCharArray());
+        keyManagers=keyManagerFactory.getKeyManagers();
+
+
+        TrustManager[] trustManagers=null;
+        InputStream truststoreInputStream = null;
+        KeyStore trustStore = null;
+        try
+        {
+            if (_truststore!=null)
+            {
+                truststoreInputStream = Resource.newResource(_truststore).getInputStream();
+                trustStore=KeyStore.getInstance(_truststoreType);
+                trustStore.load(truststoreInputStream,_trustPassword==null?null:_trustPassword.toString().toCharArray());
+            }
+        }
+        finally
+        {
+            if (truststoreInputStream != null)
+                truststoreInputStream.close();
+        }
+
+
+        TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(_sslTrustManagerFactoryAlgorithm);
+        trustManagerFactory.init(trustStore);
+        trustManagers=trustManagerFactory.getTrustManagers();
+
+        SecureRandom secureRandom=_secureRandomAlgorithm==null?null:SecureRandom.getInstance(_secureRandomAlgorithm);
+        SSLContext context=_provider==null?SSLContext.getInstance(_protocol):SSLContext.getInstance(_protocol,_provider);
+        context.init(keyManagers,trustManagers,secureRandom);
+        return context;
+    }
+
+    /**
+     * Simple bundle of information that is cached in the SSLSession. Stores the
+     * effective keySize and the client certificate chain.
+     */
+    private class CachedInfo
+    {
+        private X509Certificate[] _certs;
+        private Integer _keySize;
+
+        CachedInfo(Integer keySize, X509Certificate[] certs)
+        {
+            this._keySize=keySize;
+            this._certs=certs;
+        }
+
+        X509Certificate[] getCerts()
+        {
+            return _certs;
+        }
+
+        Integer getKeySize()
+        {
+            return _keySize;
+        }
+    }
+
+}

Property changes on: extras/sslengine/src/main/java/org/mortbay/jetty/security/SslSelectChannelConnector.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: extras/sslengine/src/main/java/org/mortbay/jetty/security/SslHttpChannelEndPoint.java
===================================================================
--- extras/sslengine/src/main/java/org/mortbay/jetty/security/SslHttpChannelEndPoint.java	(revision 5689)
+++ extras/sslengine/src/main/java/org/mortbay/jetty/security/SslHttpChannelEndPoint.java	(working copy)
@@ -1,523 +1,821 @@
-package org.mortbay.jetty.security;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.Channel;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.SocketChannel;
-
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLEngineResult;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLSession;
-
-import org.mortbay.io.Buffer;
-import org.mortbay.io.Buffers;
-import org.mortbay.io.nio.NIOBuffer;
-import org.mortbay.io.nio.SelectorManager;
-import org.mortbay.jetty.nio.SelectChannelConnector;
-import org.mortbay.log.Log;
-
-/* ------------------------------------------------------------ */
-/**
- * SslHttpChannelEndPoint.
- * 
- * @author Nik Gonzalez <ngonzalez@exist.com>
- * @author Greg Wilkins <gregw@mortbay.com>
- */
-public class SslHttpChannelEndPoint extends SelectChannelConnector.ConnectorEndPoint implements Runnable
-{
-    private static final ByteBuffer[] __NO_BUFFERS={};
-    private static final ByteBuffer __EMPTY=ByteBuffer.allocate(0);
-
-    private Buffers _buffers;
-    
-    private SSLEngine _engine;
-    private ByteBuffer _inBuffer;
-    private NIOBuffer _inNIOBuffer;
-    private ByteBuffer _outBuffer;
-    private NIOBuffer _outNIOBuffer;
-
-    private NIOBuffer[] _reuseBuffer=new NIOBuffer[2];    
-    private ByteBuffer[] _gather=new ByteBuffer[2];
-
-    // ssl
-    protected SSLSession _session;
-    
-    /* ------------------------------------------------------------ */
-    public SslHttpChannelEndPoint(Buffers buffers,SocketChannel channel, SelectorManager.SelectSet selectSet, SelectionKey key, SSLEngine engine)
-            throws SSLException, IOException
-    {
-        super(channel,selectSet,key);
-        _buffers=buffers;
-        
-        // ssl
-        _engine=engine;
-        _engine.setUseClientMode(false);
-        _session=engine.getSession();
-
-        // TODO pool buffers and use only when needed.
-        _outNIOBuffer=(NIOBuffer)buffers.getBuffer(_session.getPacketBufferSize());
-        _outBuffer=_outNIOBuffer.getByteBuffer();
-        _inNIOBuffer=(NIOBuffer)buffers.getBuffer(_session.getPacketBufferSize());
-        _inBuffer=_inNIOBuffer.getByteBuffer();
-        
-    }
-
-    /* ------------------------------------------------------------ */
-    /* (non-Javadoc)
-     * @see org.mortbay.io.nio.SelectChannelEndPoint#idleExpired()
-     */
-    protected void idleExpired()
-    {
-        try
-        {
-            _selectSet.getManager().dispatch(new Runnable()
-            {
-                public void run() 
-                { 
-                    try 
-                    {
-                        close(); 
-                    }
-                    catch(Exception e)
-                    {
-                        Log.ignore(e);
-                    }
-                }
-            });
-        }
-        catch(Exception e)
-        {
-            Log.ignore(e);
-        }
-    }
-
-
-
-    /* ------------------------------------------------------------ */
-    public void close() throws IOException
-    {
-        _engine.closeOutbound();
-        
-        try
-        {   
-            int tries=0;
-            loop: while (isOpen() && !_engine.isOutboundDone() && tries++<100)
-            {
-               
-                if (_outNIOBuffer.length()>0)
-                {
-                    flush();
-                    Thread.sleep(100); // TODO yuck
-                }
-                
-                switch(_engine.getHandshakeStatus())
-                {
-                    case FINISHED:
-                    case NOT_HANDSHAKING:
-                        break loop;
-                        
-                    case NEED_UNWRAP:
-                        if(!fill(__EMPTY))
-                            Thread.sleep(100); // TODO yuck
-                        break;
-                        
-                    case NEED_TASK:
-                    {
-                        Runnable task;
-                        while ((task=_engine.getDelegatedTask())!=null)
-                        {
-                            task.run();
-                        }
-                        break;
-                    }
-                        
-                    case NEED_WRAP:
-                    {
-                        if (_outNIOBuffer.length()>0)
-                            flush();
-                        
-                        SSLEngineResult result=null;
-                        try
-                        {
-                            _outNIOBuffer.compact();
-                            int put=_outNIOBuffer.putIndex();
-                            _outBuffer.position(put);
-                            result=_engine.wrap(__NO_BUFFERS,_outBuffer);
-                            _outNIOBuffer.setPutIndex(put+result.bytesProduced());
-                        }
-                        finally
-                        {
-                            _outBuffer.position(0);
-                        }
-                        
-                        flush();
-                        
-                        break;
-                    }
-                }
-            }
-            
-        }
-        catch(IOException e)
-        {
-            Log.ignore(e);
-        }
-        catch (InterruptedException e)
-        {
-            Log.ignore(e);
-        }
-        finally
-        {
-            super.close();
-            
-            if (_inNIOBuffer!=null)
-                _buffers.returnBuffer(_inNIOBuffer);
-            if (_outNIOBuffer!=null)
-                _buffers.returnBuffer(_outNIOBuffer);
-            if (_reuseBuffer[0]!=null)
-                _buffers.returnBuffer(_reuseBuffer[0]);
-            if (_reuseBuffer[1]!=null)
-                _buffers.returnBuffer(_reuseBuffer[1]);
-        }
-        
-        
-    }
-
-    /* ------------------------------------------------------------ */
-    /* 
-     */
-    public int fill(Buffer buffer) throws IOException
-    {
-        synchronized(buffer)
-        {
-            ByteBuffer bbuf=extractInputBuffer(buffer);
-            int size=buffer.length();
-
-            try
-            {
-                fill(bbuf);
-
-                loop: while (_inBuffer.remaining()>0)
-                {
-                    if (_outNIOBuffer.length()>0)
-                        flush();
-                    
-                    switch(_engine.getHandshakeStatus())
-                    {
-                        case FINISHED:
-                        case NOT_HANDSHAKING:
-                            break loop;
-
-                        case NEED_UNWRAP:
-                            if(!fill(bbuf))
-                                break loop;
-                            break;
-
-                        case NEED_TASK:
-                        {
-                            Runnable task;
-                            while ((task=_engine.getDelegatedTask())!=null)
-                            {
-                                task.run();
-                            }
-                            break;
-                        }
-
-                        case NEED_WRAP:
-                        {
-                            SSLEngineResult result=null;
-                            synchronized(_outBuffer)
-                            {
-                                try
-                                {
-                                    _outNIOBuffer.compact();
-                                    int put=_outNIOBuffer.putIndex();
-                                    _outBuffer.position();
-                                    result=_engine.wrap(__NO_BUFFERS,_outBuffer);
-                                    _outNIOBuffer.setPutIndex(put+result.bytesProduced());
-                                }
-                                finally
-                                {
-                                    _outBuffer.position(0);
-                                }
-                            }
-
-                            flush();
-
-                            break;
-                        }
-                    }
-                }
-            }
-            finally
-            {
-                buffer.setPutIndex(bbuf.position());
-                bbuf.position(0);
-            }
-
-            return buffer.length()-size; 
-        }
-    }
-
-    /* ------------------------------------------------------------ */
-    public int flush(Buffer buffer) throws IOException
-    {
-        return flush(buffer,null,null);
-    }
-
-
-    /* ------------------------------------------------------------ */
-    /*     
-     */
-    public int flush(Buffer header, Buffer buffer, Buffer trailer) throws IOException
-    {
-        if (_outNIOBuffer.length()>0)
-        {
-            flush();
-            if (_outNIOBuffer.length()>0)
-                return 0;
-        }
-
-        SSLEngineResult result=null;
-
-        if (header!=null && buffer!=null)
-        {
-            _gather[0]=extractOutputBuffer(header,0);
-            synchronized(_gather[0])
-            {
-                _gather[0].position(header.getIndex());
-                _gather[0].limit(header.putIndex());
-
-                _gather[1]=extractOutputBuffer(buffer,1);
-
-                synchronized(_gather[1])
-                {
-                    _gather[1].position(buffer.getIndex());
-                    _gather[1].limit(buffer.putIndex());
-
-                    synchronized(_outBuffer)
-                    {
-                        int consumed=0;
-                        try
-                        {
-                            _outNIOBuffer.clear();
-                            _outBuffer.position(0);
-                            _outBuffer.limit(_outBuffer.capacity());
-                            result=_engine.wrap(_gather,_outBuffer);
-                            _outNIOBuffer.setGetIndex(0);
-                            _outNIOBuffer.setPutIndex(result.bytesProduced());
-                            consumed=result.bytesConsumed();
-                        }
-                        finally
-                        {
-                            _outBuffer.position(0);
-
-                            if (consumed>0 && header!=null)
-                            {
-                                int len=consumed<header.length()?consumed:header.length();
-                                header.skip(len);
-                                consumed-=len;
-                                _gather[0].position(0);
-                                _gather[0].limit(_gather[0].capacity());
-                            }
-                            if (consumed>0 && buffer!=null)
-                            {
-                                int len=consumed<buffer.length()?consumed:buffer.length();
-                                buffer.skip(len);
-                                consumed-=len;
-                                _gather[1].position(0);
-                                _gather[1].limit(_gather[1].capacity());
-                            }
-                            assert consumed==0;
-                        }
-                    }
-                }
-            }
-        }
-        else
-        {
-            _gather[0]=extractOutputBuffer(header,0);
-            synchronized(_gather[0])
-            {
-                _gather[0].position(header.getIndex());
-                _gather[0].limit(header.putIndex());
-
-                int consumed=0;
-                synchronized(_outBuffer)
-                {
-                    try
-                    {
-                        _outNIOBuffer.clear();
-                        _outBuffer.position(0);
-                        _outBuffer.limit(_outBuffer.capacity());
-                        result=_engine.wrap(_gather[0],_outBuffer);
-                        _outNIOBuffer.setGetIndex(0);
-                        _outNIOBuffer.setPutIndex(result.bytesProduced());
-                        consumed=result.bytesConsumed();
-                    }
-                    finally
-                    {
-                        _outBuffer.position(0);
-
-                        if (consumed>0 && header!=null)
-                        {
-                            int len=consumed<header.length()?consumed:header.length();
-                            header.skip(len);
-                            consumed-=len;
-                            _gather[0].position(0);
-                            _gather[0].limit(_gather[0].capacity());
-                        }
-                        assert consumed==0;
-                    }
-                }
-            }
-        }
-
-        flush();
-
-        return result.bytesConsumed();
-    }
-
-    
-    /* ------------------------------------------------------------ */
-    public void flush() throws IOException
-    {
-        while (_outNIOBuffer.length()>0)
-        {
-            int flushed=super.flush(_outNIOBuffer);
-            if (flushed==0)
-            {
-                Thread.yield();
-                flushed=super.flush(_outNIOBuffer);
-                if (flushed==0)
-                    return;
-            }
-        }
-    }
-
-    /* ------------------------------------------------------------ */
-    private ByteBuffer extractInputBuffer(Buffer buffer)
-    {
-        assert buffer instanceof NIOBuffer;
-        NIOBuffer nbuf=(NIOBuffer)buffer;
-        ByteBuffer bbuf=nbuf.getByteBuffer();
-        bbuf.position(buffer.putIndex());
-        return bbuf;
-    }
-    
-    /* ------------------------------------------------------------ */
-    private ByteBuffer extractOutputBuffer(Buffer buffer,int n)
-    {
-        ByteBuffer src=null;
-        NIOBuffer nBuf=null;
-
-        if (buffer.buffer() instanceof NIOBuffer)
-        {
-            nBuf=(NIOBuffer)buffer.buffer();
-            return nBuf.getByteBuffer();
-        }
-        else
-        {
-            if (_reuseBuffer[n]==null)
-                _reuseBuffer[n] = (NIOBuffer)_buffers.getBuffer(_session.getApplicationBufferSize());
-            NIOBuffer buf = _reuseBuffer[n];
-            buf.clear();
-            buf.put(buffer);
-            return buf.getByteBuffer();
-        }
-    }
-
-    /* ------------------------------------------------------------ */
-    private boolean fill(ByteBuffer buffer) throws IOException
-    {
-        int in_len=0;
-
-        if (_inNIOBuffer.hasContent())
-            _inNIOBuffer.compact();
-        else 
-            _inNIOBuffer.clear();
-
-        while (_inNIOBuffer.space()>0)
-        {
-            int len=super.fill(_inNIOBuffer);
-            if (len<=0)
-            {
-                if (len<0)
-                    _engine.closeInbound();
-                if (len==0 || in_len>0)
-                    break;
-                return false;
-            }
-            in_len+=len;
-        }
-        
-
-        if (_inNIOBuffer.length()==0)
-            return false;
-
-        SSLEngineResult result;
-        try
-        {
-            _inBuffer.position(_inNIOBuffer.getIndex());
-            _inBuffer.limit(_inNIOBuffer.putIndex());
-            result=_engine.unwrap(_inBuffer,buffer);
-            _inNIOBuffer.skip(result.bytesConsumed());
-        }
-        finally
-        {
-            _inBuffer.position(0);
-            _inBuffer.limit(_inBuffer.capacity());
-        }
-
-        if (result != null)
-        {
-            switch(result.getStatus())
-            {
-                case OK:
-                    break;
-                case CLOSED:
-                    throw new IOException("sslEngine closed");
-                    
-                case BUFFER_OVERFLOW:
-                    Log.debug("unwrap {}",result);
-                    break;
-                    
-                case BUFFER_UNDERFLOW:
-                    Log.debug("unwrap {}",result);
-                    break;
-                    
-                default:
-                    Log.warn("unwrap "+result);
-                throw new IOException(result.toString());
-            }
-        }
-        
-        return (result.bytesProduced()+result.bytesConsumed())>0;
-    }
-
-    /* ------------------------------------------------------------ */
-    public boolean isBufferingInput()
-    {
-        return _inNIOBuffer.hasContent();
-    }
-
-    /* ------------------------------------------------------------ */
-    public boolean isBufferingOutput()
-    {
-        return _outNIOBuffer.hasContent();
-    }
-
-    /* ------------------------------------------------------------ */
-    public boolean isBufferred()
-    {
-        return true;
-    }
-
-    /* ------------------------------------------------------------ */
-    public SSLEngine getSSLEngine()
-    {
-        return _engine;
-    }
-}
+// ========================================================================
+// Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+// ------------------------------------------------------------------------
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at 
+// http://www.apache.org/licenses/LICENSE-2.0
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+// ========================================================================
+
+package org.mortbay.jetty.security;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLEngineResult;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLEngineResult.HandshakeStatus;
+
+import org.mortbay.io.Buffer;
+import org.mortbay.io.Buffers;
+import org.mortbay.io.nio.NIOBuffer;
+import org.mortbay.io.nio.SelectChannelEndPoint;
+import org.mortbay.io.nio.SelectorManager;
+import org.mortbay.jetty.EofException;
+import org.mortbay.jetty.nio.SelectChannelConnector;
+import org.mortbay.log.Log;
+
+/* ------------------------------------------------------------ */
+/**
+ * SslHttpChannelEndPoint.
+ * 
+ * @author Nik Gonzalez <ngonzalez@exist.com>
+ * @author Greg Wilkins <gregw@mortbay.com>
+ */
+public class SslHttpChannelEndPoint extends SelectChannelConnector.ConnectorEndPoint implements Runnable
+{
+    private static final ByteBuffer[] __NO_BUFFERS={};
+
+    private Buffers _buffers;
+    
+    private SSLEngine _engine;
+    private ByteBuffer _inBuffer;
+    private NIOBuffer _inNIOBuffer;
+    private ByteBuffer _outBuffer;
+    private NIOBuffer _outNIOBuffer;
+
+    private NIOBuffer[] _reuseBuffer=new NIOBuffer[2];    
+    private ByteBuffer[] _gather=new ByteBuffer[2];
+
+    private boolean _closing=false;
+    private SSLEngineResult _result;
+    
+    private boolean _handshook=false;
+    private boolean _allowRenegotiate=false;
+
+
+    // ssl
+    protected SSLSession _session;
+    
+    /* ------------------------------------------------------------ */
+    public SslHttpChannelEndPoint(Buffers buffers,SocketChannel channel, SelectorManager.SelectSet selectSet, SelectionKey key, SSLEngine engine)
+            throws SSLException, IOException
+    {
+        super(channel,selectSet,key);
+        _buffers=buffers;
+        
+        // ssl
+        _engine=engine;
+        _session=engine.getSession();
+
+        // TODO pool buffers and use only when needed.
+        _outNIOBuffer=(NIOBuffer)buffers.getBuffer(_session.getPacketBufferSize());
+        _outBuffer=_outNIOBuffer.getByteBuffer();
+        _inNIOBuffer=(NIOBuffer)buffers.getBuffer(_session.getPacketBufferSize());
+        _inBuffer=_inNIOBuffer.getByteBuffer();
+    }
+
+
+    /* ------------------------------------------------------------ */
+    /**
+     * @return True if SSL re-negotiation is allowed (default false)
+     */
+    public boolean isAllowRenegotiate()
+    {
+        return _allowRenegotiate;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * Set if SSL re-negotiation is allowed. CVE-2009-3555 discovered
+     * a vulnerability in SSL/TLS with re-negotiation.  If your JVM
+     * does not have CVE-2009-3555 fixed, then re-negotiation should 
+     * not be allowed.
+     * @param allowRenegotiate true if re-negotiation is allowed (default false)
+     */
+    public void setAllowRenegotiate(boolean allowRenegotiate)
+    {
+        _allowRenegotiate = allowRenegotiate;
+    }
+
+    /* ------------------------------------------------------------ */
+    // TODO get rid of these dumps
+    public void dump()
+    {
+        System.err.println(_result);
+        // System.err.println(h.toString());
+        // System.err.println("--");
+    }
+    
+    /* ------------------------------------------------------------ */
+    /* (non-Javadoc)
+     * @see org.mortbay.io.nio.SelectChannelEndPoint#idleExpired()
+     */
+    protected void idleExpired()
+    {
+        try
+        {
+            _selectSet.getManager().dispatch(new Runnable()
+            {
+                public void run() 
+                { 
+                    doIdleExpired();
+                }
+            });
+        }
+        catch(Exception e)
+        {
+            Log.ignore(e);
+        }
+    }
+    
+    /* ------------------------------------------------------------ */
+    protected void doIdleExpired()
+    {
+        super.idleExpired();
+    }
+
+    /* ------------------------------------------------------------ */
+    public void close() throws IOException
+    {
+        // TODO - this really should not be done in a loop here - but with async callbacks.
+
+        _closing=true;
+        try
+        {   
+            if (isBufferingOutput())
+            {
+                flush();
+                while (isOpen() && isBufferingOutput())
+                {
+                    Thread.sleep(100); // TODO non blocking
+                    flush();
+                }
+            }
+
+            _engine.closeOutbound();
+
+            loop: while (isOpen() && !(_engine.isInboundDone() && _engine.isOutboundDone()))
+            {   
+                if (isBufferingOutput())
+                {
+                    flush();
+                    while (isOpen() && isBufferingOutput())
+                    {
+                        Thread.sleep(100); // TODO non blocking
+                        flush();
+                    }
+                }
+
+                // System.err.println(_channel+" close "+_engine.getHandshakeStatus()+" "+_closing);
+                switch(_engine.getHandshakeStatus())
+                {
+                    case FINISHED:
+                    case NOT_HANDSHAKING:
+                        _handshook=true;
+                        break loop;
+                        
+                    case NEED_UNWRAP:
+                        Buffer buffer =_buffers.getBuffer(_engine.getSession().getApplicationBufferSize());
+                        try
+                        {
+                            ByteBuffer bbuffer = ((NIOBuffer)buffer).getByteBuffer();
+                            if (!unwrap(bbuffer) && _engine.getHandshakeStatus()==HandshakeStatus.NEED_UNWRAP)
+                            {
+                                break loop;
+                            }
+                        }
+                        catch(SSLException e)
+                        {
+                            Log.ignore(e);
+                        }
+                        finally
+                        {
+                            _buffers.returnBuffer(buffer);
+                        }
+                        break;
+                        
+                    case NEED_TASK:
+                    {
+                        Runnable task;
+                        while ((task=_engine.getDelegatedTask())!=null)
+                        {
+                            task.run();
+                        }
+                        break;
+                    }
+                        
+                    case NEED_WRAP:
+                    {
+                        try
+                        {
+                            _outNIOBuffer.compact();
+                            int put=_outNIOBuffer.putIndex();
+                            _outBuffer.position(put);
+                            _result=null;
+                            _result=_engine.wrap(__NO_BUFFERS,_outBuffer);
+                            _outNIOBuffer.setPutIndex(put+_result.bytesProduced());
+                        }
+                        finally
+                        {
+                            _outBuffer.position(0);
+                        }
+                        
+                        break;
+                    }
+                }
+            }
+        }
+        catch(IOException e)
+        {
+            Log.ignore(e);
+        }
+        catch (InterruptedException e)
+        {
+            Log.ignore(e);
+        }
+        finally
+        {
+            super.close();
+            
+            if (_inNIOBuffer!=null)
+                _buffers.returnBuffer(_inNIOBuffer);
+            if (_outNIOBuffer!=null)
+                _buffers.returnBuffer(_outNIOBuffer);
+            if (_reuseBuffer[0]!=null)
+                _buffers.returnBuffer(_reuseBuffer[0]);
+            if (_reuseBuffer[1]!=null)
+                _buffers.returnBuffer(_reuseBuffer[1]);
+        }   
+    }
+
+
+    
+    /* ------------------------------------------------------------ */
+    /* 
+     */
+    public int fill(Buffer buffer) throws IOException
+    {
+        ByteBuffer bbuf=extractInputBuffer(buffer);
+        int size=buffer.length();
+        HandshakeStatus initialStatus = _engine.getHandshakeStatus();
+        synchronized (bbuf)
+        {
+            try
+            {
+                unwrap(bbuf);
+
+                int wraps=0;
+                loop: while (true)
+                {
+                    if (isBufferingOutput())
+                    {
+                        flush();
+                        if (isBufferingOutput())
+                            break loop;
+                    }
+
+                    // System.err.println(_channel+" fill  "+_engine.getHandshakeStatus()+" "+_closing);
+                    switch(_engine.getHandshakeStatus())
+                    {
+                        case FINISHED:
+                        case NOT_HANDSHAKING:
+                            if (_closing)
+                                return -1;
+                            break loop;
+
+                        case NEED_UNWRAP:
+                            checkRenegotiate();
+                            if (!unwrap(bbuf) && _engine.getHandshakeStatus()==HandshakeStatus.NEED_UNWRAP)
+                            {
+                                break loop;
+                            }
+                            break;
+
+                        case NEED_TASK:
+                        {
+                            Runnable task;
+                            while ((task=_engine.getDelegatedTask())!=null)
+                            {
+                                task.run();
+                            }
+                            
+                            if(initialStatus==HandshakeStatus.NOT_HANDSHAKING && 
+                               _engine.getHandshakeStatus()==HandshakeStatus.NEED_UNWRAP && wraps==0)
+                            {
+                                // This should be NEED_WRAP
+                                // The fix simply detects the signature of the bug and then close the connection (fail-fast) so that ff3 will delegate to using SSL instead of TLS.
+                                // This is a jvm bug on java1.6 where the SSLEngine expects more data from the initial handshake when the client(ff3-tls) already had given it.
+                                // See http://jira.codehaus.org/browse/JETTY-567 for more details
+                                return -1;
+                            }
+                            break;
+                        }
+
+                        case NEED_WRAP:
+                        {
+                            checkRenegotiate();
+                            wraps++;
+                            synchronized(_outBuffer)
+                            {
+                                try
+                                {
+                                    _outNIOBuffer.compact();
+                                    int put=_outNIOBuffer.putIndex();
+                                    _outBuffer.position();
+                                    _result=null;
+                                    _result=_engine.wrap(__NO_BUFFERS,_outBuffer);
+                                    switch(_result.getStatus())
+                                    {
+                                        case BUFFER_OVERFLOW:
+                                        case BUFFER_UNDERFLOW:
+                                            Log.warn("wrap {}",_result);
+                                        case CLOSED:
+                                            _closing=true;
+                                    }
+                                    
+                                    _outNIOBuffer.setPutIndex(put+_result.bytesProduced());
+                                }
+                                finally
+                                {
+                                    _outBuffer.position(0);
+                                }
+                            }
+
+                            flush();
+
+                            break;
+                        }
+                    }
+                }
+            }
+            catch(SSLException e)
+            {
+                Log.warn(e.toString());
+                Log.debug(e);
+                throw e;
+            }
+            finally
+            {
+                buffer.setPutIndex(bbuf.position());
+                bbuf.position(0);
+            }
+            
+            int filled=buffer.length()-size; 
+            if (filled>0)
+                _handshook=true;
+            return filled; 
+        }
+        
+    }
+
+    /* ------------------------------------------------------------ */
+    public int flush(Buffer buffer) throws IOException
+    {
+        return flush(buffer,null,null);
+    }
+
+
+    /* ------------------------------------------------------------ */
+    /*     
+     */
+    public int flush(Buffer header, Buffer buffer, Buffer trailer) throws IOException
+    {   
+        int consumed=0;
+        int available=header.length();
+        if (buffer!=null)
+            available+=buffer.length();
+        
+        int tries=0;
+        loop: while (true)
+        {   
+            if (_outNIOBuffer.length()>0)
+            {
+                flush();
+                if (isBufferingOutput())
+                    break loop;
+            }
+
+            // System.err.println(_channel+" flush "+_engine.getHandshakeStatus()+" "+_closing);
+            switch(_engine.getHandshakeStatus())
+            {
+                case FINISHED:
+                case NOT_HANDSHAKING:
+                    if (_closing || available==0)
+                    {
+                        if (consumed==0)
+                            consumed= -1;
+                        break loop;
+                    }
+                        
+                    int c;
+                    if (header!=null && header.length()>0)
+                    {
+                        if (buffer!=null && buffer.length()>0)
+                            c=wrap(header,buffer);
+                        else
+                            c=wrap(header);
+                    }
+                    else 
+                        c=wrap(buffer);
+                    
+                    if (c>0)
+                    {
+                        _handshook=true;
+                        consumed+=c;
+                        available-=c;
+                    }
+                    else if (c<0)
+                    {
+                        if (consumed==0)
+                            consumed=-1;
+                        break loop;
+                    }
+                    
+                    break;
+
+                case NEED_UNWRAP:
+                    checkRenegotiate();
+                    Buffer buf =_buffers.getBuffer(_engine.getSession().getApplicationBufferSize());
+                    try
+                    {
+                        ByteBuffer bbuf = ((NIOBuffer)buf).getByteBuffer();
+                        if (!unwrap(bbuf) && _engine.getHandshakeStatus()==HandshakeStatus.NEED_UNWRAP)
+                        {
+                            break loop;
+                        }
+                    }
+                    finally
+                    {
+                        _buffers.returnBuffer(buf);
+                    }
+                    
+                    break;
+
+                case NEED_TASK:
+                {
+                    Runnable task;
+                    while ((task=_engine.getDelegatedTask())!=null)
+                    {
+                        task.run();
+                    }
+                    break;
+                }
+
+                case NEED_WRAP:
+                {
+                    checkRenegotiate();
+                    synchronized(_outBuffer)
+                    {
+                        try
+                        {
+                            _outNIOBuffer.compact();
+                            int put=_outNIOBuffer.putIndex();
+                            _outBuffer.position();
+                            _result=null;
+                            _result=_engine.wrap(__NO_BUFFERS,_outBuffer);
+                            switch(_result.getStatus())
+                            {
+                                case BUFFER_OVERFLOW:
+                                case BUFFER_UNDERFLOW:
+                                    Log.warn("wrap {}",_result);
+                                case CLOSED:
+                                    _closing=true;
+                            }
+                            _outNIOBuffer.setPutIndex(put+_result.bytesProduced());
+                        }
+                        finally
+                        {
+                            _outBuffer.position(0);
+                        }
+                    }
+
+                    flush();
+                    if (isBufferingOutput())
+                        break loop;
+
+                    break;
+                }
+            }
+        }
+        
+        return consumed;
+    }
+    
+    /* ------------------------------------------------------------ */
+    public void flush() throws IOException
+    {
+        int len=_outNIOBuffer.length();
+        if (len>0)
+        {
+            int flushed=super.flush(_outNIOBuffer);
+            len=_outNIOBuffer.length();
+            
+            if (len>0)
+            {
+                Thread.yield();
+                flushed=super.flush(_outNIOBuffer);
+                len=_outNIOBuffer.length();
+            }
+        }
+    }
+    
+    /* ------------------------------------------------------------ */
+    private void checkRenegotiate() throws IOException
+    {
+        if (_handshook && !_allowRenegotiate && _channel!=null && _channel.isOpen())
+        {
+            Log.warn("SSL renegotiate denied: "+_channel);
+            close();
+        }   
+    }
+
+    /* ------------------------------------------------------------ */
+    private ByteBuffer extractInputBuffer(Buffer buffer)
+    {
+        assert buffer instanceof NIOBuffer;
+        NIOBuffer nbuf=(NIOBuffer)buffer;
+        ByteBuffer bbuf=nbuf.getByteBuffer();
+        bbuf.position(buffer.putIndex());
+        return bbuf;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * @return true if progress is made
+     */
+    private boolean unwrap(ByteBuffer buffer) throws IOException
+    {
+        if (_inNIOBuffer.hasContent())
+            _inNIOBuffer.compact();
+        else 
+            _inNIOBuffer.clear();
+
+        int total_filled=0;
+        
+        while (_inNIOBuffer.space()>0 && super.isOpen())
+        {
+            try
+            {
+                int filled=super.fill(_inNIOBuffer);
+                if (filled<=0)
+                    break;
+                total_filled+=filled;
+            }
+            catch(IOException e)
+            {
+                if (_inNIOBuffer.length()==0)
+                {
+                    _outNIOBuffer.clear();
+                    throw e;
+                }
+                break;
+            }
+        }
+        
+        if (total_filled==0 && _inNIOBuffer.length()==0)
+        {
+            if(!isOpen())
+            {
+                _outNIOBuffer.clear();
+                throw new EofException();
+            }
+            return false;
+        }
+
+        try
+        {
+            _inBuffer.position(_inNIOBuffer.getIndex());
+            _inBuffer.limit(_inNIOBuffer.putIndex());
+            _result=null;
+            _result=_engine.unwrap(_inBuffer,buffer);
+            _inNIOBuffer.skip(_result.bytesConsumed());
+        }
+        finally
+        {
+            _inBuffer.position(0);
+            _inBuffer.limit(_inBuffer.capacity());
+        }
+        
+        switch(_result.getStatus())
+        {
+            case BUFFER_OVERFLOW:
+                throw new IllegalStateException(_result.toString());                        
+                
+            case BUFFER_UNDERFLOW:
+                if (Log.isDebugEnabled()) 
+                    Log.debug("unwrap {}",_result);
+                if(!isOpen())
+                {
+                    _inNIOBuffer.clear();
+                    _outNIOBuffer.clear();
+                    throw new EofException();
+                }
+                return (total_filled > 0);
+                
+            case CLOSED:
+                _closing=true;
+                
+            case OK:
+                boolean progress=total_filled>0 ||_result.bytesConsumed()>0 || _result.bytesProduced()>0; 
+                return progress;
+            default:
+                Log.warn("unwrap "+_result);
+                throw new IOException(_result.toString());
+        }
+    }
+
+    
+    /* ------------------------------------------------------------ */
+    private ByteBuffer extractOutputBuffer(Buffer buffer,int n)
+    {
+        NIOBuffer nBuf=null;
+
+        if (buffer.buffer() instanceof NIOBuffer)
+        {
+            nBuf=(NIOBuffer)buffer.buffer();
+            return nBuf.getByteBuffer();
+        }
+        else
+        {
+            if (_reuseBuffer[n]==null)
+                _reuseBuffer[n] = (NIOBuffer)_buffers.getBuffer(_session.getApplicationBufferSize());
+            NIOBuffer buf = _reuseBuffer[n];
+            buf.clear();
+            buf.put(buffer);
+            return buf.getByteBuffer();
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    private int wrap(Buffer header, Buffer buffer) throws IOException
+    {
+        _gather[0]=extractOutputBuffer(header,0);
+        synchronized(_gather[0])
+        {
+            _gather[0].position(header.getIndex());
+            _gather[0].limit(header.putIndex());
+
+            _gather[1]=extractOutputBuffer(buffer,1);
+
+            synchronized(_gather[1])
+            {
+                _gather[1].position(buffer.getIndex());
+                _gather[1].limit(buffer.putIndex());
+
+                synchronized(_outBuffer)
+                {
+                    int consumed=0;
+                    try
+                    {
+                        _outNIOBuffer.clear();
+                        _outBuffer.position(0);
+                        _outBuffer.limit(_outBuffer.capacity());
+
+                        _result=null;
+                        _result=_engine.wrap(_gather,_outBuffer);
+                        _outNIOBuffer.setGetIndex(0);
+                        _outNIOBuffer.setPutIndex(_result.bytesProduced());
+                        consumed=_result.bytesConsumed();
+                    }
+                    finally
+                    {
+                        _outBuffer.position(0);
+
+                        if (consumed>0 && header!=null)
+                        {
+                            int len=consumed<header.length()?consumed:header.length();
+                            header.skip(len);
+                            consumed-=len;
+                            _gather[0].position(0);
+                            _gather[0].limit(_gather[0].capacity());
+                        }
+                        if (consumed>0 && buffer!=null)
+                        {
+                            int len=consumed<buffer.length()?consumed:buffer.length();
+                            buffer.skip(len);
+                            consumed-=len;
+                            _gather[1].position(0);
+                            _gather[1].limit(_gather[1].capacity());
+                        }
+                        assert consumed==0;
+                    }
+                }
+            }
+        }
+        
+
+        switch(_result.getStatus())
+        {
+            case BUFFER_OVERFLOW:
+            case BUFFER_UNDERFLOW:
+                Log.warn("wrap {}",_result);
+                
+            case OK:
+                return _result.bytesConsumed();
+            case CLOSED:
+                _closing=true;
+                return _result.bytesConsumed()>0?_result.bytesConsumed():-1;
+
+            default:
+                Log.warn("wrap "+_result);
+            throw new IOException(_result.toString());
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    private int wrap(Buffer buffer) throws IOException
+    {
+        _gather[0]=extractOutputBuffer(buffer,0);
+        synchronized(_gather[0])
+        {
+            _gather[0].position(buffer.getIndex());
+            _gather[0].limit(buffer.putIndex());
+
+            int consumed=0;
+            synchronized(_outBuffer)
+            {
+                try
+                {
+                    _outNIOBuffer.clear();
+                    _outBuffer.position(0);
+                    _outBuffer.limit(_outBuffer.capacity());
+                    _result=null;
+                    _result=_engine.wrap(_gather[0],_outBuffer);
+                    _outNIOBuffer.setGetIndex(0);
+                    _outNIOBuffer.setPutIndex(_result.bytesProduced());
+                    consumed=_result.bytesConsumed();
+                }
+                finally
+                {
+                    _outBuffer.position(0);
+
+                    if (consumed>0 && buffer!=null)
+                    {
+                        int len=consumed<buffer.length()?consumed:buffer.length();
+                        buffer.skip(len);
+                        consumed-=len;
+                        _gather[0].position(0);
+                        _gather[0].limit(_gather[0].capacity());
+                    }
+                    assert consumed==0;
+                }
+            }
+        }
+        switch(_result.getStatus())
+        {
+            case BUFFER_OVERFLOW:
+            case BUFFER_UNDERFLOW:
+                Log.warn("wrap {}",_result);
+                
+            case OK:
+                return _result.bytesConsumed();
+            case CLOSED:
+                _closing=true;
+                return _result.bytesConsumed()>0?_result.bytesConsumed():-1;
+
+            default:
+                Log.warn("wrap "+_result);
+            throw new IOException(_result.toString());
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    public boolean isBufferingInput()
+    {
+        return _inNIOBuffer.hasContent();
+    }
+
+    /* ------------------------------------------------------------ */
+    public boolean isBufferingOutput()
+    {
+        return _outNIOBuffer.hasContent();
+    }
+
+    /* ------------------------------------------------------------ */
+    public boolean isBufferred()
+    {
+        return true;
+    }
+
+    /* ------------------------------------------------------------ */
+    public SSLEngine getSSLEngine()
+    {
+        return _engine;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String toString()
+    {
+        return super.toString()+","+_engine.getHandshakeStatus()+", in/out="+_inNIOBuffer.length()+"/"+_outNIOBuffer.length()+" "+_result;
+    }
+}

Property changes on: extras/sslengine/src/main/java/org/mortbay/jetty/security/SslHttpChannelEndPoint.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: extras/sslengine/src/main/resources/jetty-sslengine.xml
===================================================================
--- extras/sslengine/src/main/resources/jetty-sslengine.xml	(revision 5689)
+++ extras/sslengine/src/main/resources/jetty-sslengine.xml	(working copy)
@@ -1,25 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure//EN" "http://jetty.mortbay.org/configure.dtd">
-
-<!-- =============================================================== -->
-<!-- Configure SSL for the Jetty Server                              -->
-<!-- this configuration file should be used in combination with      -->
-<!-- other configuration files.  e.g.                                -->
-<!--    java -jar start.jar etc/jetty.xml etc/jetty-ssl.xml          -->
-<!-- =============================================================== -->
-<Configure id="Server" class="org.mortbay.jetty.Server">
-  <Call name="addConnector">
-    <Arg>
-      <New class="org.mortbay.jetty.security.SslSelectChannelConnector">
-	<Set name="Port">8444</Set>
-	<Set name="maxIdleTime">30000</Set>
-        <Set name="Acceptors">2</Set>
-        <Set name="AcceptQueueSize">100</Set>
-	<Set name="Keystore"><SystemProperty name="jetty.home" default="." />/etc/keystore</Set>
-	<Set name="Password">OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4</Set>
-	<Set name="KeyPassword">OBF:1u2u1wml1z7s1z7a1wnl1u2g</Set>
-      </New>
-    </Arg>
-  </Call>
-        
-</Configure>
Index: extras/sslengine/pom.xml
===================================================================
--- extras/sslengine/pom.xml	(revision 5689)
+++ extras/sslengine/pom.xml	(working copy)
@@ -38,7 +38,7 @@
             <configuration>
               <tasks>
                 <copy failonerror="false" file="target/${project.artifactId}-${project.version}.${project.packaging}" todir="../../lib/ext" />
-                <copy failonerror="false" file="src/main/resources/jetty-sslengine.xml" todir="../../etc" />
+                <copy failonerror="false" file="src/main/config/etc/jetty-sslengine.xml" todir="../../etc" />
               </tasks>
             </configuration>
           </execution>

Property changes on: extras/ajp
___________________________________________________________________
Modified: svn:ignore
   - target
.classpath
.settings
.project

   + 
*.diff
*.iml
*.ipr
*.iws
*.log
*.patch
*.swp
*~
.classpath
.fbprefs
.pmd
.project
.settings
target


Index: extras/ajp/src/test/java/org/mortbay/jetty/ajp/TestAjpParser.java
===================================================================
--- extras/ajp/src/test/java/org/mortbay/jetty/ajp/TestAjpParser.java	(revision 5689)
+++ extras/ajp/src/test/java/org/mortbay/jetty/ajp/TestAjpParser.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty.ajp;
 
 import java.io.IOException;
@@ -3,5 +17,4 @@
 
 import org.mortbay.io.Buffer;
-import org.mortbay.io.Buffers;
 import org.mortbay.io.ByteArrayBuffer;
 import org.mortbay.io.ByteArrayEndPoint;
@@ -25,7 +38,9 @@
         
         EndPoint endp = new ByteArrayEndPoint(src,Ajp13Packet.MAX_PACKET_SIZE);
         
-        Ajp13Parser parser = new Ajp13Parser(buffers,endp,new EH(),new Ajp13Generator(buffers,endp,0,0));
+        Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+        parser.setEventHandler(new EH());
+        parser.setGenerator(new Ajp13Generator(buffers,endp,0,0));
         
         parser.parseAvailable();
         
@@ -40,7 +55,9 @@
         SimpleBuffers buffers=new SimpleBuffers(new Buffer[]
         { buffer });
         EndPoint endp=new ByteArrayEndPoint(src,Ajp13Packet.MAX_PACKET_SIZE);
-        Ajp13Parser parser=new Ajp13Parser(buffers,endp,new EH(),new Ajp13Generator(buffers,endp,0,0));
+        Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+        parser.setEventHandler(new EH());
+        parser.setGenerator(new Ajp13Generator(buffers,endp,0,0));
         parser.parse();
         assertTrue(true);
     }    
@@ -53,13 +70,15 @@
         SimpleBuffers buffers=new SimpleBuffers(new Buffer[]
         { buffer });
         EndPoint endp=new ByteArrayEndPoint(src,Ajp13Packet.MAX_PACKET_SIZE);
-        Ajp13Parser parser=new Ajp13Parser(buffers,endp,new EH(),new Ajp13Generator(buffers,endp,0,0));
+        Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+        parser.setEventHandler(new EH());
+        parser.setGenerator(new Ajp13Generator(buffers,endp,0,0));
         parser.parse();
         assertTrue(true);
     }
     
     
-    public void testSSLPacket() throws Exception
+    public void testSSLPacketWithIntegerKeySize() throws Exception
     {
         String packet = "1234025002020008485454502f312e3100000f2f746573742f64756d702f696e666f00000e3139322e3136382e3130302e343000ffff000c776562746964652d746573740001bb01000ca00b000c776562746964652d7465737400a00e005a4d6f7a696c6c612f352e30202857696e646f77733b20553b2057696e646f7773204e5420352e313b20656e2d55533b2072763a312e382e312e3129204765636b6f2f32303036313230342046697265666f782f322e302e302e3100a0010063746578742f786d6c2c6170706c69636174696f6e2f786d6c2c6170706c69636174696f6e2f7868746d6c2b786d6c2c746578742f68746d6c3b713d302e392c746578742f706c61696e3b713d302e382c696d6167652f706e672c2a2f2a3b713d302e3500a004000e656e2d75732c656e3b713d302e3500a003000c677a69702c6465666c61746500a002001e49534f2d383835392d312c7574662d383b713d302e372c2a3b713d302e3700000a4b6565702d416c69766500000333303000a006000a6b6565702d616c69766500a00d001a68747470733a2f2f776562746964652d746573742f746573742f00a00900174a53455353494f4e49443d69326c6e307539773573387300000d43616368652d436f6e74726f6c0000096d61782d6167653d3000000c4d61782d466f7277617264730000023130000800124448452d5253412d4145533235362d5348410009004032413037364245323330433238393130383941414132303631344139384441443131314230323132343030374130363642454531363742303941464337383942000b0100ff";
         byte[] src = TypeUtil.fromHexString(packet);
@@ -69,12 +88,33 @@
         
         EndPoint endp = new ByteArrayEndPoint(src,Ajp13Packet.MAX_PACKET_SIZE);
         
-        Ajp13Parser parser = new Ajp13Parser(buffers,endp,new EH(),new Ajp13Generator(buffers,endp,0,0));
+        Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+        parser.setEventHandler(new EH());
+        parser.setGenerator(new Ajp13Generator(buffers,endp,0,0));
         
         parser.parseAvailable();
         
         assertTrue(true);
-    }    
+    }
+
+    public void testSSLPacketWithStringKeySize() throws Exception
+    {
+        String packet = "1234025002020008485454502f312e3100000f2f746573742f64756d702f696e666f00000e3139322e3136382e3130302e343000ffff000c776562746964652d746573740001bb01000ca00b000c776562746964652d7465737400a00e005a4d6f7a696c6c612f352e30202857696e646f77733b20553b2057696e646f7773204e5420352e313b20656e2d55533b2072763a312e382e312e3129204765636b6f2f32303036313230342046697265666f782f322e302e302e3100a0010063746578742f786d6c2c6170706c69636174696f6e2f786d6c2c6170706c69636174696f6e2f7868746d6c2b786d6c2c746578742f68746d6c3b713d302e392c746578742f706c61696e3b713d302e382c696d6167652f706e672c2a2f2a3b713d302e3500a004000e656e2d75732c656e3b713d302e3500a003000c677a69702c6465666c61746500a002001e49534f2d383835392d312c7574662d383b713d302e372c2a3b713d302e3700000a4b6565702d416c69766500000333303000a006000a6b6565702d616c69766500a00d001a68747470733a2f2f776562746964652d746573742f746573742f00a00900174a53455353494f4e49443d69326c6e307539773573387300000d43616368652d436f6e74726f6c0000096d61782d6167653d3000000c4d61782d466f7277617264730000023130000800124448452d5253412d4145533235362d5348410009004032413037364245323330433238393130383941414132303631344139384441443131314230323132343030374130363642454531363742303941464337383942000b000332353600ff";
+        byte[] src = TypeUtil.fromHexString(packet);
+        
+        ByteArrayBuffer buffer= new ByteArrayBuffer(Ajp13Packet.MAX_PACKET_SIZE);
+        SimpleBuffers buffers=new SimpleBuffers(new Buffer[]{buffer});
+        
+        EndPoint endp = new ByteArrayEndPoint(src,Ajp13Packet.MAX_PACKET_SIZE);
+        
+        Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+        parser.setEventHandler(new EH());
+        parser.setGenerator(new Ajp13Generator(buffers,endp,0,0));
+        
+        parser.parseAvailable();
+        
+        assertTrue(true);
+    }
     
     
     public void testSSLPacketFragment() throws Exception
@@ -96,7 +136,9 @@
             ByteArrayEndPoint endp = new ByteArrayEndPoint(frag0,Ajp13Packet.MAX_PACKET_SIZE);
             endp.setNonBlocking(true);
         
-            Ajp13Parser parser = new Ajp13Parser(buffers,endp,new EH(),new Ajp13Generator(buffers,endp,0,0));
+            Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+            parser.setEventHandler(new EH());
+            parser.setGenerator(new Ajp13Generator(buffers,endp,0,0));
             parser.parseNext();
             
             endp.setIn(new ByteArrayBuffer(frag1));
@@ -110,19 +152,100 @@
     
     public void testPacketWithBody() throws Exception
     {
-        String packet=getPacketWithBody();
+        String packet=getTestHeader();
         byte[] src=TypeUtil.fromHexString(packet);
         ByteArrayBuffer buffer=new ByteArrayBuffer(Ajp13Packet.MAX_PACKET_SIZE);
         SimpleBuffers buffers=new SimpleBuffers(new Buffer[]
         { buffer });
-        EndPoint endp=new ByteArrayEndPoint(src,Ajp13Packet.MAX_PACKET_SIZE);
-        Ajp13Parser parser=new Ajp13Parser(buffers,endp,new EH(),new Ajp13Generator(buffers,endp,0,0));
-        parser.parse();
+        ByteArrayEndPoint endp=new ByteArrayEndPoint(src,Ajp13Packet.MAX_PACKET_SIZE);
+        endp.setNonBlocking(true);
+        
+        final int count[]={0};
+        Ajp13Generator gen = new Ajp13Generator(buffers,endp,0,0)
+        {
+            public void getBodyChunk() throws IOException
+            {
+                count[0]++;
+                super.getBodyChunk();
+            }
+        };
+        Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+        parser.setEventHandler(new EH());
+        parser.setGenerator(gen);
+        
+        parser.parseNext();
+        assertEquals(1,parser.getState());
+        assertEquals(0,count[0]);
+        
+        endp.setIn(new ByteArrayBuffer(TypeUtil.fromHexString(getTestShortBody())));
+
+        parser.parseNext();
+        assertEquals(1,parser.getState());
+        assertEquals(1,count[0]);
+        
+        endp.setIn(new ByteArrayBuffer(TypeUtil.fromHexString(getTestTinyBody())));
+
+        parser.parseNext();
+        parser.parseNext();
+        assertEquals(0,parser.getState());
+        assertEquals(1,count[0]);
+        
         assertTrue(true);
     }
 
 
     
+    public void testPacketWithChunkedBody() throws Exception
+    {
+        String packet="123400ff02040008485454502f312e3100000f2f746573742f64756d702f696e666f0000093132372e302e302e3100ffff00096c6f63616c686f7374000050000007a00e000d4a6176612f312e352e305f313100a00b00096c6f63616c686f737400a0010034746578742f68746d6c2c20696d6167652f6769662c20696d6167652f6a7065672c202a3b20713d2e322c202a2f2a3b20713d2e3200a006000a6b6565702d616c69766500a00700216170706c69636174696f6e2f782d7777772d666f726d2d75726c656e636f6465640000115472616e736665722d456e636f64696e670000076368756e6b656400000c4d61782d466f727761726473000002313000ff";
+        byte[] src=TypeUtil.fromHexString(packet);
+        ByteArrayBuffer buffer=new ByteArrayBuffer(Ajp13Packet.MAX_PACKET_SIZE);
+        SimpleBuffers buffers=new SimpleBuffers(new Buffer[]
+        { buffer });
+        ByteArrayEndPoint endp=new ByteArrayEndPoint(src,Ajp13Packet.MAX_PACKET_SIZE);
+        endp.setNonBlocking(true);
+        
+        final int count[]={0};
+        Ajp13Generator gen = new Ajp13Generator(buffers,endp,0,0)
+        {
+            public void getBodyChunk() throws IOException
+            {
+                count[0]++;
+                super.getBodyChunk();
+            }
+        };
+        Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+        parser.setEventHandler(new EH());
+        parser.setGenerator(gen);
+        
+        parser.parseNext();
+        assertEquals(1,parser.getState());
+        assertEquals(1,count[0]);
+        
+        endp.setIn(new ByteArrayBuffer(TypeUtil.fromHexString("1234007e007c7468656e616d653d746865253230717569636b25323062726f776e253230666f782532306a756d70732532306f766572253230746f2532307468652532306c617a79253230646f67253230544845253230515549434b25323042524f574e253230464f582532304a554d50532532304f564552253230544f25323054")));
+
+        while (parser.parseNext()>0);
+        assertEquals(1,parser.getState());
+        assertEquals(2,count[0]);
+        
+        endp.setIn(new ByteArrayBuffer(TypeUtil.fromHexString("12340042004048452532304c415a59253230444f472532302676616c75656f66323d6162636465666768696a6b6c6d6e6f707172737475767778797a31323334353637383930")));
+
+        while (parser.parseNext()>0);
+        assertEquals(1,parser.getState());
+        assertEquals(3,count[0]);
+        
+        endp.setIn(new ByteArrayBuffer(TypeUtil.fromHexString("123400020000")));
+
+        while (parser.getState()!=0 && parser.parseNext()>0);
+        assertEquals(0,parser.getState());
+        assertEquals(3,count[0]);
+        
+        assertTrue(true);
+    }
+
+    
+
+    
     public void testPacketFragment() throws Exception
     {
         String packet = "123401070202000f77696474683d20485454502f312e300000122f636f6e74726f6c2f70726f647563742f2200000e3230382e32372e3230332e31323800ffff000c7777772e756c74612e636f6d000050000005a006000a6b6565702d616c69766500a00b000c7777772e756c74612e636f6d00a00e002b4d6f7a696c6c612f342e302028636f6d70617469626c653b20426f726465724d616e6167657220332e302900a0010043696d6167652f6769662c20696d6167652f782d786269746d61702c20696d6167652f6a7065672c20696d6167652f706a7065672c20696d6167652f706d672c202a2f2a00a008000130000600067570726f64310008000a4145533235362d53484100ff";
@@ -142,7 +265,9 @@
             ByteArrayEndPoint endp = new ByteArrayEndPoint(frag0,Ajp13Packet.MAX_PACKET_SIZE);
             endp.setNonBlocking(true);
         
-            Ajp13Parser parser = new Ajp13Parser(buffers,endp,new EH(),new Ajp13Generator(buffers,endp,0,0));
+            Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+            parser.setEventHandler(new EH());
+            parser.setGenerator(new Ajp13Generator(buffers,endp,0,0));
             parser.parseNext();
             
             endp.setIn(new ByteArrayBuffer(frag1));
@@ -156,7 +281,7 @@
     
     public void testPacketFragmentWithBody() throws Exception
     {
-        String packet = getPacketWithBody();
+        String packet = getTestHeader()+getTestBody();
         byte[] src = TypeUtil.fromHexString(packet);
         
         for (int f=1;f<src.length;f++)
@@ -172,8 +297,10 @@
         
             ByteArrayEndPoint endp = new ByteArrayEndPoint(frag0,Ajp13Packet.MAX_PACKET_SIZE);
             endp.setNonBlocking(true);
-        
-            Ajp13Parser parser = new Ajp13Parser(buffers,endp,new EH(),new Ajp13Generator(buffers,endp,0,0));
+            
+            Ajp13Parser parser = new Ajp13Parser(buffers,endp);
+            parser.setEventHandler(new EH());
+            parser.setGenerator(new Ajp13Generator(buffers,endp,0,0));
             parser.parseNext();
             
             endp.setIn(new ByteArrayBuffer(frag1));
@@ -184,10 +311,9 @@
     }
     
     
-    private String getPacketWithBody()
+    private String getTestHeader()
     {
         StringBuffer header = new StringBuffer("");
-        StringBuffer body = new StringBuffer("");
         
         
         header.append("1234026902040008485454502f31");
@@ -231,9 +357,16 @@
         header.append("64313d32266964323d696d673200ff");
 
         
+        return header.toString();
         
+    }
+
+    private String getTestBody()
+    {
+        StringBuffer body = new StringBuffer("");
         
         
+        
         body.append("123402f902f72d2d2d2d2d2d2d2d");
         body.append("2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d");
         body.append("2d2d2d2d2d3934333833323534323630");
@@ -284,11 +417,77 @@
         body.append("33383332353432363038372d2d0d0a");
         
        
+        return  body.toString();
         
+    }
+    
+    
+    private String getTestShortBody()
+    {
+        StringBuffer body = new StringBuffer("");
         
-        return header.toString() + body.toString();
+        body.append("123402f702f52d2d2d2d2d2d2d2d");
+        body.append("2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d");
+        body.append("2d2d2d2d2d3934333833323534323630");
+        body.append("38370d0a436f6e74656e742d44697370");
+        body.append("6f736974696f6e3a20666f726d2d6461");
+        body.append("74613b206e616d653d227265636f7264");
+        body.append("4964220d0a0d0a320d0a2d2d2d2d2d2d");
+        body.append("2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d");
+        body.append("2d2d2d2d2d2d2d393433383332353432");
+        body.append("363038370d0a436f6e74656e742d4469");
+        body.append("73706f736974696f6e3a20666f726d2d");
+        body.append("646174613b206e616d653d226e616d65");
+        body.append("220d0a0d0a4974656d0d0a2d2d2d2d2d");
+        body.append("2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d");
+        body.append("2d2d2d2d2d2d2d2d3934333833323534");
+        body.append("32363038370d0a436f6e74656e742d44");
+        body.append("6973706f736974696f6e3a20666f726d");
+        body.append("2d646174613b206e616d653d22746e49");
+        body.append("6d674964220d0a0d0a696d67320d0a2d");
+        body.append("2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d");
+        body.append("2d2d2d2d2d2d2d2d2d2d2d2d39343338");
+        body.append("3332353432363038370d0a436f6e7465");
+        body.append("6e742d446973706f736974696f6e3a20");
+        body.append("666f726d2d646174613b206e616d653d");
+        body.append("227468756d624e61696c496d61676546");
+        body.append("696c65223b2066696c656e616d653d22");
+        body.append("6161612e747874220d0a436f6e74656e");
+        body.append("742d547970653a20746578742f706c61");
+        body.append("696e0d0a0d0a61616161616161616161");
+        body.append("61616161616161616161616161616161");
+        body.append("61616161616161616161616161616161");
+        body.append("61616161616161616161616161616161");
+        body.append("0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d");
+        body.append("2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d39");
+        body.append("3433383332353432363038370d0a436f");
+        body.append("6e74656e742d446973706f736974696f");
+        body.append("6e3a20666f726d2d646174613b206e61");
+        body.append("6d653d226c61726765496d6167654669");
+        body.append("6c65223b2066696c656e616d653d2261");
+        body.append("61612e747874220d0a436f6e74656e74");
+        body.append("2d547970653a20746578742f706c6169");
+        body.append("6e0d0a0d0a6161616161616161616161");
+        body.append("61616161616161616161616161616161");
+        body.append("61616161616161616161616161616161");
+        body.append("6161616161616161616161616161610d");
+        body.append("0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d");
+        body.append("2d2d2d2d2d2d2d2d2d2d2d2d2d2d3934");
+        body.append("33383332353432363038372d2d");
         
+       
+        return  body.toString();
+        
     }
+    private String getTestTinyBody()
+    {
+        StringBuffer body = new StringBuffer("");
+        
+        body.append("123400042d2d0d0a");
+       
+        return  body.toString();
+        
+    }
     
     
     private static class EH implements Ajp13Parser.EventHandler
@@ -407,6 +606,11 @@
         {
             //To change body of implemented methods use File | Settings | File Templates.
         }
+        
+        public void parsedSslKeySize(int keySize) throws IOException
+        {
+            // System.err.println(key+":: "+value);
+        }
 
         public void parsedRequestAttribute(String key, int value) throws IOException
         {
Index: extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13SocketConnector.java
===================================================================
--- extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13SocketConnector.java	(revision 5689)
+++ extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13SocketConnector.java	(working copy)
@@ -56,8 +56,8 @@
 
     protected void doStart() throws Exception
     {
-        Log.info("AJP13 is not a secure protocol. Please protect port {}",Integer.toString(getPort()));
         super.doStart();
+        Log.info("AJP13 is not a secure protocol. Please protect port {}",Integer.toString(getLocalPort()));
     }
     
     
@@ -83,14 +83,14 @@
     // Secured on a packet by packet bases not by connection
     public boolean isConfidential(Request request)
     {
-        throw new UnsupportedOperationException();
+        return ((Ajp13Request) request).isSslSecure();
     }
 
     /* ------------------------------------------------------------ */
     // Secured on a packet by packet bases not by connection
     public boolean isIntegral(Request request)
     {
-        throw new UnsupportedOperationException();
+        return ((Ajp13Request) request).isSslSecure();
     }
 
     /* ------------------------------------------------------------ */
Index: extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Generator.java
===================================================================
--- extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Generator.java	(revision 5689)
+++ extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Generator.java	(working copy)
@@ -370,25 +370,29 @@
             int field_index = _buffer.putIndex();
             addInt(0);
 
-            // Add headers
-            Iterator i = fields.getFields();
             int num_fields = 0;
 
-            while (i.hasNext())
-            {
-                num_fields++;
-                Field f = (Field) i.next();
+            if (fields != null)
+            { 
+                // Add headers
+                Iterator i = fields.getFields();
 
-                byte[] codes = (byte[]) __headerHash.get(f.getName());
-                if (codes != null)
+                while (i.hasNext())
                 {
-                    _buffer.put(codes);
+                    num_fields++;
+                    Field f = (Field) i.next();
+
+                    byte[] codes = (byte[]) __headerHash.get(f.getName());
+                    if (codes != null)
+                    {
+                        _buffer.put(codes);
+                    }
+                    else
+                    {
+                        addString(f.getName());
+                    }
+                    addString(f.getValue());
                 }
-                else
-                {
-                    addString(f.getName());
-                }
-                addString(f.getValue());
             }
 
             if (!has_server && _status > 100 && getSendServerVersion())
Index: extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Request.java
===================================================================
--- extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Request.java	(revision 5689)
+++ extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Request.java	(working copy)
@@ -1,73 +1,113 @@
-package org.mortbay.jetty.ajp;
-
-import org.mortbay.jetty.HttpConnection;
-import org.mortbay.jetty.Request;
-
-public class Ajp13Request extends Request
-{
-    protected String _remoteAddr;
-    protected String _remoteHost;
-    protected String _remoteUser;
-    protected HttpConnection _connection;
-
-
-
-    public Ajp13Request(HttpConnection connection)
-    {
-        super(connection);
-        _remoteAddr = null;
-        _remoteHost = null;
-        _remoteUser = null;
-        
-    }
-
-    public void setRemoteUser(String remoteUser)
-    {
-        _remoteUser = remoteUser;
-    }
-
-    public String getRemoteUser()
-    {
-        if(_remoteUser != null)
-            return _remoteUser;
-        return super.getRemoteUser();
-    }
-
-    public String getRemoteAddr()
-    {
-        if (_remoteAddr != null)
-            return _remoteAddr;
-        if (_remoteHost != null)
-            return _remoteHost;
-        return super.getRemoteAddr();
-    }
-
-
-
-    public void setRemoteAddr(String remoteAddr)
-    {
-        _remoteAddr = remoteAddr;
-    }
-
-    public String getRemoteHost()
-    {
-        if (_remoteHost != null)
-            return _remoteHost;
-        if (_remoteAddr != null)
-            return _remoteAddr;
-        return super.getRemoteHost();
-    }
-
-    public void setRemoteHost(String remoteHost)
-    {
-        _remoteHost = remoteHost;
-    }
-
-    protected void recycle()
-    {
-        super.recycle();
-        _remoteAddr = null;
-        _remoteHost = null;
-    }
-
-}
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
+package org.mortbay.jetty.ajp;
+
+import org.mortbay.jetty.HttpConnection;
+import org.mortbay.jetty.Request;
+
+public class Ajp13Request extends Request
+{
+    protected String _remoteAddr;
+    protected String _remoteHost;
+    protected String _remoteUser;
+    protected boolean _sslSecure;
+
+    /* ------------------------------------------------------------ */
+    public Ajp13Request()
+    {
+        super();
+        _remoteAddr = null;
+        _remoteHost = null;
+        _remoteUser = null;        
+        _sslSecure = false;
+    }
+
+    /* ------------------------------------------------------------ */
+    protected void setConnection(HttpConnection connection)
+    {
+        super.setConnection(connection);
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setRemoteUser(String remoteUser)
+    {
+        _remoteUser = remoteUser;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getRemoteUser()
+    {
+        if(_remoteUser != null)
+            return _remoteUser;
+        return super.getRemoteUser();
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getRemoteAddr()
+    {
+        if (_remoteAddr != null)
+            return _remoteAddr;
+        if (_remoteHost != null)
+            return _remoteHost;
+        return super.getRemoteAddr();
+    }
+
+
+
+    /* ------------------------------------------------------------ */
+    public void setRemoteAddr(String remoteAddr)
+    {
+        _remoteAddr = remoteAddr;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getRemoteHost()
+    {
+        if (_remoteHost != null)
+            return _remoteHost;
+        if (_remoteAddr != null)
+            return _remoteAddr;
+        return super.getRemoteHost();
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setRemoteHost(String remoteHost)
+    {
+        _remoteHost = remoteHost;
+    }
+
+    /* ------------------------------------------------------------ */
+    public boolean isSslSecure()
+    {
+        return _sslSecure;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setSslSecure(boolean sslSecure)
+    {
+        _sslSecure = sslSecure;
+    }
+
+    /* ------------------------------------------------------------ */
+    protected void recycle()
+    {
+        super.recycle();
+        _remoteAddr = null;
+        _remoteHost = null;
+        _remoteUser = null;
+        _sslSecure = false;
+    }
+
+}

Property changes on: extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Request.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Parser.java
===================================================================
--- extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Parser.java	(revision 5689)
+++ extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Parser.java	(working copy)
@@ -60,14 +60,23 @@
     
 
     /* ------------------------------------------------------------------------------- */
-    public Ajp13Parser(Buffers buffers, EndPoint endPoint, EventHandler handler, Ajp13Generator generator)
+    public Ajp13Parser(Buffers buffers, EndPoint endPoint)
     {
         _buffers = buffers;
         _endp = endPoint;
-        _handler = handler;
-        _generator = generator;
-
     }
+    
+    /* ------------------------------------------------------------------------------- */
+    public void setEventHandler(EventHandler handler)
+    {
+        _handler=handler;
+    }
+    
+    /* ------------------------------------------------------------------------------- */
+    public void setGenerator(Ajp13Generator generator)
+    {
+        _generator=generator;
+    }
 
     /* ------------------------------------------------------------------------------- */
     public long getContentLength()
@@ -170,8 +179,12 @@
             }
 
             _buffer = _body;
-            filled = _buffer.length();
-            return filled;
+            
+            if (_buffer.length()>0)
+            {            
+                filled = _buffer.length();
+                return filled;
+            }
         }
 
         if (_buffer.markIndex() == 0 && _buffer.putIndex() == _buffer.capacity())
@@ -342,7 +355,7 @@
                 if (bufHeaderName != null && bufHeaderName.toString().equals(Ajp13RequestHeaders.CONTENT_LENGTH))
                 {
                     _contentLength = BufferUtil.toLong(bufHeaderValue);
-                    if (_contentLength <= 0)
+                    if (_contentLength == 0)
                         _contentLength = HttpTokens.NO_CONTENT;
                 }
 
@@ -404,7 +417,8 @@
                         
                     case Ajp13RequestHeaders.SSL_KEYSIZE_ATTR:
                         
-                        // This has been implemented as either a string or a integer.
+                        // This has been implemented in AJP13 as either a string or a integer.
+                        // Servlet specs say javax.servlet.request.key_size must be an Integer
                         
                         // Does it look like a string containing digits?
                         int length = Ajp13RequestPacket.getInt(_buffer);
@@ -413,10 +427,10 @@
                         {
                             // this must be a string length rather than a key length
                             _buffer.skip(-2);
-                            _handler.parsedRequestAttribute("javax.servlet.request.key_size", Ajp13RequestPacket.getString(_buffer, _tok1));
+                            _handler.parsedSslKeySize(Integer.parseInt(Ajp13RequestPacket.getString(_buffer, _tok1).toString()));
                         }
                         else
-                            _handler.parsedRequestAttribute("javax.servlet.request.key_size",length);
+                            _handler.parsedSslKeySize(length);
                         
                         break;
 
@@ -464,7 +478,7 @@
             _contentPosition = 0;
             switch ((int) _contentLength)
             {
-                case HttpTokens.UNKNOWN_CONTENT:
+
                 case HttpTokens.NO_CONTENT:
                     _state = STATE_END;
                     _handler.headerComplete();
@@ -472,6 +486,19 @@
 
                     break;
 
+                case HttpTokens.UNKNOWN_CONTENT:
+
+                    _generator.getBodyChunk();
+                    if (_buffers != null && _body == null && _buffer == _header && _header.length() <= 0)
+                    {
+                        _body = _buffers.getBuffer(Ajp13Packet.MAX_PACKET_SIZE);
+                        _body.clear();
+                    }
+                    _state = STATE_AJP13CHUNK_START;
+                    _handler.headerComplete(); // May recurse here!
+
+                    return total_filled;
+
                 default:
 
                     if (_buffers != null && _body == null && _buffer == _header && _contentLength > (_header.capacity() - _header.getIndex()))
@@ -514,6 +541,7 @@
                     if (_chunkLength==0)
                     {
                         _state=STATE_END;
+                         _generator.gotBody();
                         _handler.messageComplete(_contentPosition);
                         return total_filled;
                     }
@@ -561,7 +589,7 @@
                     if (remaining==0)
                     {
                         _state=STATE_AJP13CHUNK_START;
-                        if (_contentPosition<_contentLength)
+                        if (_contentPosition<_contentLength || _contentLength == HttpTokens.UNKNOWN_CONTENT)
                         {
                             _generator.getBodyChunk();
                         }
@@ -740,12 +768,12 @@
 
         public void parsedSslSession(Buffer sslSession) throws IOException;
 
+        public void parsedSslKeySize(int keySize) throws IOException;
 
 
 
 
 
-
     }
 
     /* ------------------------------------------------------------ */
Index: extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Connection.java
===================================================================
--- extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Connection.java	(revision 5689)
+++ extras/ajp/src/main/java/org/mortbay/jetty/ajp/Ajp13Connection.java	(working copy)
@@ -14,14 +14,21 @@
 
 package org.mortbay.jetty.ajp;
 
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.Collection;
+import java.util.Iterator;
 
 import javax.servlet.ServletInputStream;
+import javax.servlet.http.HttpServletResponse;
 
 import org.mortbay.io.Buffer;
 import org.mortbay.io.EndPoint;
 import org.mortbay.jetty.Connector;
 import org.mortbay.jetty.HttpConnection;
+import org.mortbay.jetty.HttpException;
 import org.mortbay.jetty.Request;
 import org.mortbay.jetty.Server;
 
@@ -34,27 +41,27 @@
  */
 public class Ajp13Connection extends HttpConnection
 {
-    private boolean _sslSecure = false;
-
     public Ajp13Connection(Connector connector, EndPoint endPoint, Server server)
     {
-        super(connector, endPoint, server);
-        _request = new Ajp13Request(this);
-        _generator = new Ajp13Generator(_connector, _endp, _connector.getHeaderBufferSize(), _connector.getResponseBufferSize());
-        _parser = new Ajp13Parser(_connector, _endp, new RequestHandler(), (Ajp13Generator) _generator);
-        _generator.setSendServerVersion(server.getSendServerVersion());
-        _server = server;
-
+        super(connector, endPoint, server,
+                new Ajp13Parser(connector, endPoint),
+                new Ajp13Generator(connector, endPoint, connector.getHeaderBufferSize(), connector.getResponseBufferSize()),
+                new Ajp13Request()
+                );
+        
+        ((Ajp13Parser)_parser).setEventHandler(new RequestHandler());
+        ((Ajp13Parser)_parser).setGenerator((Ajp13Generator)_generator);
+        ((Ajp13Request)_request).setConnection(this);
     }
 
     public boolean isConfidential(Request request)
     {
-        return _sslSecure;
+        return ((Ajp13Request) request).isSslSecure();
     }
 
     public boolean isIntegral(Request request)
     {
-        return _sslSecure;
+        return ((Ajp13Request) request).isSslSecure();
     }
 
     public ServletInputStream getInputStream()
@@ -72,7 +79,7 @@
         {
             _delayedHandling = false;
             _uri.clear();
-            _sslSecure = false;
+            ((Ajp13Request) _request).setSslSecure(false);
             _request.setTimeStamp(System.currentTimeMillis());
             _request.setUri(_uri);
             
@@ -100,7 +107,28 @@
 
         public void parsedSslCert(Buffer sslCert) throws IOException
         {
-            _request.setAttribute("javax.servlet.request.X509Certificate", sslCert.toString());
+            try 
+            {
+                CertificateFactory cf = CertificateFactory.getInstance("X.509");
+                ByteArrayInputStream bis = new ByteArrayInputStream(sslCert.toString().getBytes());
+
+                Collection certCollection = cf.generateCertificates(bis);
+                X509Certificate[] certificates = new X509Certificate[certCollection.size()];
+
+                int i=0;
+                Iterator iter=certCollection.iterator();
+                while(iter.hasNext())
+                    certificates[i++] = (X509Certificate)iter.next();
+
+                _request.setAttribute("javax.servlet.request.X509Certificate", certificates);
+            } 
+            catch (Exception e) 
+            {
+                org.mortbay.log.Log.warn(e.toString());
+                org.mortbay.log.Log.ignore(e);
+                if (sslCert!=null)
+                    _request.setAttribute("javax.servlet.request.X509Certificate", sslCert.toString());
+            }
         }
 
         public void parsedSslCipher(Buffer sslCipher) throws IOException
@@ -112,9 +140,16 @@
         {
             _request.setAttribute("javax.servlet.request.ssl_session", sslSession.toString());
         }
+        
+        public void parsedSslKeySize(int keySize) throws IOException
+        {
+           _request.setAttribute("javax.servlet.request.key_size", new Integer(keySize));
+        }
 
         public void parsedMethod(Buffer method) throws IOException
         {
+            if (method == null)
+                throw new HttpException(HttpServletResponse.SC_BAD_REQUEST);
             _request.setMethod(method.toString());
         }
 
@@ -162,7 +197,7 @@
 
         public void parsedSslSecure(boolean secure) throws IOException
         {
-            _sslSecure = secure;
+            ((Ajp13Request) _request).setSslSecure(secure);
         }
 
         public void parsedQueryString(Buffer value) throws IOException

Property changes on: extras/ajp/src/main/config
___________________________________________________________________
Added: svn:mergeinfo

Index: extras/ajp/src/main/resources/jetty-ajp.xml
===================================================================
--- extras/ajp/src/main/resources/jetty-ajp.xml	(revision 5689)
+++ extras/ajp/src/main/resources/jetty-ajp.xml	(working copy)
@@ -1,18 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure//EN" "http://jetty.mortbay.org/configure.dtd">
-
-<Configure id="Server" class="org.mortbay.jetty.Server">
-
-  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
-  <!-- Add a AJP listener on port 8009                           -->
-  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
-  <Call name="addConnector">
-    <Arg>
-       <New class="org.mortbay.jetty.ajp.Ajp13SocketConnector">
-         <Set name="port">8009</Set>
-       </New>
-    </Arg>
-  </Call>
-
-</Configure>
-
Index: extras/ajp/pom.xml
===================================================================
--- extras/ajp/pom.xml	(revision 5689)
+++ extras/ajp/pom.xml	(working copy)
@@ -9,16 +9,8 @@
   <groupId>org.mortbay.jetty</groupId>
   <artifactId>jetty-ajp</artifactId>
   <name>Jetty AJP</name>
-  <url>http://jetty.mortbay.org</url>
-  <licenses>
-    <license>
-      <name>Apache License Version 2</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0</url>
-    </license>
-  </licenses>
   <build>
-    <defaultGoal>install</defaultGoal>
-    <plugins>
+     <plugins>
        <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
         <configuration>
@@ -38,7 +30,7 @@
             <configuration>
               <tasks>
                 <copy failonerror="false" file="target/${project.artifactId}-${project.version}.${project.packaging}" todir="../../lib/ext" />
-                <copy failonerror="false" file="src/main/resources/jetty-ajp.xml" todir="../../etc" />
+                <copy failonerror="false" file="src/main/config/etc/jetty-ajp.xml" todir="../../etc" />
               </tasks>
             </configuration>
           </execution>
@@ -64,8 +56,7 @@
       <groupId>org.mortbay.jetty</groupId>
       <artifactId>jetty</artifactId>
       <version>${project.version}</version>
-    </dependency>
-    
+    </dependency>    
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>

Property changes on: modules/jetty
___________________________________________________________________
Modified: svn:ignore
   - .project
.classpath
.settings
target

   + 
*.diff
*.iml
*.ipr
*.iws
*.log
*.patch
*.swp
*~
.classpath
.fbprefs
.pmd
.project
.settings
target


Index: modules/jetty/src/test/java/org/mortbay/jetty/HttpConnectionTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/HttpConnectionTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/HttpConnectionTest.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 /*
  * Created on 9/01/2004
  *
@@ -6,6 +20,17 @@
  */
 package org.mortbay.jetty;
 
+import java.io.IOException;
+import java.io.PrintWriter;
+
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpServletRequest;
+
+import org.mortbay.log.Log;
+
+
 import junit.framework.TestCase;
 
 /**
@@ -34,7 +59,9 @@
     protected void setUp() throws Exception
     {
         super.setUp();
-        
+        connector.setHeaderBufferSize(1024);
+        connector.setRequestBufferSize(2048);
+        connector.setResponseBufferSize(4096);
         server.start();
     }
 
@@ -97,6 +124,21 @@
     }
 
     /* --------------------------------------------------------------- */
+    public void testEmpty() throws Exception
+    {        
+        String response=connector.getResponses("GET /R1 HTTP/1.1\n"+
+                "Host: localhost\n"+
+                "Transfer-Encoding: chunked\n"+
+                "Content-Type: text/plain\n"+
+                "\015\012"+
+        "0\015\012\015\012");
+
+        int offset=0;
+        offset = checkContains(response,offset,"HTTP/1.1 200");
+        offset = checkContains(response,offset,"/R1");
+    }
+
+    /* --------------------------------------------------------------- */
     public void testAutoFlush() throws Exception
     {        
         
@@ -180,6 +222,78 @@
         }
     }
 
+    /* --------------------------------------------------------------- */
+    public void testPipeline()
+    {        
+        
+        String response=null;
+        String requests=null;
+        try
+        {
+            int offset=0;
+            
+            offset=0; connector.reopen();
+            requests="GET /R1 HTTP/1.1\n"+
+                "Host: localhost\n"+
+                "Content-Type: text/plain; charset=utf-8\n"+
+                "Content-Length: 10\n"+
+                "\n"+
+                "0123456789\n"+
+                "GET /R2 HTTP/1.1\n"+
+                "Host: localhost\n"+
+                "Content-Type: text/plain; charset=utf-8\n"+
+                "Content-Length: 10\n"+
+                "\n"+
+                "abcdefghij\n";
+            
+            response=connector.getResponses(requests);
+            offset = checkContains(response,offset,"HTTP/1.1 200");
+            offset = checkContains(response,offset,"/R1");
+            offset = checkContains(response,offset,"encoding=utf-8");
+            offset = checkContains(response,offset,"0123456789");
+            offset = checkContains(response,offset,"HTTP/1.1 200");
+            offset = checkContains(response,offset,"/R2");
+            offset = checkContains(response,offset,"encoding=utf-8");
+            offset = checkContains(response,offset,"abcdefghij");
+
+
+            offset=0; connector.reopen();
+            requests="GET /R1 HTTP/1.1\n"+
+                "Host: localhost\n"+
+                "Content-Type: text/plain; charset=utf-8\n"+
+                "Content-Length: 1026\n"+
+                "\n";
+            
+            for (int i=0;i<100;i++)
+                requests+="0123456789";
+            requests+="abcdefghijklmnopqrstuvwxyz";
+            requests+=
+                "GET /R2 HTTP/1.1\n"+
+                "Host: localhost\n"+
+                "Content-Type: text/plain; charset=utf-8\n"+
+                "Content-Length: 10\n"+
+                "\n"+
+                "0987654321\n";
+            
+            response=connector.getResponses(requests);
+            offset = checkContains(response,offset,"HTTP/1.1 200");
+            offset = checkContains(response,offset,"/R1");
+            offset = checkContains(response,offset,"encoding=utf-8");
+            offset = checkContains(response,offset,"abcdefghijklmnopqrstuvwxyz");
+            offset = checkContains(response,offset,"HTTP/1.1 200");
+            offset = checkContains(response,offset,"/R2");
+            offset = checkContains(response,offset,"encoding=utf-8");
+            offset = checkContains(response,offset,"0987654321");
+            
+        }
+        catch(Exception e)
+        {
+            e.printStackTrace();
+            assertTrue(false);
+            if (response!=null)
+                System.err.println(response);
+        }
+    }
     
     public void testConnection ()
     { 
@@ -206,12 +320,147 @@
             e.printStackTrace();
             assertTrue(false);
             if (response!=null)
+                 System.err.println(response);
+        }
+    }
+    
+    public void testOversizedBuffer() 
+    {
+        String response = null;
+        connector.reopen();
+        try 
+        {
+            int offset = 0;
+            String cookie = "thisisastringthatshouldreachover1kbytes";
+            for (int i=0;i<100;i++)
+                cookie+="xxxxxxxxxxxx";
+            response = connector.getResponses("GET / HTTP/1.1\n"+
+                "Host: localhost\n" +
+                "Cookie: "+cookie+"\n"+
+                "\015\012"
+             );
+            offset = checkContains(response, offset, "HTTP/1.1 413");
+        } 
+        catch(Exception e)
+        {
+            e.printStackTrace();
+            assertTrue(false);
+            if(response != null)
                 System.err.println(response);
+                
         }
     }
     
     
+    public void testOversizedResponse ()
+    throws Exception
+    {  
+        String str = "thisisastringthatshouldreachover1kbytes";
+        for (int i=0;i<400;i++)
+            str+="xxxxxxxxxxxx";
+        final String longstr = str;
+        String response = null;
+        server.stop();
+        server.setHandler(new DumpHandler()
+        {
+            public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch) throws IOException, ServletException
+            {
+                try
+                {
+                    Request base_request = (request instanceof Request) ? (Request)request:HttpConnection.getCurrentConnection().getRequest();
+                    base_request.setHandled(true);
+                    response.setHeader(HttpHeaders.CONTENT_TYPE,MimeTypes.TEXT_HTML);
+                    response.setHeader("LongStr", longstr);
+                    PrintWriter writer = response.getWriter();
+                    writer.write("<html><h1>FOO</h1></html>");  
+                    writer.flush();
+                    writer.close();
+                    throw new RuntimeException("SHOULD NOT GET HERE");
+                }
+                catch(ArrayIndexOutOfBoundsException e)
+                {
+                    Log.debug(e);
+                    Log.info("correctly ignored "+e);
+                }
+            }
+        });
+        server.start();
+        
+        connector.reopen();
+        try 
+        {
+            int offset = 0;
+          
+            response = connector.getResponses("GET / HTTP/1.1\n"+
+                "Host: localhost\n" +
+                "\015\012"
+             );
+          
+            offset = checkContains(response, offset, "HTTP/1.1 500");
+        } 
+        catch(Exception e)
+        {
+            e.printStackTrace();
+            if(response != null)
+                System.err.println(response);
+            fail("Exception");      
+        }
+    }
     
+    public void testAsterisk()
+    {
+        String response = null;
+
+        try 
+        {
+            int offset=0;
+            
+            offset=0; connector.reopen();
+            response=connector.getResponses("OPTIONS * HTTP/1.1\n"+
+                                           "Host: localhost\n"+
+                                           "Transfer-Encoding: chunked\n"+
+                                           "Content-Type: text/plain; charset=utf-8\n"+
+                                           "\015\012"+
+                                           "5;\015\012"+
+                                           "12345\015\012"+
+                                           "0;\015\012\015\012");
+            offset = checkContains(response,offset,"HTTP/1.1 200");
+            offset = checkContains(response,offset,"*");
+            
+            // to prevent the DumpHandler from picking this up and returning 200 OK
+            server.setHandler(null);
+            offset=0; connector.reopen();
+            response=connector.getResponses("GET * HTTP/1.1\n"+
+                                           "Host: localhost\n"+
+                                           "Transfer-Encoding: chunked\n"+
+                                           "Content-Type: text/plain; charset=utf-8\n"+
+                                           "\015\012"+
+                                           "5;\015\012"+
+                                           "12345\015\012"+
+                                           "0;\015\012\015\012");
+            offset = checkContains(response,offset,"HTTP/1.1 404 Not Found");
+
+            offset=0; connector.reopen();
+            response=connector.getResponses("GET ** HTTP/1.1\n"+
+                                           "Host: localhost\n"+
+                                           "Transfer-Encoding: chunked\n"+
+                                           "Content-Type: text/plain; charset=utf-8\n"+
+                                           "\015\012"+
+                                           "5;\015\012"+
+                                           "12345\015\012"+
+                                           "0;\015\012\015\012");
+            offset = checkContains(response,offset,"HTTP/1.1 400 Bad Request");
+        } 
+        catch (Exception e)
+        {
+            e.printStackTrace();
+            assertTrue(false);
+            if (response!=null)
+                 System.err.println(response);
+        }
+
+    }
+    
     private int checkContains(String s,int offset,String c)
     {
         int o=s.indexOf(c,offset);
Index: modules/jetty/src/test/java/org/mortbay/jetty/HttpURITest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/HttpURITest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/HttpURITest.java	(working copy)
@@ -112,6 +112,13 @@
        /*32*/ {"/?x=y",null, null, null,null,"/", null,"x=y",null},
        /*33*/ {"/?abc=test",null, null, null,null,"/", null,"abc=test",null},
        /*34*/ {"/#fragment",null, null, null,null,"/", null,null,"fragment"},
+       /*35*/ {"http://192.0.0.1:8080/","http","//192.0.0.1:8080","192.0.0.1","8080","/",null,null,null},
+       /*36*/ {"http://[2001:db8::1]:8080/","http","//[2001:db8::1]:8080","[2001:db8::1]","8080","/",null,null,null},
+       /*37*/ {"http://user@[2001:db8::1]:8080/","http","//user@[2001:db8::1]:8080","[2001:db8::1]","8080","/",null,null,null},
+       /*38*/ {"http://[2001:db8::1]/","http","//[2001:db8::1]","[2001:db8::1]",null,"/",null,null,null},
+       /*39*/ {"//[2001:db8::1]:8080/",null,null,null,null,"//[2001:db8::1]:8080/",null,null,null},
+       /*40*/ {"http://user@[2001:db8::1]:8080/","http","//user@[2001:db8::1]:8080","[2001:db8::1]","8080","/",null,null,null},
+       /*41*/ {"*",null,null,null,null,"*",null, null,null}
     };
     
     
@@ -135,5 +142,26 @@
         }
         
     }
+    
+    public void testInvalidAddress() throws Exception
+    {
+        assertInvalidURI("http://[ffff::1:8080/", "Invalid URL; no closing ']' -- should throw exception");
+        assertInvalidURI("**", "only '*', not '**'");
+        assertInvalidURI("*/", "only '*', not '*/'");
+    }
+    
+    public void assertInvalidURI(String invalidURI, String message)
+    {
+        HttpURI uri = new HttpURI();
+        try
+        {
+            uri.parse(invalidURI);
+            fail(message);
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertTrue(true);
+        }
+    }
 
 }
Index: modules/jetty/src/test/java/org/mortbay/jetty/SelectChannelServerTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/SelectChannelServerTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/SelectChannelServerTest.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 import org.mortbay.jetty.nio.SelectChannelConnector;
 
Index: modules/jetty/src/test/java/org/mortbay/jetty/HttpServerTestBase.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/HttpServerTestBase.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/HttpServerTestBase.java	(working copy)
@@ -1,6 +1,21 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 
 import java.io.BufferedReader;
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -10,7 +25,6 @@
 import java.io.Writer;
 import java.net.Socket;
 import java.net.URL;
-import java.net.URLConnection;
 import java.util.Arrays;
 import java.util.Random;
 
@@ -20,7 +34,6 @@
 
 import junit.framework.TestCase;
 
-import org.mortbay.jetty.bio.SocketConnector;
 import org.mortbay.jetty.handler.AbstractHandler;
 import org.mortbay.thread.BoundedThreadPool;
 import org.mortbay.util.IO;
@@ -30,7 +43,8 @@
  */
 public class HttpServerTestBase extends TestCase
 {
-
+    private static boolean stress=Boolean.getBoolean("STRESS");
+    
     // ~ Static fields/initializers
     // ---------------------------------------------
 
@@ -59,16 +73,27 @@
 
     private static final String REQUEST2=REQUEST2_HEADER+REQUEST2_CONTENT.getBytes().length+"\n\n"+REQUEST2_CONTENT;
 
-    private static final String RESPONSE2_CONTENT="<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n"
-            +"<nimbus xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"+"        xsi:noNamespaceSchemaLocation=\"nimbus.xsd\" version=\"1.0\">\n"
-            +"    <request requestId=\"1\">\n"+"        <getJobDetails>\n"+"            <jobId>73</jobId>\n"+"        </getJobDetails>\n"+"    </request>\n"
+    private static final String RESPONSE2_CONTENT=
+            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n"+
+            "<nimbus xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"+
+            "        xsi:noNamespaceSchemaLocation=\"nimbus.xsd\" version=\"1.0\">\n"+
+            "    <request requestId=\"1\">\n"+
+            "        <getJobDetails>\n"+
+            "            <jobId>73</jobId>\n"+
+            "        </getJobDetails>\n"+
+            "    </request>\n"
             +"</nimbus>\n";
-    private static final String RESPONSE2="HTTP/1.1 200 OK\n"+"Content-Length: "+RESPONSE2_CONTENT.getBytes().length+"\n"+"Server: Jetty(6.1.x)\n"+"\n"
-            +RESPONSE2_CONTENT;
+    private static final String RESPONSE2=
+        "HTTP/1.1 200 OK\n"+
+        "Content-Type: text/xml; charset=iso-8859-1\n"+
+        "Content-Length: "+RESPONSE2_CONTENT.getBytes().length+"\n"+
+        "Server: Jetty(6.1.x)\n"+
+        "\n"+
+        RESPONSE2_CONTENT;
 
     // Useful constants
     private static final long PAUSE=15L;
-    private static final int LOOPS=250;
+    private static final int LOOPS=stress?250:25;
     private static final String HOST="localhost";
 
     private Connector _connector;
@@ -358,7 +383,6 @@
         {   
             String[] encoding = {"NONE","UTF-8","ISO-8859-1","ISO-8859-2"};
 
-
             for (int e =0; e<encoding.length;e++)
             {
                 for (int b=1;b<=128;b=b==1?2:b==2?32:b==32?128:129)
@@ -372,14 +396,11 @@
                             InputStream in = (InputStream)url.getContent();
                             String response=IO.toString(in,e==0?null:encoding[e]);
                             
-                            // System.err.println(test+": "+(b*w)+" "+response.length()+" "+(response.length()-(b*w))/w);
                             assertEquals(test,b*w,response.length());
                         }
                     }
                 }
             }
-
-
         }
         finally
         {
@@ -387,7 +408,6 @@
             server.stop();
             Thread.yield();
         }
-
     }
 
     /**
@@ -454,8 +474,8 @@
         }
 
     }
-    
 
+
     /**
      * After several iterations, I generated some known bad fragment points.
      * 
@@ -527,6 +547,141 @@
         server.stop();
     }
     
+
+    /**
+     */
+    public void testRecycledWriters() throws Exception
+    {
+        Server server=startServer(new EchoHandler());
+        
+        try
+        {   
+            long start=System.currentTimeMillis();
+            Socket client=new Socket(HOST,port);
+            OutputStream os=client.getOutputStream();
+            InputStream is=client.getInputStream();
+
+            os.write((
+                    "POST /echo?charset=utf-8 HTTP/1.1\r\n"+
+                    "host: "+HOST+":"+port+"\r\n"+
+                    "content-type: text/plain; charset=utf-8\r\n"+
+                    "content-length: 10\r\n"+
+                    "\r\n").getBytes("iso-8859-1"));
+            
+            os.write((
+                    "123456789\n"
+            ).getBytes("utf-8"));
+
+            os.write((
+                    "POST /echo?charset=utf-8 HTTP/1.1\r\n"+
+                    "host: "+HOST+":"+port+"\r\n"+
+                    "content-type: text/plain; charset=utf-8\r\n"+
+                    "content-length: 10\r\n"+
+                    "\r\n"
+            ).getBytes("iso-8859-1"));
+
+            os.write((
+                    "abcdefghi\n"
+            ).getBytes("utf-8"));
+
+            String content="Wibble";
+            byte[] contentB=content.getBytes("utf-8");
+            os.write((
+                    "POST /echo?charset=utf-16 HTTP/1.1\r\n"+
+                    "host: "+HOST+":"+port+"\r\n"+
+                    "content-type: text/plain; charset=utf-8\r\n"+
+                    "content-length: "+contentB.length+"\r\n"+
+                    "connection: close\r\n"+
+                    "\r\n"
+            ).getBytes("iso-8859-1"));
+            os.write(contentB);
+
+            os.flush();
+            
+            ByteArrayOutputStream bout = new ByteArrayOutputStream();
+            IO.copy(is,bout);
+            byte[] b=bout.toByteArray();
+            String in = new String(b,0,b.length,"utf-8");
+            assertTrue(in.indexOf("123456789")>=0);
+            assertTrue(in.indexOf("abcdefghi")>=0);
+            assertTrue(in.indexOf("Wibble")<0);
+            in = new String(b,0,b.length,"utf-16");
+            assertTrue(in.indexOf("123456789")<0);
+            assertTrue(in.indexOf("abcdefghi")<0);
+            assertTrue(in.indexOf("Wibble")>=0);
+            
+        }
+        finally
+        {
+            // Shut down
+            server.stop();
+            Thread.yield();
+        }
+    }
+
+    /**
+     */
+    public void testRecycledReaders() throws Exception
+    {
+        Server server=startServer(new EchoHandler());
+        
+        try
+        {   
+            long start=System.currentTimeMillis();
+            Socket client=new Socket(HOST,port);
+            OutputStream os=client.getOutputStream();
+            InputStream is=client.getInputStream();
+
+            os.write((
+                    "POST /echo?charset=utf-8 HTTP/1.1\r\n"+
+                    "host: "+HOST+":"+port+"\r\n"+
+                    "content-type: text/plain; charset=utf-8\r\n"+
+                    "content-length: 10\r\n"+
+                    "\r\n").getBytes("iso-8859-1"));
+            
+            os.write((
+                    "123456789\n"
+            ).getBytes("utf-8"));
+
+            os.write((
+                    "POST /echo?charset=utf-8 HTTP/1.1\r\n"+
+                    "host: "+HOST+":"+port+"\r\n"+
+                    "content-type: text/plain; charset=utf-8\r\n"+
+                    "content-length: 10\r\n"+
+                    "\r\n"
+            ).getBytes("iso-8859-1"));
+
+            os.write((
+                    "abcdefghi\n"
+            ).getBytes("utf-8"));
+
+            String content="Wibble";
+            byte[] contentB=content.getBytes("utf-16");
+            os.write((
+                    "POST /echo?charset=utf-8 HTTP/1.1\r\n"+
+                    "host: "+HOST+":"+port+"\r\n"+
+                    "content-type: text/plain; charset=utf-16\r\n"+
+                    "content-length: "+contentB.length+"\r\n"+
+                    "connection: close\r\n"+
+                    "\r\n"
+            ).getBytes("iso-8859-1"));
+            os.write(contentB);
+
+            os.flush();
+            
+            String in = IO.toString(is);
+            assertTrue(in.indexOf("123456789")>=0);
+            assertTrue(in.indexOf("abcdefghi")>=0);
+            assertTrue(in.indexOf("Wibble")>=0);
+            
+        }
+        finally
+        {
+            // Shut down
+            server.stop();
+            Thread.yield();
+        }
+    }
     
     /**
      * Read entire response from the client. Close the output.
@@ -621,29 +776,41 @@
     // ----------------------------------------------------------
     private static class EchoHandler extends AbstractHandler
     {
-
         // ~ Methods
         // ------------------------------------------------------------
         public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch) throws IOException, ServletException
         {
-
             Request base_request=(request instanceof Request)?(Request)request:HttpConnection.getCurrentConnection().getRequest();
             base_request.setHandled(true);
 
+            if (request.getContentType()!=null)
+                response.setContentType(request.getContentType());
+            if (request.getParameter("charset")!=null)
+                response.setCharacterEncoding(request.getParameter("charset"));
+            else if (request.getCharacterEncoding()!=null)
+                response.setCharacterEncoding(request.getCharacterEncoding());
+            
             PrintWriter writer=response.getWriter();
             BufferedReader reader=request.getReader();
             int count=0;
             String line;
-
+            
             while ((line=reader.readLine())!=null)
             {
                 writer.print(line);
-                writer.print('\n');
+                writer.print("\n");
                 count+=line.length();
             }
 
             if (count==0)
                 throw new IllegalStateException("no input recieved");
+            
+            // just to be difficult
+            reader.close();
+            writer.close();
+            
+            if (reader.read()>=0)
+                throw new IllegalStateException("Not closed");
         }
     }
 
Index: modules/jetty/src/test/java/org/mortbay/jetty/BusySelectChannelServerTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/BusySelectChannelServerTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/BusySelectChannelServerTest.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 import java.io.IOException;
 import java.nio.channels.SelectionKey;
@@ -4,8 +18,8 @@
 import java.nio.channels.SocketChannel;
 
 import org.mortbay.io.Buffer;
-import org.mortbay.io.ByteArrayBuffer;
 import org.mortbay.io.View;
+import org.mortbay.io.nio.IndirectNIOBuffer;
 import org.mortbay.io.nio.NIOBuffer;
 import org.mortbay.io.nio.SelectChannelEndPoint;
 import org.mortbay.io.nio.SelectorManager.SelectSet;
@@ -30,9 +44,9 @@
                 {
                     int write;
                     int read;
-                    NIOBuffer one = new NIOBuffer(1,false);
-                    NIOBuffer two = new NIOBuffer(2,false);
-                    NIOBuffer three = new NIOBuffer(3,false);
+                    NIOBuffer one = new IndirectNIOBuffer(1);
+                    NIOBuffer two = new IndirectNIOBuffer(2);
+                    NIOBuffer three = new IndirectNIOBuffer(3);
                     
                     /* ------------------------------------------------------------ */
                     /* (non-Javadoc)
Index: modules/jetty/src/test/java/org/mortbay/jetty/ServerTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/ServerTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/ServerTest.java	(working copy)
@@ -14,25 +14,11 @@
 
 package org.mortbay.jetty;
 
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.net.URL;
 import java.util.Random;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import junit.framework.TestCase;
 
-import org.mortbay.jetty.handler.ContextHandler;
 import org.mortbay.jetty.handler.DefaultHandler;
-import org.mortbay.jetty.nio.SelectChannelConnector;
-import org.mortbay.jetty.servlet.ServletHandler;
-import org.mortbay.jetty.servlet.ServletHolder;
-import org.mortbay.jetty.servlet.ServletMapping;
-import org.mortbay.util.IO;
 
 /**
  * @version $Revision$
Index: modules/jetty/src/test/java/org/mortbay/jetty/BlockingChannelServerTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/BlockingChannelServerTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/BlockingChannelServerTest.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 import org.mortbay.jetty.nio.BlockingChannelConnector;
 
Index: modules/jetty/src/test/java/org/mortbay/jetty/ResourceCacheTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/ResourceCacheTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/ResourceCacheTest.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 
 import java.io.File;
Index: modules/jetty/src/test/java/org/mortbay/jetty/SocketServerTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/SocketServerTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/SocketServerTest.java	(working copy)
@@ -1,6 +1,19 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 import org.mortbay.jetty.bio.SocketConnector;
-import org.mortbay.thread.BoundedThreadPool;
 
 /**
  * HttpServer Tester.
Index: modules/jetty/src/test/java/org/mortbay/jetty/HttpGeneratorClientTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/HttpGeneratorClientTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/HttpGeneratorClientTest.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 
 import java.io.IOException;
@@ -7,6 +21,7 @@
 import org.mortbay.io.ByteArrayEndPoint;
 import org.mortbay.io.SimpleBuffers;
 import org.mortbay.io.View;
+import org.mortbay.util.StringUtil;
 
 import junit.framework.TestCase;
 
@@ -24,6 +39,98 @@
     {
         junit.textui.TestRunner.run(HttpGeneratorTest.class);
     }
+
+    public void testContentLength()
+        throws Exception
+    {
+        Buffer bb=new ByteArrayBuffer(8096);
+        Buffer sb=new ByteArrayBuffer(1500);
+        ByteArrayEndPoint endp = new ByteArrayEndPoint(new byte[0],4096);
+        HttpGenerator generator = new HttpGenerator(new SimpleBuffers(new Buffer[]{sb,bb}),endp, sb.capacity(), bb.capacity());
+        
+        generator.setRequest("GET","/usr");
+        
+        HttpFields fields = new HttpFields();
+        fields.add("Header","Value");
+        fields.add("Content-Type","text/plain");
+        
+        String content = "The quick brown fox jumped over the lazy dog";
+        fields.addLongField("Content-Length",content.length());
+        
+        generator.completeHeader(fields,false);
+        
+        generator.addContent(new ByteArrayBuffer(content),true);
+        generator.flush();
+        generator.complete();
+        generator.flush();
+        
+        String result=endp.getOut().toString();
+        result=StringUtil.replace(result,"\r\n","|");
+        result=StringUtil.replace(result,"\r","|");
+        result=StringUtil.replace(result,"\n","|");
+        
+        assertEquals("GET /usr HTTP/1.1|Header: Value|Content-Type: text/plain|Content-Length: 44||"+content,result);
+    }
+
+    public void testAutoContentLength()
+        throws Exception
+    {
+        Buffer bb=new ByteArrayBuffer(8096);
+        Buffer sb=new ByteArrayBuffer(1500);
+        ByteArrayEndPoint endp = new ByteArrayEndPoint(new byte[0],4096);
+        HttpGenerator generator = new HttpGenerator(new SimpleBuffers(new Buffer[]{sb,bb}),endp, sb.capacity(), bb.capacity());
+        
+        generator.setRequest("GET","/usr");
+        
+        HttpFields fields = new HttpFields();
+        fields.add("Header","Value");
+        fields.add("Content-Type","text/plain");
+        
+        String content = "The quick brown fox jumped over the lazy dog";
+
+        generator.addContent(new ByteArrayBuffer(content),true);
+        generator.completeHeader(fields,true);
+        
+        generator.flush();
+        generator.complete();
+        generator.flush();
+        
+        String result=endp.getOut().toString();
+        result=StringUtil.replace(result,"\r\n","|");
+        result=StringUtil.replace(result,"\r","|");
+        result=StringUtil.replace(result,"\n","|");
+        assertEquals("GET /usr HTTP/1.1|Header: Value|Content-Type: text/plain|Content-Length: 44||"+content,result);
+    }
+
+    public void testChunked()
+        throws Exception
+    {
+        Buffer bb=new ByteArrayBuffer(8096);
+        Buffer sb=new ByteArrayBuffer(1500);
+        ByteArrayEndPoint endp = new ByteArrayEndPoint(new byte[0],4096);
+        HttpGenerator generator = new HttpGenerator(new SimpleBuffers(new Buffer[]{sb,bb}),endp, sb.capacity(), bb.capacity());
+        
+        generator.setRequest("GET","/usr");
+        
+        HttpFields fields = new HttpFields();
+        fields.add("Header","Value");
+        fields.add("Content-Type","text/plain");
+        
+        String content = "The quick brown fox jumped over the lazy dog";
+
+        generator.completeHeader(fields,false);
+        
+        generator.addContent(new ByteArrayBuffer(content),false);
+        generator.flush();
+        generator.complete();
+        generator.flush();
+
+        String result=endp.getOut().toString();
+        result=StringUtil.replace(result,"\r\n","|");
+        result=StringUtil.replace(result,"\r","|");
+        result=StringUtil.replace(result,"\n","|");
+        assertEquals("GET /usr HTTP/1.1|Header: Value|Content-Type: text/plain|Transfer-Encoding: chunked||2C|"+content+"|0||",result);
+    }
     
     public void testHTTP()
         throws Exception
@@ -48,7 +155,7 @@
                     // For none, keep-alive, close
                     for (int c=0;c<connect.length;c++)
                     {
-                        String t="v="+v+",r="+r+",chunks="+chunks+",connect="+connect[c]+",tr="+tr[r];
+                        String t="v="+v+",r="+r+",chunks="+chunks+",c="+c+",tr="+tr[r];
                         // System.err.println(t);
                         
                         hb.reset(true);
@@ -63,8 +170,9 @@
                         }
                         catch(IllegalStateException e)
                         {
-                            if (v==10 && chunks>2)
+                            if (v<10 || v==10 && chunks>2)
                                 continue;
+                            System.err.println(t);
                             throw e;
                         }
                         String request=endp.getOut().toString();
@@ -151,7 +259,11 @@
                     if (i%2==0)
                     {
                         if (hb.isState(HttpGenerator.STATE_HEADER))
+                        {
+                            if (version<11)
+                                fields.addLongField("Content-Length",body.length());
                             hb.completeHeader(fields, HttpGenerator.MORE);
+                        }
                         hb.flush();
                     }
                 }
Index: modules/jetty/src/test/java/org/mortbay/jetty/HttpGeneratorTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/HttpGeneratorTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/HttpGeneratorTest.java	(working copy)
@@ -25,6 +25,9 @@
 import org.mortbay.io.ByteArrayEndPoint;
 import org.mortbay.io.SimpleBuffers;
 import org.mortbay.io.View;
+import org.mortbay.jetty.AbstractGenerator.Output;
+import org.mortbay.jetty.AbstractGenerator.OutputWriter;
+import org.mortbay.util.StringUtil;
 
 /**
  * @author gregw
@@ -78,7 +81,7 @@
                         endp.reset();
                         fields.clear();
                         
-                        tr[r].build(v,hb,null,connect[c],null,chunks, fields);
+                        tr[r].build(v,hb,"OK\r\nTest",connect[c],null,chunks, fields);
                         String response=endp.getOut().toString();
                         // System.out.println("RESPONSE: "+t+"\n"+response+(hb.isPersistent()?"...\n":"---\n"));
                         
@@ -109,6 +112,9 @@
                         else
                             assertTrue(t,hb.isPersistent() ||  c==2 || c==3);
                         
+                        if (v>9)
+                            assertEquals("OK  Test",f2);
+                        
                         assertTrue(t,tr[r].values[1]==null || content.length()==Integer.parseInt(tr[r].values[1]));
                     }
                 }
@@ -199,7 +205,6 @@
       /* 7 */  new TR(200,"text/html",""+CONTENT.length(),CONTENT),
     };
     
-
     String content;
     String f0;
     String f1;
@@ -268,8 +273,33 @@
         public void messageComplete(long contentLength)
         {
         }
+    }
 
+    public void testOutput()
+        throws Exception
+    {
+        Buffer sb=new ByteArrayBuffer(1500);
+        Buffer bb=new ByteArrayBuffer(8096);
+        HttpFields fields = new HttpFields();
+        ByteArrayEndPoint endp = new ByteArrayEndPoint(new byte[0],4096);
+        HttpGenerator hb = new HttpGenerator(new SimpleBuffers(new Buffer[]{sb,bb}),endp, sb.capacity(), bb.capacity());
 
-    }
-
+        hb.setResponse(200,"OK");
+        
+        Output output = new Output(hb,10000);
+        OutputWriter writer = new OutputWriter(output);
+        writer.setCharacterEncoding(StringUtil.__UTF8);
+        
+        char[] chars = new char[1024];
+        for (int i=0;i<chars.length;i++)
+            chars[i]=(char)('0'+(i%10));
+        chars[0]='\u0553';
+        writer.write(chars);
+        
+        hb.completeHeader(fields,true);
+        hb.flush();
+        String response = new String(endp.getOut().asArray(),StringUtil.__UTF8);
+        assertTrue(response.startsWith("HTTP/1.1 200 OK\r\nContent-Length: 1025\r\n\r\n\u05531234567890"));
+                
+    }    
 }
Index: modules/jetty/src/test/java/org/mortbay/jetty/security/ConstraintTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/security/ConstraintTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/security/ConstraintTest.java	(working copy)
@@ -124,14 +124,14 @@
         _connector.reopen();
         response=_connector.getResponses("GET /ctx/auth/info HTTP/1.0\r\n\r\n");
         assertTrue(response.startsWith("HTTP/1.1 401 Unauthorized"));
-        assertTrue(response.indexOf("WWW-Authenticate: basic realm=\"TestRealm\"")>0);
+        assertTrue(response.indexOf("WWW-Authenticate: Basic realm=\"TestRealm\"")>0);
 
         _connector.reopen();
         response=_connector.getResponses("GET /ctx/auth/info HTTP/1.0\r\n"+
             "Authorization: "+B64Code.encode("user:wrong")+"\r\n"+
             "\r\n");
         assertTrue(response.startsWith("HTTP/1.1 401 Unauthorized"));
-        assertTrue(response.indexOf("WWW-Authenticate: basic realm=\"TestRealm\"")>0);
+        assertTrue(response.indexOf("WWW-Authenticate: Basic realm=\"TestRealm\"")>0);
         
         _connector.reopen();
         response=_connector.getResponses("GET /ctx/auth/info HTTP/1.0\r\n"+
Index: modules/jetty/src/test/java/org/mortbay/jetty/RequestTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/RequestTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/RequestTest.java	(working copy)
@@ -17,28 +17,22 @@
 
 
 import java.io.IOException;
+import java.io.Reader;
 import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.Map;
 
-import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import javax.servlet.http.HttpSessionContext;
 
+import junit.framework.TestCase;
+
+import org.mortbay.jetty.Request;
 import org.mortbay.jetty.handler.AbstractHandler;
-import org.mortbay.jetty.handler.ContextHandler;
-import org.mortbay.jetty.servlet.AbstractSessionManager;
-import org.mortbay.jetty.servlet.HashSessionIdManager;
-import org.mortbay.jetty.servlet.HashSessionManager;
+import org.mortbay.jetty.handler.HandlerCollection;
 import org.mortbay.util.IO;
+import org.mortbay.util.StringUtil;
 
-import java.util.Locale;
-
-import junit.framework.TestCase;
-
 /**
  * @author gregw
  *
@@ -147,12 +141,14 @@
     public void testContent()
         throws Exception
     {
+      
         final int[] length=new int[1];
         
         _handler._checker = new RequestTester()
         {
             public boolean check(HttpServletRequest request,HttpServletResponse response)
             {
+                assertEquals(request.getContentLength(), ((Request)request).getContentRead());
                 length[0]=request.getContentLength();
                 return true;
             }  
@@ -168,17 +164,61 @@
             "Content-Length: "+l+"\r\n"+
             "Connection: close\r\n"+
             "\r\n"+
-            content;
-            content+="x";
-            
+            content;           
             _connector.reopen();
             String response = _connector.getResponses(request);
             assertEquals(l,length[0]);
             if (l>0)
                 assertEquals(l,_handler._content.length());
+            content+="x";
         }
     }
-    
+
+
+    public void testPartialRead()
+        throws Exception
+    {
+        Handler handler = new AbstractHandler()
+        {
+            public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch) throws IOException, ServletException
+            {
+                Request baseRequest = (Request)request;
+                baseRequest.setHandled(true);
+                Reader reader=request.getReader();
+                byte[] b=("read="+reader.read()+"\n").getBytes(StringUtil.__UTF8);
+                response.setContentLength(b.length);
+                response.getOutputStream().write(b);
+                response.flushBuffer();
+            }
+            
+        };
+        _server.stop();
+        _server.setHandler(handler);
+        _server.start();
+
+        String request="GET / HTTP/1.1\r\n"+
+        "Host: whatever\r\n"+
+        "Content-Type: text/plane\r\n"+
+        "Content-Length: "+10+"\r\n"+
+        "\r\n"+
+        "0123456789\r\n"+
+        "GET / HTTP/1.1\r\n"+
+        "Host: whatever\r\n"+
+        "Content-Type: text/plane\r\n"+
+        "Content-Length: "+10+"\r\n"+
+        "Connection: close\r\n"+
+        "\r\n"+
+        "ABCDEFGHIJ\r\n";
+
+        String responses = _connector.getResponses(request);
+        
+        int index=responses.indexOf("read="+(int)'0');
+        assertTrue(index>0);
+        
+        index=responses.indexOf("read="+(int)'A',index+7);
+        assertTrue(index>0);
+        
+    }
     public void testConnectionClose()
         throws Exception
     {
@@ -294,31 +334,29 @@
         assertTrue(response.indexOf("200")>0);
         assertTrue(response.indexOf("Connection: close")>0);
         assertTrue(response.indexOf("Hello World")>0);
-
-        
-        
-        
     }
     
-    
-
-    
     public void testCookie()
         throws Exception
     {
-      
-        final String[] cookie=new String[10];
+
+        final String[] name=new String[20];
+        final String[] cookie=new String[20];
         
         _handler._checker = new RequestTester()
         {
             public boolean check(HttpServletRequest request,HttpServletResponse response)
             {
                 for (int i=0;i<cookie.length; i++)
+                {
+                    name[i]=null;
                     cookie[i]=null;
+                }
                 
                 Cookie[] cookies = request.getCookies();
                 for (int i=0;cookies!=null && i<cookies.length; i++)
                 {
+                    name[i]=cookies[i].getName();
                     cookie[i]=cookies[i].getValue();
                 }
                 return true;
@@ -328,16 +366,17 @@
         
         String request="POST / HTTP/1.1\r\n"+
         "Host: whatever\r\n"+
-        "Cookie: name=value\r\n"+
+        "Cookie: name=\"quoted=\\\"value\\\"\"\n" +
         "Connection: close\r\n"+
         "\r\n";
 
         _connector.reopen();
         _connector.getResponses(request);
 
-        assertEquals("value",cookie[0]);
+        assertEquals("quoted=\"value\"",cookie[0]);
         assertEquals(null,cookie[1]);
         
+        
         request="POST / HTTP/1.1\r\n"+
         "Host: whatever\r\n"+
         "Cookie: name=value\r\n"+
@@ -372,7 +411,34 @@
         assertEquals("value",cookie[0]);
         assertEquals(null,cookie[1]);
         
-        
+
+        request="POST / HTTP/1.1\r\n"+
+        "Host: whatever\r\n"+
+        "Cookie: name0=value0; name1 = value1 , \"\\\"name2\\\"\"  =  \"\\\"value2\\\"\"  \n" +
+        "Cookie: $Version=2; name3=value3=value3;$path=/path;$domain=acme.com;$port=8080, name4=; name5 =  ; name6\n" +
+        "Cookie: name7=value7;\n" +
+        "Connection: close\r\n"+
+        "\r\n";
+
+        _connector.reopen();
+        _connector.getResponses(request);
+
+        assertEquals("name0" ,name[0]);
+        assertEquals("value0" ,cookie[0]);
+        assertEquals("name1" ,name[1]);
+        assertEquals("value1" ,cookie[1]);
+        assertEquals("\"name2\"" ,name[2]);
+        assertEquals("\"value2\"" ,cookie[2]);
+        assertEquals("name3" ,name[3]);
+        assertEquals("value3=value3" ,cookie[3]);
+        assertEquals("name4" ,name[4]);
+        assertEquals("" ,cookie[4]);
+        assertEquals("name5" ,name[5]);
+        assertEquals("" ,cookie[5]);
+        assertEquals("name6" ,name[6]);
+        assertEquals("" ,cookie[6]);
+        assertEquals("name7" ,name[7]);
+        assertEquals("value7" ,cookie[7]);
     }
     
     
Index: modules/jetty/src/test/java/org/mortbay/jetty/HttpHeaderTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/HttpHeaderTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/HttpHeaderTest.java	(working copy)
@@ -92,6 +92,22 @@
         assertEquals(false, e.hasMoreElements());
     }
     
+    public void testCRLF()
+    throws Exception
+    {
+        HttpFields header = new HttpFields();
+
+        header.put("name0", "value\r\n0");
+        header.put("name\r\n1", "value1");
+        header.put("name:2", "value:\r\n2");
+        
+        ByteArrayBuffer buffer = new ByteArrayBuffer(1024);
+        header.put(buffer);
+        assertTrue(buffer.toString().indexOf("name0: value0")>=0);
+        assertTrue(buffer.toString().indexOf("name1: value1")>=0);
+        assertTrue(buffer.toString().indexOf("name2: value:2")>=0);       
+    }
+    
     public void testCachedPut()
         throws Exception
     {
@@ -290,20 +306,20 @@
     }
     
     public void testDestroy()
-	    throws Exception
-	{
-	    HttpFields header = new HttpFields();
-	    
-	    header.put(new ByteArrayBuffer("name0"), new View(new ByteArrayBuffer("value0")));
-	    assertTrue(header.getFieldNames().hasMoreElements());
-	    assertNotNull(header.getStringField("name0"));
-	    assertNull(header.getStringField("name1"));
-	    
-	    header.destroy();
-	
-	    assertNull(header.getStringField("name0"));
-	}
+        throws Exception
+    {
+        HttpFields header = new HttpFields();
+        
+        header.put(new ByteArrayBuffer("name0"), new View(new ByteArrayBuffer("value0")));
+        assertTrue(header.getFieldNames().hasMoreElements());
+        assertNotNull(header.getStringField("name0"));
+        assertNull(header.getStringField("name1"));
+        
+        header.destroy();
 
+        assertNull(header.getStringField("name0"));
+    }
+
     public void testCase()
     throws Exception
     {
Index: modules/jetty/src/test/java/org/mortbay/jetty/RFC2616Test.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/RFC2616Test.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/RFC2616Test.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 /*
  * Created on 9/01/2004
  *
Index: modules/jetty/src/test/java/org/mortbay/jetty/RandomConnector.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/RandomConnector.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/RandomConnector.java	(working copy)
@@ -32,6 +32,7 @@
 import org.mortbay.io.Buffer;
 import org.mortbay.io.EndPoint;
 import org.mortbay.io.nio.ChannelEndPoint;
+import org.mortbay.io.nio.IndirectNIOBuffer;
 import org.mortbay.io.nio.NIOBuffer;
 import org.mortbay.jetty.nio.AbstractNIOConnector;
 import org.mortbay.jetty.servlet.Context;
@@ -265,7 +266,7 @@
                 len=buffer.space();
             
             // Load a length limited slice via a temp buffer
-            NIOBuffer temp= new NIOBuffer(len,false);
+            NIOBuffer temp= new IndirectNIOBuffer(len);
             int len2=super.fill(temp);
             if (len2<0)
             {
Index: modules/jetty/src/test/java/org/mortbay/jetty/HttpParserTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/HttpParserTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/HttpParserTest.java	(working copy)
@@ -151,6 +151,24 @@
         assertEquals(-1, h);
     }
 
+    public void testConnect()
+        throws Exception
+    {
+        StringEndPoint io=new StringEndPoint();
+        io.setInput("CONNECT 192.168.1.2:80 HTTP/1.1\015\012" + "\015\012");
+        ByteArrayBuffer buffer= new ByteArrayBuffer(4096);
+        SimpleBuffers buffers=new SimpleBuffers(new Buffer[]{buffer});
+
+        Handler handler = new Handler();
+        HttpParser parser= new HttpParser(buffers,io, handler, buffer.capacity(), 0);
+        parser.parse();
+        assertTrue(handler.request);
+        assertEquals("CONNECT", f0);
+        assertEquals("192.168.1.2:80", f1);
+        assertEquals("HTTP/1.1", f2);
+        assertEquals(-1, h);
+    }
+    
     public void testHeaderParse()
 	throws Exception
     {
@@ -163,6 +181,7 @@
                 + "Header3: \015\012"
                 + "Header4 \015\012"
                 + "  value4\015\012"
+                + "Server5: notServer\015\012"
                 + "\015\012");
         ByteArrayBuffer buffer= new ByteArrayBuffer(4096);
         SimpleBuffers buffers=new SimpleBuffers(new Buffer[]{buffer});
@@ -181,7 +200,9 @@
         assertEquals("", val[2]);
         assertEquals("Header4", hdr[3]);
         assertEquals("value4", val[3]);
-        assertEquals(3, h);
+        assertEquals("Server5", hdr[4]);
+        assertEquals("notServer", val[4]);
+        assertEquals(4, h);
     }
 
     public void testChunkParse()
@@ -453,6 +474,7 @@
 
     class Handler extends HttpParser.EventHandler
     {   
+        boolean request;
         HttpFields fields;
         
         public void content(Buffer ref)
@@ -467,6 +489,7 @@
         {
             try
             {
+                request=true;
                 h= -1;
                 hdr= new String[9];
                 val= new String[9];
@@ -519,6 +542,7 @@
 
         public void startResponse(Buffer version, int status, Buffer reason)
         {
+            request=false;
             f0 = version.toString();
 	    f1 = Integer.toString(status);
 	    f2 = reason.toString();
Index: modules/jetty/src/test/java/org/mortbay/jetty/handler/ContextHandlerTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/handler/ContextHandlerTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/handler/ContextHandlerTest.java	(working copy)
@@ -25,7 +25,16 @@
 import junit.framework.TestCase;
 
 import org.mortbay.resource.Resource;
+import org.mortbay.jetty.Server;
+import org.mortbay.jetty.LocalConnector;
+import org.mortbay.jetty.Connector;
+import org.mortbay.jetty.Request;
+import org.mortbay.jetty.HttpConnection;
 
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+
 /**
  * @version $Revision$
  */
@@ -47,28 +56,201 @@
 
         ContextHandler handler = new ContextHandler();
 
-        assertTrue("Not a directory " + testDirectory, testDirectory.isDirectory());
+        assertTrue("Not a directory " + testDirectory,testDirectory.isDirectory());
         handler.setBaseResource(Resource.newResource(testDirectory.toURL()));
 
         List paths = new ArrayList(handler.getResourcePaths(root));
-        assertEquals(2, paths.size());
+        assertEquals(2,paths.size());
 
         Collections.sort(paths);
-        assertEquals("/WEB-INF/jsp/", paths.get(0));
-        assertEquals("/WEB-INF/web.xml", paths.get(1));
+        assertEquals("/WEB-INF/jsp/",paths.get(0));
+        assertEquals("/WEB-INF/web.xml",paths.get(1));
     }
 
     private File setupTestDirectory() throws IOException
     {
-        File root = new File(System.getProperty("basedir", "modules/jetty"), "target/" + getClass().getName());
+        File tmp = File.createTempFile("cht",null);
+        tmp.delete();
+        tmp.mkdir();
+        tmp.deleteOnExit();
+        File root = new File(tmp,getClass().getName());
         root.mkdir();
 
-        File webInf = new File(root, "WEB-INF");
+        File webInf = new File(root,"WEB-INF");
         webInf.mkdir();
 
-        new File(webInf, "jsp").mkdir();
-        new File(webInf, "web.xml").createNewFile();
+        new File(webInf,"jsp").mkdir();
+        new File(webInf,"web.xml").createNewFile();
 
         return root;
     }
+
+    public void testVirtualHostNormalization() throws Exception
+    {
+        Server server = new Server();
+        LocalConnector connector = new LocalConnector();
+        server.setConnectors(new Connector[]
+        { connector });
+
+        ContextHandler contextA = new ContextHandler("/");
+        contextA.setVirtualHosts(new String[]
+        { "www.example.com" });
+        IsHandledHandler handlerA = new IsHandledHandler();
+        contextA.setHandler(handlerA);
+
+        ContextHandler contextB = new ContextHandler("/");
+        IsHandledHandler handlerB = new IsHandledHandler();
+        contextB.setHandler(handlerB);
+        contextB.setVirtualHosts(new String[]
+        { "www.example2.com." });
+
+        ContextHandler contextC = new ContextHandler("/");
+        IsHandledHandler handlerC = new IsHandledHandler();
+        contextC.setHandler(handlerC);
+
+        HandlerCollection c = new HandlerCollection();
+
+        c.addHandler(contextA);
+        c.addHandler(contextB);
+        c.addHandler(contextC);
+
+        server.setHandler(c);
+
+        try
+        {
+            server.start();
+            connector.getResponses("GET / HTTP/1.1\n" + "Host: www.example.com.\n\n");
+
+            assertTrue(handlerA.isHandled());
+            assertFalse(handlerB.isHandled());
+            assertFalse(handlerC.isHandled());
+
+            handlerA.reset();
+            handlerB.reset();
+            handlerC.reset();
+
+            connector.getResponses("GET / HTTP/1.1\n" + "Host: www.example2.com\n\n");
+
+            assertFalse(handlerA.isHandled());
+            assertTrue(handlerB.isHandled());
+            assertFalse(handlerC.isHandled());
+
+        }
+        finally
+        {
+            server.stop();
+        }
+
+    }
+
+    public void testVirtualHostWildcard() throws Exception
+    {
+        Server server = new Server();
+        LocalConnector connector = new LocalConnector();
+        server.setConnectors(new Connector[] { connector });
+
+        ContextHandler context = new ContextHandler("/");
+        
+        IsHandledHandler handler = new IsHandledHandler();
+        context.setHandler(handler);
+
+        server.addHandler(context);
+
+        try
+        {
+            server.start();
+            checkWildcardHost(true,server,new String[] {"example.com", "*.example.com"}, new String[] {"example.com", ".example.com", "vhost.example.com"});
+            checkWildcardHost(false,server,new String[] {"example.com", "*.example.com"}, new String[] {"badexample.com", ".badexample.com", "vhost.badexample.com"});
+            
+            checkWildcardHost(false,server,new String[] {"*."}, new String[] {"anything.anything"});
+            
+            checkWildcardHost(true,server,new String[] {"*.example.com"}, new String[] {"vhost.example.com", ".example.com"});
+            checkWildcardHost(false,server,new String[] {"*.example.com"}, new String[] {"vhost.www.example.com", "example.com", "www.vhost.example.com"});
+
+            checkWildcardHost(true,server,new String[] {"*.sub.example.com"}, new String[] {"vhost.sub.example.com", ".sub.example.com"});
+            checkWildcardHost(false,server,new String[] {"*.sub.example.com"}, new String[] {".example.com", "sub.example.com", "vhost.example.com"});
+            
+            checkWildcardHost(false,server,new String[] {"example.*.com","example.com.*"}, new String[] {"example.vhost.com", "example.com.vhost", "example.com"});            
+        }
+        finally
+        {
+            server.stop();
+        }
+    }
+
+    private void checkWildcardHost(boolean succeed, Server server, String[] contextHosts, String[] requestHosts) throws Exception
+    {
+        LocalConnector connector = (LocalConnector)server.getConnectors()[0];
+        ContextHandler context = (ContextHandler)server.getHandler();
+        context.setVirtualHosts(contextHosts);
+        
+        IsHandledHandler handler = (IsHandledHandler)context.getHandler();
+        for(int i=0; i < requestHosts.length; ++i)
+        {
+            String host = requestHosts[i];
+            connector.getResponses("GET / HTTP/1.1\n" + "Host: "+host+"\n\n");
+            if(succeed) 
+                assertTrue("'"+host+"' should have been handled.",handler.isHandled());
+            else
+                assertFalse("'"+host + "' should not have been handled.", handler.isHandled());
+            handler.reset();
+        }
+
+    }
+
+    public static final class IsHandledHandler extends AbstractHandler
+    {
+        private boolean handled;
+
+        public boolean isHandled()
+        {
+            return handled;
+        }
+
+        public void handle(String s, HttpServletRequest request, HttpServletResponse response, int i) throws IOException, ServletException
+        {
+            Request base_request = (request instanceof Request)?(Request)request:HttpConnection.getCurrentConnection().getRequest();
+            base_request.setHandled(true);
+            this.handled = true;
+        }
+
+        public void reset()
+        {
+            handled = false;
+        }
+    }
+
+    public void testAttributes() throws Exception
+    {
+        ContextHandler handler = new ContextHandler();
+        handler.setAttribute("aaa","111");
+        handler.getServletContext().setAttribute("bbb","222");
+        assertEquals("111",handler.getServletContext().getAttribute("aaa"));
+        assertEquals("222",handler.getAttribute("bbb"));
+        
+        handler.start();
+
+        handler.getServletContext().setAttribute("aaa","000");
+        handler.setAttribute("ccc","333");
+        handler.getServletContext().setAttribute("ddd","444");
+        assertEquals("111",handler.getServletContext().getAttribute("aaa"));
+        assertEquals("222",handler.getServletContext().getAttribute("bbb"));
+        assertEquals("333",handler.getServletContext().getAttribute("ccc"));
+        assertEquals("444",handler.getServletContext().getAttribute("ddd"));
+        
+        assertEquals("111",handler.getAttribute("aaa"));
+        assertEquals("222",handler.getAttribute("bbb"));
+        assertEquals("333",handler.getAttribute("ccc"));
+        assertEquals(null,handler.getAttribute("ddd"));
+        
+
+        handler.stop();
+
+        assertEquals("111",handler.getServletContext().getAttribute("aaa"));
+        assertEquals("222",handler.getServletContext().getAttribute("bbb"));
+        assertEquals("333",handler.getServletContext().getAttribute("ccc"));
+        assertEquals(null,handler.getServletContext().getAttribute("ddd"));
+        
+
+    }
 }
Index: modules/jetty/src/test/java/org/mortbay/jetty/ResponseTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/jetty/ResponseTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/jetty/ResponseTest.java	(working copy)
@@ -17,35 +17,29 @@
 
 
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.LineNumberReader;
 import java.io.PrintWriter;
-import java.net.HttpURLConnection;
 import java.net.Socket;
-import java.net.URL;
 import java.util.Enumeration;
+import java.util.Locale;
 import java.util.Map;
 
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.HttpSessionContext;
 
+import junit.framework.TestCase;
+
 import org.mortbay.jetty.bio.SocketConnector;
 import org.mortbay.jetty.handler.AbstractHandler;
 import org.mortbay.jetty.handler.ContextHandler;
 import org.mortbay.jetty.servlet.AbstractSessionManager;
 import org.mortbay.jetty.servlet.HashSessionIdManager;
 import org.mortbay.jetty.servlet.HashSessionManager;
-import org.mortbay.util.IO;
 
-import java.util.Locale;
-
-import junit.framework.TestCase;
-
 /**
  * @author gregw
  *
@@ -309,6 +303,7 @@
         response.sendError(500, "Database Error");
         assertEquals(500, response.getStatus());
         assertEquals("Database Error", response.getReason());
+        assertEquals("must-revalidate,no-cache,no-store", response.getHeader(HttpHeaders.CACHE_CONTROL));
 
         response=newResponse();
         
@@ -321,6 +316,7 @@
         response.sendError(406, "Super Nanny");
         assertEquals(406, response.getStatus());
         assertEquals("Super Nanny", response.getReason());
+        assertEquals("must-revalidate,no-cache,no-store", response.getHeader(HttpHeaders.CACHE_CONTROL));
     }
     
     public void testEncodeRedirect()
Index: modules/jetty/src/test/java/org/mortbay/io/BufferTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/io/BufferTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/io/BufferTest.java	(working copy)
@@ -17,6 +17,8 @@
 
 import junit.framework.TestCase;
 
+import org.mortbay.io.nio.DirectNIOBuffer;
+import org.mortbay.io.nio.IndirectNIOBuffer;
 import org.mortbay.io.nio.NIOBuffer;
 import org.mortbay.util.StringUtil;
 
@@ -42,8 +44,8 @@
         super.setUp();
         buffer=new Buffer[]{
           new ByteArrayBuffer(10),
-          new NIOBuffer(10,false),
-          new NIOBuffer(10,true)
+          new IndirectNIOBuffer(10),
+          new DirectNIOBuffer(10)
         };
     }
 
@@ -96,7 +98,17 @@
             assertEquals(t,2,bg[1]);
             assertEquals(t,3,bg[2]);
             
+            //test getting 0 bytes returns 0
+            int count = b.get(bg,0,0);
+            assertEquals(t,0, count);
             
+            //read up to end
+            count = b.get(bg,0,2);
+            assertEquals(t, 2, count);
+            
+            //test reading past end returns -1
+            count = b.get(bg,0,1);
+            assertEquals(t, -1, count);
         }
     }
     
@@ -107,7 +119,7 @@
         {
                 new ByteArrayBuffer("Test1234 "),
                 new ByteArrayBuffer("tEST1234 "),
-                new NIOBuffer(4096,true),
+                new DirectNIOBuffer(4096),
         };
         b[2].put("TeSt1234 ".getBytes(StringUtil.__UTF8));
         
@@ -115,6 +127,37 @@
             assertEquals("t"+i,b[0].hashCode(),b[i].hashCode()); 
     }
     
+    public void testGet () 
+    throws Exception
+    {
+        Buffer buff = new ByteArrayBuffer(new byte[]{(byte)0,(byte)1,(byte)2,(byte)3,(byte)4,(byte)5});
+        
+        byte[] readbuff = new byte[2];
+        
+        int count = buff.get(readbuff, 0, 2);
+        assertEquals(2, count);
+        assertEquals(readbuff[0], (byte)0);
+        assertEquals(readbuff[1], (byte)1);
+        
+        count = buff.get(readbuff, 0, 2);
+        assertEquals(2, count);
+        assertEquals(readbuff[0], (byte)2);
+        assertEquals(readbuff[1], (byte)3);
+        
+        count = buff.get(readbuff, 0, 0);
+        assertEquals(0, count);
+        
+        readbuff[0]=(byte)9;
+        readbuff[1]=(byte)9;
+        
+        count = buff.get(readbuff, 0, 2);
+        assertEquals(2, count);
+        
+        count = buff.get(readbuff, 0, 2);
+        assertEquals(-1, count);
+        
+    }
+    
     public void testInsensitive()
     {
         Buffer cs0 = new ByteArrayBuffer("Test 1234");
Index: modules/jetty/src/test/java/org/mortbay/io/BufferCacheTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/io/BufferCacheTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/io/BufferCacheTest.java	(working copy)
@@ -17,129 +17,147 @@
 import junit.framework.TestCase;
 
 /* ------------------------------------------------------------------------------- */
-/** 
+/**
  * 
  * @author gregw
  */
 public class BufferCacheTest extends TestCase
-{ 
-	final static String [] S ={"S0","S1","s2","s3"};
-	
-	BufferCache cache;
-	
-	public BufferCacheTest(String arg0)
-	{
-		super(arg0);
-	}
+{
+    final static String[] S=
+    { "S0", "S1", "s2", "s3" };
 
-	public static void main(String[] args)
-	{
-		junit.textui.TestRunner.run(BufferCacheTest.class);
-	}
+    BufferCache cache;
 
-	/**
-	 * @see TestCase#setUp()
-	 */
-	protected void setUp() throws Exception
-	{
-		super.setUp();
-		cache=new BufferCache();
-		cache.add(S[1],1);
-		cache.add(S[2],2);
-		cache.add(S[3],3);
-	}
+    public BufferCacheTest(String arg0)
+    {
+        super(arg0);
+    }
 
-	/**
-	 * @see TestCase#tearDown()
-	 */
-	protected void tearDown() throws Exception
-	{
-		super.tearDown();
-	}
+    public static void main(String[] args)
+    {
+        junit.textui.TestRunner.run(BufferCacheTest.class);
+    }
 
-	public void testLookupIndex()
-	{
-		for (int i=0;i<S.length;i++)
-		{
-			String s = "S0S1s2s3";
-			ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
-			BufferCache.CachedBuffer b=cache.get(buf);
-			int index=b==null?-1:b.getOrdinal();
-			
-			if (i>0)
-				assertEquals(i,index);
-			else
-				assertEquals(-1,index);
-		}
-	}
-	
+    /**
+     * @see TestCase#setUp()
+     */
+    protected void setUp() throws Exception
+    {
+        super.setUp();
+        cache=new BufferCache();
+        cache.add(S[1],1);
+        cache.add(S[2],2);
+        cache.add(S[3],3);
+    }
 
-	public void testGetBuffer()
-	{
-		for (int i=0;i<S.length;i++)
-		{
-			String s = "S0S1s2s3";
-			ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
-			Buffer b=cache.get(buf);
-			
-			if (i>0)
-				assertEquals(i,b.peek(1)-'0');
-			else
-				assertEquals(null,b);
-		}
-	}
-	
+    /**
+     * @see TestCase#tearDown()
+     */
+    protected void tearDown() throws Exception
+    {
+        super.tearDown();
+    }
 
-	public void testLookupBuffer()
-	{
-		for (int i=0;i<S.length;i++)
-		{
-			String s = "S0S1s2s3";
-			ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
-			Buffer b=cache.lookup(buf);
-			
-			assertEquals(S[i],b.toString());
-			if (i>0)
-				assertTrue(""+i,S[i]==b.toString());
-			else
-			{
+    public void testLookupIndex()
+    {
+        for (int i=0; i<S.length; i++)
+        {
+            String s="S0S1s2s3";
+            ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
+            BufferCache.CachedBuffer b=cache.get(buf);
+            int index=b==null?-1:b.getOrdinal();
+
+            if (i>0)
+                assertEquals(i,index);
+            else
+                assertEquals(-1,index);
+        }
+    }
+
+    public void testGetBuffer()
+    {
+        for (int i=0; i<S.length; i++)
+        {
+            String s="S0S1s2s3";
+            ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
+            Buffer b=cache.get(buf);
+
+            if (i>0)
+                assertEquals(i,b.peek(1)-'0');
+            else
+                assertEquals(null,b);
+        }
+    }
+
+    public void testLookupBuffer()
+    {
+        for (int i=0; i<S.length; i++)
+        {
+            String s="S0S1s2s3";
+            ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
+            Buffer b=cache.lookup(buf);
+
+            assertEquals(S[i],b.toString());
+            if (i>0)
+                assertTrue(""+i,S[i]==b.toString());
+            else
+            {
                 assertTrue(""+i,S[i]!=b.toString());
                 assertEquals(""+i,S[i],b.toString());
-            } 
-		}
-	}
-	
-	public void testInsensitiveLookupBuffer()
-	{
-		for (int i=0;i<S.length;i++)
-		{
-			String s = "s0s1S2S3";
-			ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
-			Buffer b=cache.lookup(buf);
-			
-			assertTrue("test"+i,S[i].equalsIgnoreCase(b.toString()));
-			if (i>0)
-				assertTrue("test"+i,S[i]==b.toString());
-			else
+            }
+        }
+    }
+
+    public void testLookupPartialBuffer()
+    {
+        cache.add("44444",4);
+        
+        ByteArrayBuffer buf=new ByteArrayBuffer("44444");
+        Buffer b=cache.lookup(buf);
+        assertEquals("44444",b.toString());
+        assertEquals(4,cache.getOrdinal(b));
+        
+        buf=new ByteArrayBuffer("4444");
+        b=cache.lookup(buf);
+        assertEquals(-1,cache.getOrdinal(b));
+        
+        buf=new ByteArrayBuffer("44444x");
+        b=cache.lookup(buf);
+        assertEquals(-1,cache.getOrdinal(b));
+        
+
+    }
+
+    public void testInsensitiveLookupBuffer()
+    {
+        for (int i=0; i<S.length; i++)
+        {
+            String s="s0s1S2S3";
+            ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
+            Buffer b=cache.lookup(buf);
+
+            assertTrue("test"+i,S[i].equalsIgnoreCase(b.toString()));
+            if (i>0)
+                assertTrue("test"+i,S[i]==b.toString());
+            else
                 assertTrue("test"+i,S[i]!=b.toString());
-		}
-	}
-	
+        }
+    }
 
-	public void testToString()
-	{
-		for (int i=0;i<S.length;i++)
-		{
-			String s = "S0S1s2s3";
-			ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
-			String b=cache.toString(buf);
-			
-			assertEquals(S[i],b);
-			if (i>0)
-				assertTrue(S[i]==b);
-			else
-				assertTrue(S[i]!=b);
-		}
-	}
-	
+    public void testToString()
+    {
+        for (int i=0; i<S.length; i++)
+        {
+            String s="S0S1s2s3";
+            ByteArrayBuffer buf=new ByteArrayBuffer(s.getBytes(),i*2,2);
+            String b=cache.toString(buf);
+
+            assertEquals(S[i],b);
+            if (i>0)
+                assertTrue(S[i]==b);
+            else
+                assertTrue(S[i]!=b);
+        }
+    }
+
 }
Index: modules/jetty/src/test/java/org/mortbay/resource/ResourceTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/resource/ResourceTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/resource/ResourceTest.java	(working copy)
@@ -17,6 +17,7 @@
 
 import java.io.File;
 import java.io.FilePermission;
+import java.io.FilenameFilter;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.jar.JarInputStream;
@@ -250,9 +251,16 @@
             assertTrue(""+i+":"+data[i].test,c.startsWith(data[i].content));
         }
     }
-    
-    
-    
+
+    /* ------------------------------------------------------------ */
+    public void testEncoding() throws Exception
+    {
+        Resource r =Resource.newResource("/tmp/a file with,spe#ials/");
+        assertTrue(r.getURL().toString().indexOf("a%20file%20with,spe%23ials")>0);
+        assertTrue(r.getFile().toString().indexOf("a file with,spe#ials")>0);
+    }
+
+    /* ------------------------------------------------------------ */
     public void testJarFile()
     throws Exception
     {
@@ -266,6 +274,61 @@
         
     }
 
+    /* ------------------------------------------------------------ */
+    public void testJarFileCopyToDirectoryTraversal () throws Exception
+    {
+        String s = "jar:"+__userURL+"TestData/extract.zip!/";
+        Resource r = Resource.newResource(s);
+
+        assertTrue(r instanceof JarResource);
+        JarResource jarResource = (JarResource)r;
+
+        File destParent = File.createTempFile("copyjar", null);
+        if (destParent.exists())
+            destParent.delete();
+        destParent.mkdir();
+        destParent.deleteOnExit();
+        
+        File dest = new File(destParent.getCanonicalPath()+"/extract");
+        if(dest.exists())
+            dest.delete();
+        dest.mkdir();
+        dest.deleteOnExit();
+
+        JarResource.extract(jarResource, dest, true);
+
+        // dest contains only the valid entry; dest.getParent() contains only the dest directory
+        assertEquals(1, dest.listFiles().length);
+        assertEquals(1, dest.getParentFile().listFiles().length);
+
+        FilenameFilter dotdotFilenameFilter = new FilenameFilter() {
+            public boolean accept(File directory, String name)
+            {
+                return name.equals("dotdot.txt");
+            }
+        };        
+        assertEquals(0, dest.listFiles(dotdotFilenameFilter).length);
+        assertEquals(0, dest.getParentFile().listFiles(dotdotFilenameFilter).length);
+
+        FilenameFilter extractfileFilenameFilter = new FilenameFilter() {
+            public boolean accept(File directory, String name)
+            {
+                return name.equals("extract-filenotdir");
+            }
+        };
+        assertEquals(0, dest.listFiles(extractfileFilenameFilter).length);
+        assertEquals(0, dest.getParentFile().listFiles(extractfileFilenameFilter).length);
+
+        FilenameFilter currentDirectoryFilenameFilter = new FilenameFilter() {
+            public boolean accept(File directory, String name)
+            {
+                return name.equals("current.txt");
+            }
+        };
+        assertEquals(1, dest.listFiles(currentDirectoryFilenameFilter).length);
+        assertEquals(0, dest.getParentFile().listFiles(currentDirectoryFilenameFilter).length);        
+    }
+
     /**
      * Test a class path resource for existence.
      */
Index: modules/jetty/src/test/java/org/mortbay/thread/TimeoutTest.java
===================================================================
--- modules/jetty/src/test/java/org/mortbay/thread/TimeoutTest.java	(revision 5689)
+++ modules/jetty/src/test/java/org/mortbay/thread/TimeoutTest.java	(working copy)
@@ -1,133 +0,0 @@
-//========================================================================
-//$Id: TimeoutTest.java,v 1.1 2005/10/05 14:09:42 janb Exp $
-//Copyright 2004-2005 Mort Bay Consulting Pty. Ltd.
-//------------------------------------------------------------------------
-//Licensed under the Apache License, Version 2.0 (the "License");
-//you may not use this file except in compliance with the License.
-//You may obtain a copy of the License at 
-//http://www.apache.org/licenses/LICENSE-2.0
-//Unless required by applicable law or agreed to in writing, software
-//distributed under the License is distributed on an "AS IS" BASIS,
-//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//See the License for the specific language governing permissions and
-//limitations under the License.
-//========================================================================
-
-package org.mortbay.thread;
-
-import junit.framework.TestCase;
-
-public class TimeoutTest extends TestCase
-{
-    Timeout timeout = new Timeout();
-    Timeout.Task[] tasks;
-
-    /* ------------------------------------------------------------ */
-    /* 
-     * @see junit.framework.TestCase#setUp()
-     */
-    protected void setUp() throws Exception
-    {
-        super.setUp();
-        
-        timeout=new Timeout();
-        timeout.setDuration(1000000);
-        tasks= new Timeout.Task[10]; 
-        
-        for (int i=0;i<tasks.length;i++)
-        {
-            tasks[i]=new Timeout.Task();
-            timeout.setNow(1000+i*100);
-            timeout.schedule(tasks[i]);
-        }
-        timeout.setNow(100);
-    }
-
-    /* ------------------------------------------------------------ */
-    /* 
-     * @see junit.framework.TestCase#tearDown()
-     */
-    protected void tearDown() throws Exception
-    {
-        super.tearDown();
-    }
-    
-
-    /* ------------------------------------------------------------ */
-    public void testExpiry()
-    {
-        timeout.setDuration(200);
-        timeout.setNow(1500);
-        timeout.tick();
-        
-        for (int i=0;i<tasks.length;i++)
-        {
-            assertEquals("isExpired "+i,i<4, tasks[i].isExpired());
-        }
-    }
-
-    /* ------------------------------------------------------------ */
-    public void testCancel()
-    {
-        timeout.setDuration(200);
-        timeout.setNow(1700);
-
-        for (int i=0;i<tasks.length;i++)
-            if (i%2==1)
-                tasks[i].cancel();
-
-        timeout.tick();
-        
-        for (int i=0;i<tasks.length;i++)
-        {
-            assertEquals("isExpired "+i,i%2==0 && i<6, tasks[i].isExpired());
-        }
-    }
-
-    /* ------------------------------------------------------------ */
-    public void testTouch()
-    {
-        timeout.setDuration(200);
-        timeout.setNow(1350);
-        tasks[2].reschedule();
-        
-        
-        timeout.setNow(1500);
-        timeout.tick();
-        for (int i=0;i<tasks.length;i++)
-        {
-            assertEquals("isExpired "+i,i!=2 && i<4, tasks[i].isExpired());
-        }
-        
-        timeout.setNow(1550);
-        timeout.tick();
-        for (int i=0;i<tasks.length;i++)
-        {
-            assertEquals("isExpired "+i, i<4, tasks[i].isExpired());
-        }  
-    }
-
-
-    /* ------------------------------------------------------------ */
-    public void testDelay()
-    {
-        Timeout.Task task = new Timeout.Task();
-
-        timeout.setNow(1100);
-        timeout.schedule(task, 300);
-        timeout.setDuration(200);
-        
-        timeout.setNow(1300);
-        timeout.tick();
-        assertEquals("delay", false, task.isExpired());
-        
-        timeout.setNow(1500);
-        timeout.tick();
-        assertEquals("delay", false, task.isExpired());
-        
-        timeout.setNow(1700);
-        timeout.tick();
-        assertEquals("delay", true, task.isExpired());
-    }
-
-}
Index: modules/jetty/src/main/java/org/mortbay/jetty/NCSARequestLog.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/NCSARequestLog.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/NCSARequestLog.java	(working copy)
@@ -18,6 +18,7 @@
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
+import java.util.ArrayList;
 import java.util.Locale;
 import java.util.TimeZone;
 
@@ -30,6 +31,7 @@
 import org.mortbay.util.RolloverFileOutputStream;
 import org.mortbay.util.StringUtil;
 import org.mortbay.util.TypeUtil;
+import org.mortbay.util.Utf8StringBuffer;
 
 /** 
  * This {@link RequestLog} implementation outputs logs in the pseudo-standard NCSA common log format.
@@ -50,10 +52,10 @@
     private int _retainDays;
     private boolean _closeOut;
     private boolean _preferProxiedForAddress;
-    private String _logDateFormat;
+    private String _logDateFormat="dd/MMM/yyyy:HH:mm:ss Z";
     private String _filenameDateFormat = null;
     private Locale _logLocale = Locale.getDefault();
-    private String _logTimeZone = TimeZone.getDefault().getID();
+    private String _logTimeZone = "GMT";
     private String[] _ignorePaths;
     private boolean _logLatency = false;
     private boolean _logCookies = false;
@@ -64,6 +66,8 @@
     private transient DateCache _logDateCache;
     private transient PathMap _ignorePathMap;
     private transient Writer _writer;
+    private transient ArrayList _buffers;
+    private transient char[] _copy;
 
     
     public NCSARequestLog()
@@ -127,7 +131,16 @@
         return _logDateFormat;
     }
     
+    public void setLogLocale(Locale logLocale)
+    {
+        _logLocale = logLocale;
+    }
     
+    public Locale getLogLocale()
+    {
+        return _logLocale;
+    }
+    
     public void setLogTimeZone(String tz) 
     {
         _logTimeZone = tz;
@@ -213,6 +226,7 @@
         _preferProxiedForAddress = preferProxiedForAddress;
     }
 
+    /* ------------------------------------------------------------ */
     public void log(Request request, Response response)
     {
         if (!isStarted()) 
@@ -226,8 +240,15 @@
             if (_fileOut == null)
                 return;
 
-            StringBuffer buf = new StringBuffer(160);
-            String log =null;
+            Utf8StringBuffer u8buf;
+            StringBuffer buf;
+            synchronized(_writer)
+            {
+                int size=_buffers.size();
+                u8buf = size==0?new Utf8StringBuffer(160):(Utf8StringBuffer)_buffers.remove(size-1);
+                buf = u8buf.getStringBuffer();
+            }
+            
             synchronized(buf) // for efficiency until we can use StringBuilder
             {
                 if (_logServer)
@@ -258,7 +279,9 @@
                 buf.append("] \"");
                 buf.append(request.getMethod());
                 buf.append(' ');
-                buf.append(request.getUri());
+                
+                request.getUri().writeTo(u8buf);
+                
                 buf.append(' ');
                 buf.append(request.getProtocol());
                 buf.append("\" ");
@@ -293,44 +316,69 @@
                 else 
                     buf.append(" - ");
 
-                log = buf.toString();
             }
-            
-            synchronized(_writer)
+
+            if (!_extended && !_logCookies && !_logLatency)
             {
-                _writer.write(log);
-                if (_extended)
-                    logExtended(request, response, _writer);
-                
-                if (_logCookies)
+                synchronized(_writer)
                 {
-                    Cookie[] cookies = request.getCookies(); 
-                    if (cookies == null || cookies.length == 0)
-                        _writer.write(" -");
-                    else
+                    buf.append(StringUtil.__LINE_SEPARATOR);
+                    int l=buf.length();
+                    if (l>_copy.length)
+                        l=_copy.length;  
+                    buf.getChars(0,l,_copy,0); 
+                    _writer.write(_copy,0,l);
+                    _writer.flush();
+                    u8buf.reset();
+                    _buffers.add(u8buf); 
+                }
+            }
+            else
+            {
+                synchronized(_writer)
+                {
+                    int l=buf.length();
+                    if (l>_copy.length)
+                        l=_copy.length;  
+                    buf.getChars(0,l,_copy,0); 
+                    _writer.write(_copy,0,l);
+                    u8buf.reset();
+                    _buffers.add(u8buf); 
+
+                    // TODO do outside synchronized scope
+                    if (_extended)
+                        logExtended(request, response, _writer);
+
+                    // TODO do outside synchronized scope
+                    if (_logCookies)
                     {
-                        _writer.write(" \"");
-                        for (int i = 0; i < cookies.length; i++) 
+                        Cookie[] cookies = request.getCookies(); 
+                        if (cookies == null || cookies.length == 0)
+                            _writer.write(" -");
+                        else
                         {
-                            if (i != 0)
-                                _writer.write(';');
-                            _writer.write(cookies[i].getName());
-                            _writer.write('=');
-                            _writer.write(cookies[i].getValue());
+                            _writer.write(" \"");
+                            for (int i = 0; i < cookies.length; i++) 
+                            {
+                                if (i != 0)
+                                    _writer.write(';');
+                                _writer.write(cookies[i].getName());
+                                _writer.write('=');
+                                _writer.write(cookies[i].getValue());
+                            }
+                            _writer.write('\"');
                         }
-                        _writer.write("\"");
                     }
+
+                    if (_logLatency)
+                    {
+                        _writer.write(' ');
+                        _writer.write(TypeUtil.toString(System.currentTimeMillis() - request.getTimeStamp()));
+                    }
+
+                    _writer.write(StringUtil.__LINE_SEPARATOR);
+                    _writer.flush();
                 }
-                
-                if (_logLatency)
-                {
-                    _writer.write(" ");
-                    _writer.write(TypeUtil.toString(System.currentTimeMillis() - request.getTimeStamp()));
-                }
-                
-                _writer.write(StringUtil.__LINE_SEPARATOR);
-                _writer.flush();
-                
             }
         } 
         catch (IOException e) 
@@ -339,7 +387,8 @@
         }
         
     }
-    
+
+    /* ------------------------------------------------------------ */
     protected void logExtended(Request request, 
                                Response response, 
                                Writer writer) throws IOException 
@@ -365,6 +414,7 @@
         }          
     }
 
+    /* ------------------------------------------------------------ */
     protected void doStart() throws Exception
     {
         if (_logDateFormat!=null)
@@ -394,9 +444,12 @@
             _ignorePathMap = null;
         
         _writer = new OutputStreamWriter(_out);
+        _buffers = new ArrayList();
+        _copy = new char[1024];
         super.doStart();
     }
 
+    /* ------------------------------------------------------------ */
     protected void doStop() throws Exception
     {
         super.doStop();
@@ -409,6 +462,8 @@
         _closeOut = false;
         _logDateCache = null;
         _writer = null;
+        _buffers = null;
+        _copy = null;
     }
 
     /* ------------------------------------------------------------ */
Index: modules/jetty/src/main/java/org/mortbay/jetty/servlet/ServletHandler.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/servlet/ServletHandler.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/servlet/ServletHandler.java	(working copy)
@@ -219,6 +219,15 @@
     }
     
     /* ------------------------------------------------------------ */
+    /** Whether there is a ServletHolder that matches this path
+     * @param pathInContext Path within _context.
+     * @return whether there is a ServletHolder that matches this path
+     */
+    public boolean matchesPath(String pathInContext)
+    {
+        return _servletPathMap.containsMatch(pathInContext);
+    }
+    /* ------------------------------------------------------------ */
     /**
      * @return A {@link RequestDispatcher dispatcher} wrapping the resource at <code>uriInContext</code>,
      *  or <code>null</code> if the specified uri cannot be dispatched to.
@@ -399,7 +408,13 @@
                     th=cause;
             }
             
-            if (th instanceof HttpException)
+            // hnndle or log exception
+            if (th instanceof RetryRequest)
+            {
+                base_request.setHandled(false);
+                throw (RetryRequest)th;  
+            }
+            else if (th instanceof HttpException)
                 throw (HttpException)th;
             else if (th instanceof RuntimeIOException)
                 throw (RuntimeIOException)th;
Index: modules/jetty/src/main/java/org/mortbay/jetty/servlet/DefaultServlet.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/servlet/DefaultServlet.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/servlet/DefaultServlet.java	(working copy)
@@ -34,6 +34,8 @@
 import org.mortbay.io.Buffer;
 import org.mortbay.io.ByteArrayBuffer;
 import org.mortbay.io.WriterOutputStream;
+import org.mortbay.io.nio.DirectNIOBuffer;
+import org.mortbay.io.nio.IndirectNIOBuffer;
 import org.mortbay.io.nio.NIOBuffer;
 import org.mortbay.jetty.Connector;
 import org.mortbay.jetty.HttpConnection;
@@ -909,9 +911,7 @@
 
             if (_useFileMappedBuffer && resource.getFile()!=null) 
             {    
-                File file = resource.getFile();
-                if (file != null) 
-                    buffer = new NIOBuffer(file);
+                buffer = new DirectNIOBuffer(resource.getFile());
             } 
             else 
             {
@@ -919,13 +919,16 @@
                 try
                 {
                     Connector connector = HttpConnection.getCurrentConnection().getConnector();
-                    buffer = new NIOBuffer((int) length, ((NIOConnector)connector).getUseDirectBuffers()?NIOBuffer.DIRECT:NIOBuffer.INDIRECT);
+                    buffer = ((NIOConnector)connector).getUseDirectBuffers()?
+                            (NIOBuffer)new DirectNIOBuffer((int)length):
+                            (NIOBuffer)new IndirectNIOBuffer((int)length);
+                                
                 }
                 catch(OutOfMemoryError e)
                 {
                     Log.warn(e.toString());
                     Log.debug(e);
-                    buffer = new NIOBuffer((int) length, NIOBuffer.INDIRECT);
+                    buffer = new IndirectNIOBuffer((int) length);
                 }
                 buffer.readFrom(is,(int)length);
                 is.close();
Index: modules/jetty/src/main/java/org/mortbay/jetty/servlet/PathMap.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/servlet/PathMap.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/servlet/PathMap.java	(working copy)
@@ -325,6 +325,20 @@
         return LazyList.getList(getLazyMatches(path));
     }
 
+    /* --------------------------------------------------------------- */
+    /** Return whether the path matches any entries in the PathMap, 
+     * excluding the default entry 
+     * @param path Path to match
+     * @return Whether the PathMap contains any entries that match this
+     */
+    public boolean containsMatch(String path)
+    {       
+        Entry match = getMatch(path);
+        return match!=null && !match.equals(_default);
+    }
+
+    
+    
     /* --------------------------------------------------------------- */  
     public synchronized Object remove(Object pathSpec)
     {
Index: modules/jetty/src/main/java/org/mortbay/jetty/HttpFields.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/HttpFields.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/HttpFields.java	(working copy)
@@ -15,9 +15,6 @@
 package org.mortbay.jetty;
 
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.io.Writer;
-import java.net.URLEncoder;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
@@ -42,7 +39,7 @@
 import org.mortbay.io.BufferUtil;
 import org.mortbay.io.ByteArrayBuffer;
 import org.mortbay.io.View;
-import org.mortbay.util.DateCache;
+import org.mortbay.io.BufferCache.CachedBuffer;
 import org.mortbay.util.LazyList;
 import org.mortbay.util.QuotedStringTokenizer;
 import org.mortbay.util.StringMap;
@@ -193,7 +190,7 @@
             __dateReceive[i].setTimeZone(__GMT);
         }
     }
-    public final static String __01Jan1970 = formatDate(0, false);
+    public final static String __01Jan1970 = formatDate(0, false).trim();
     public final static Buffer __01Jan1970_BUFFER = new ByteArrayBuffer(__01Jan1970);
 
     /* -------------------------------------------------------------- */
@@ -530,8 +527,9 @@
      * 
      * @param name the name of the field
      * @param value the value of the field. If null the field is cleared.
+     * @param numValue the numeric value of the field (must match value) or -1
      */
-    private void put(Buffer name, Buffer value, long numValue)
+    public void put(Buffer name, Buffer value, long numValue)
     {
         if (value == null)
         {
@@ -964,12 +962,10 @@
         String name_value_params = null;
         synchronized (buf)
         {
-            buf.append(name);
+            QuotedStringTokenizer.quoteIfNeeded(buf, name);
             buf.append('=');
             if (value != null && value.length() > 0)
-            {
-                URIUtil.encodePath(buf,value);
-            }
+                QuotedStringTokenizer.quoteIfNeeded(buf, value);
 
             if (version > 0)
             {
@@ -986,13 +982,16 @@
             if (path != null && path.length() > 0)
             {
                 buf.append(";Path=");
-                buf.append(URIUtil.encodePath(path));
+                if (path.startsWith("\""))
+                    buf.append(path);
+                else
+                    QuotedStringTokenizer.quoteIfNeeded(buf,path);
             }
             String domain = cookie.getDomain();
             if (domain != null && domain.length() > 0)
             {
                 buf.append(";Domain=");
-                buf.append(domain.toLowerCase());// lowercase for IE
+                QuotedStringTokenizer.quoteIfNeeded(buf,domain.toLowerCase());
             }
 
             long maxAge = cookie.getMaxAge();
@@ -1021,7 +1020,8 @@
             {
                 buf.append(";Secure");
             }
-            if (cookie instanceof HttpOnlyCookie) buf.append(";HttpOnly");
+            if (cookie instanceof HttpOnlyCookie)
+                buf.append(";HttpOnly");
 
             // TODO - straight to Buffer?
             name_value_params = buf.toString();
@@ -1031,20 +1031,6 @@
     }
 
     /* -------------------------------------------------------------- */
-    public void write(Writer writer) throws IOException
-    {
-        synchronized (writer)
-        {
-            for (int i = 0; i < _fields.size(); i++)
-            {
-                Field field = (Field) _fields.get(i);
-                if (field != null && field._revision == _revision) field.write(writer);
-            }
-            writer.write(StringUtil.CRLF);
-        }
-    }
-
-    /* -------------------------------------------------------------- */
     public void put(Buffer buffer) throws IOException
     {
         for (int i = 0; i < _fields.size(); i++)
@@ -1060,9 +1046,24 @@
     {
         try
         {
-            ByteArrayBuffer buffer = new ByteArrayBuffer(4096);
-            put(buffer);
-            return BufferUtil.to8859_1_String(buffer);
+            StringBuffer buffer = new StringBuffer();
+          
+            for (int i = 0; i < _fields.size(); i++)
+            {
+                Field field = (Field) _fields.get(i);
+                if (field != null && field._revision == _revision)
+                {
+                    String tmp = field.getName();
+                    if (tmp != null) buffer.append(tmp);
+                    buffer.append(": ");
+                    tmp = field.getValue();
+                    if (tmp != null) buffer.append(tmp);
+                    buffer.append("\r\n");
+                }
+            } 
+            buffer.append("\r\n");
+            return buffer.toString();
+            
         }
         catch (Exception e)
         {
@@ -1102,8 +1103,8 @@
             {
                 Field field = (Field) _fields.get(i);
                 if (field != null) {
-                	_bufferMap.remove(field.getNameBuffer());
-                	field.destroy();
+                    _bufferMap.remove(field.getNameBuffer());
+                    field.destroy();
                 }
             }
         }
@@ -1373,23 +1374,58 @@
                 }
             }
         }
+        
+        
 
         /* ------------------------------------------------------------ */
-        public void write(Writer writer) throws IOException
-        {
-            writer.write(BufferUtil.to8859_1_String(_name));
-            writer.write(":");
-            writer.write(BufferUtil.to8859_1_String(_value));
-            writer.write(StringUtil.CRLF);
-        }
-
-        /* ------------------------------------------------------------ */
         public void put(Buffer buffer) throws IOException
         {
-            buffer.put(_name);
+            int o=(_name instanceof CachedBuffer)?((CachedBuffer)_name).getOrdinal():-1;
+            if (o>=0)
+                buffer.put(_name);
+            else
+            {
+                int s=_name.getIndex();
+                int e=_name.putIndex();
+                while (s<e)
+                {
+                    byte b=_name.peek(s++);
+                    switch(b)
+                    {
+                        case '\r':
+                        case '\n':
+                        case ':' :
+                            continue;
+                        default:
+                            buffer.put(b);
+                    }
+                }
+            }
+            
             buffer.put((byte) ':');
             buffer.put((byte) ' ');
-            buffer.put(_value);
+            
+            o=(_value instanceof CachedBuffer)?((CachedBuffer)_value).getOrdinal():-1;
+            if (o>=0 || _numValue>=0)
+                buffer.put(_value);
+            else
+            {
+                int s=_value.getIndex();
+                int e=_value.putIndex();
+                while (s<e)
+                {
+                    byte b=_value.peek(s++);
+                    switch(b)
+                    {
+                        case '\r':
+                        case '\n':
+                            continue;
+                        default:
+                            buffer.put(b);
+                    }
+                }
+            }
+
             BufferUtil.putCRLF(buffer);
         }
 
Index: modules/jetty/src/main/java/org/mortbay/jetty/MimeTypes.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/MimeTypes.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/MimeTypes.java	(working copy)
@@ -25,7 +25,6 @@
 import org.mortbay.io.BufferCache;
 import org.mortbay.io.BufferCache.CachedBuffer;
 import org.mortbay.log.Log;
-import org.mortbay.util.QuotedStringTokenizer;
 import org.mortbay.util.StringUtil;
 
 
@@ -47,8 +46,12 @@
       TEXT_XML_8859_1="text/xml; charset=iso-8859-1",
       TEXT_HTML_UTF_8="text/html; charset=utf-8",
       TEXT_PLAIN_UTF_8="text/plain; charset=utf-8",
-      TEXT_XML_UTF_8="text/xml; charset=utf-8";
+      TEXT_XML_UTF_8="text/xml; charset=utf-8",
     
+      // minimal changes for 6.1.12
+      TEXT_JSON="text/json",
+      TEXT_JSON_UTF_8="text/json;charset=UTF-8";
+    
 
     private final static int
 	FORM_ENCODED_ORDINAL=1,
@@ -62,9 +65,13 @@
         TEXT_XML_8859_1_ORDINAL=9,
         TEXT_HTML_UTF_8_ORDINAL=10,
         TEXT_PLAIN_UTF_8_ORDINAL=11,
-        TEXT_XML_UTF_8_ORDINAL=12;
+        TEXT_XML_UTF_8_ORDINAL=12,
+        TEXT_JSON_ORDINAL=13,
+        TEXT_JSON_UTF_8_ORDINAL=14;
+        
+        
     
-    private static int __index=13;
+    private static int __index=15;
     
     public final static BufferCache CACHE = new BufferCache(); 
 
@@ -82,9 +89,12 @@
     	TEXT_XML_8859_1_BUFFER=new CachedBuffer(TEXT_XML_8859_1,TEXT_XML_8859_1_ORDINAL),
         TEXT_HTML_UTF_8_BUFFER=new CachedBuffer(TEXT_HTML_UTF_8,TEXT_HTML_UTF_8_ORDINAL),
         TEXT_PLAIN_UTF_8_BUFFER=new CachedBuffer(TEXT_PLAIN_UTF_8,TEXT_PLAIN_UTF_8_ORDINAL),
-        TEXT_XML_UTF_8_BUFFER=new CachedBuffer(TEXT_XML_UTF_8,TEXT_XML_UTF_8_ORDINAL);
+        TEXT_XML_UTF_8_BUFFER=new CachedBuffer(TEXT_XML_UTF_8,TEXT_XML_UTF_8_ORDINAL),
     
+        TEXT_JSON_BUFFER=CACHE.add(TEXT_JSON,TEXT_JSON_ORDINAL),
+        TEXT_JSON_UTF_8_BUFFER=CACHE.add(TEXT_JSON_UTF_8,TEXT_JSON_UTF_8_ORDINAL);
     
+    
     /* ------------------------------------------------------------ */
     /* ------------------------------------------------------------ */
     private final static Map __dftMimeMap = new HashMap();
@@ -146,6 +156,11 @@
         TEXT_XML_BUFFER.setAssociate("utf8",TEXT_XML_UTF_8_BUFFER);
         TEXT_XML_BUFFER.setAssociate("UTF8",TEXT_XML_UTF_8_BUFFER);
         TEXT_XML_BUFFER.setAssociate("utf-8",TEXT_XML_UTF_8_BUFFER);
+        
+        TEXT_JSON_BUFFER.setAssociate("UTF-8",TEXT_JSON_UTF_8_BUFFER);
+        TEXT_JSON_BUFFER.setAssociate("utf8",TEXT_JSON_UTF_8_BUFFER);
+        TEXT_JSON_BUFFER.setAssociate("UTF8",TEXT_JSON_UTF_8_BUFFER);
+        TEXT_JSON_BUFFER.setAssociate("utf-8",TEXT_JSON_UTF_8_BUFFER);
     }
 
 
@@ -263,6 +278,8 @@
                 case TEXT_HTML_UTF_8_ORDINAL:
                 case TEXT_PLAIN_UTF_8_ORDINAL:
                 case TEXT_XML_UTF_8_ORDINAL:
+                case TEXT_JSON_ORDINAL:
+                case TEXT_JSON_UTF_8_ORDINAL:
                     return StringUtil.__UTF8;
             }
         }
Index: modules/jetty/src/main/java/org/mortbay/jetty/SessionManager.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/SessionManager.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/SessionManager.java	(working copy)
@@ -37,7 +37,7 @@
     /* ------------------------------------------------------------ */
     /** Session cookie name.
      * Defaults to JSESSIONID, but can be set with the
-     * org.mortbay.jetty.servlet.SessionCookie system property.
+     * org.mortbay.jetty.servlet.SessionCookie context init parameter.
      */
     public final static String __SessionCookieProperty = "org.mortbay.jetty.servlet.SessionCookie";
     public final static String __DefaultSessionCookie = "JSESSIONID";   
@@ -46,7 +46,8 @@
     /* ------------------------------------------------------------ */
     /** Session URL parameter name.
      * Defaults to jsessionid, but can be set with the
-     * org.mortbay.jetty.servlet.SessionURL system property.
+     * org.mortbay.jetty.servlet.SessionURL context init parameter.  If set to null or 
+     * "none" no URL rewriting will be done.
      */
     public final static String __SessionURLProperty = "org.mortbay.jetty.servlet.SessionURL";
     public final static String __DefaultSessionURL = "jsessionid";
Index: modules/jetty/src/main/java/org/mortbay/jetty/AbstractConnector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/AbstractConnector.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/AbstractConnector.java	(working copy)
@@ -16,12 +16,13 @@
 package org.mortbay.jetty;
 
 import java.io.IOException;
+import java.net.InetAddress;
 import java.net.Socket;
-import java.util.ArrayList;
+import java.net.UnknownHostException;
 
-import org.mortbay.component.AbstractLifeCycle;
+import javax.servlet.ServletRequest;
+
 import org.mortbay.component.LifeCycle;
-import org.mortbay.io.Buffer;
 import org.mortbay.io.EndPoint;
 import org.mortbay.log.Log;
 import org.mortbay.thread.ThreadPool;
@@ -30,12 +31,13 @@
 
 
 /** Abstract Connector implementation.
- * This abstract implemenation of the Connector interface provides:<ul>
+ * This abstract implementation of the Connector interface provides:<ul>
  * <li>AbstractLifeCycle implementation</li>
  * <li>Implementations for connector getters and setters</li>
  * <li>Buffer management</li>
  * <li>Socket configuration</li>
  * <li>Base acceptor thread</li>
+ * <li>Optional reverse proxy headers checking</li>
  * </ul>
  * 
  * @author gregw
@@ -45,6 +47,7 @@
 public abstract class AbstractConnector extends AbstractBuffers implements Connector
 {
     private String _name;
+    
     private Server _server;
     private ThreadPool _threadPool;
     private String _host;
@@ -57,6 +60,12 @@
     private int _acceptors=1;
     private int _acceptorPriorityOffset=0;
     private boolean _useDNS;
+    private boolean _forwarded;
+    private String _hostHeader;
+    private String _forwardedHostHeader = "X-Forwarded-Host";             // default to mod_proxy_http header
+    private String _forwardedServerHeader = "X-Forwarded-Server";         // default to mod_proxy_http header
+    private String _forwardedForHeader = "X-Forwarded-For";               // default to mod_proxy_http header
+    private boolean _reuseAddress=true;
     
     protected int _maxIdleTime=200000; 
     protected int _lowResourceMaxIdleTime=-1; 
@@ -163,6 +172,28 @@
     
     /* ------------------------------------------------------------ */
     /**
+     * Set the maximum Idle time for a connection, which roughly translates
+     * to the {@link Socket#setSoTimeout(int)} call, although with NIO 
+     * implementations other mechanisms may be used to implement the timeout.  
+     * The max idle time is applied:<ul>
+     * <li>When waiting for a new request to be received on a connection</li>
+     * <li>When reading the headers and content of a request</li>
+     * <li>When writing the headers and content of a response</li>
+     * </ul>
+     * Jetty interprets this value as the maximum time between some progress being
+     * made on the connection. So if a single byte is read or written, then the 
+     * timeout (if implemented by jetty) is reset.  However, in many instances,
+     * the reading/writing is delegated to the JVM, and the semantic is more
+     * strictly enforced as the maximum time a single read/write operation can
+     * take.  Note, that as Jetty supports writes of memory mapped file buffers,
+     * then a write may take many 10s of seconds for large content written to a 
+     * slow device.
+     * <p>
+     * Previously, Jetty supported separate idle timeouts and IO operation timeouts,
+     * however the expense of changing the value of soTimeout was significant, so
+     * these timeouts were merged. With the advent of NIO, it may be possible to
+     * again differentiate these values (if there is demand).
+     * 
      * @param maxIdleTime The maxIdleTime to set.
      */
     public void setMaxIdleTime(int maxIdleTime)
@@ -192,7 +223,7 @@
     /**
      * @return Returns the soLingerTime.
      */
-    public long getSoLingerTime()
+    public int getSoLingerTime()
     {
         return _soLingerTime;
     }
@@ -245,6 +276,9 @@
     /* ------------------------------------------------------------ */
     protected void doStart() throws Exception
     {
+        if (_server==null)
+            throw new IllegalStateException("No server");
+        
         // open listener port
         open();
         
@@ -337,10 +371,83 @@
     /* ------------------------------------------------------------ */
     public void customize(EndPoint endpoint, Request request)
         throws IOException
-    {      
+    {
+        if (isForwarded())
+            checkForwardedHeaders(endpoint, request);
     }
-    
+
     /* ------------------------------------------------------------ */
+    protected void checkForwardedHeaders(EndPoint endpoint, Request request)
+        throws IOException
+    {
+        HttpFields httpFields = request.getConnection().getRequestFields();
+        
+        // Retrieving headers from the request
+        String forwardedHost = getLeftMostValue(httpFields.getStringField(getForwardedHostHeader()));
+        String forwardedServer = getLeftMostValue(httpFields.getStringField(getForwardedServerHeader()));
+        String forwardedFor = getLeftMostValue(httpFields.getStringField(getForwardedForHeader()));
+        
+        if (_hostHeader!=null)
+        {
+            // Update host header       
+            httpFields.put(HttpHeaders.HOST_BUFFER, _hostHeader);
+            request.setServerName(null);
+            request.setServerPort(-1);
+            request.getServerName();
+        }
+        else if (forwardedHost != null)
+        {
+            // Update host header	
+            httpFields.put(HttpHeaders.HOST_BUFFER, forwardedHost);
+            request.setServerName(null);
+            request.setServerPort(-1);
+            request.getServerName();
+        }
+        else if (forwardedServer != null)
+        {
+            // Use provided server name
+            request.setServerName(forwardedServer);
+        }
+        
+        if (forwardedFor != null)
+        {
+            request.setRemoteAddr(forwardedFor);
+            InetAddress inetAddress = null;
+            
+            if (_useDNS)
+            {
+                try
+                {
+                    inetAddress = InetAddress.getByName(forwardedFor);
+                }
+                catch (UnknownHostException e)
+                {
+                    Log.ignore(e);
+                }
+            }
+            
+            request.setRemoteHost(inetAddress==null?forwardedFor:inetAddress.getHostName());
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    protected String getLeftMostValue(String headerValue) {
+        if (headerValue == null)
+            return null;
+        
+        int commaIndex = headerValue.indexOf(',');
+        
+        if (commaIndex == -1)
+        {
+            // Single value
+            return headerValue;
+        }
+
+        // The left-most value is the farthest downstream client
+        return headerValue.substring(0, commaIndex);
+    }
+
+    /* ------------------------------------------------------------ */
     public void persist(EndPoint endpoint)
         throws IOException
     {      
@@ -466,6 +573,91 @@
     }
     
     /* ------------------------------------------------------------ */
+    /** 
+     * Is reverse proxy handling on?
+     * @return true if this connector is checking the x-forwarded-for/host/server headers
+     */
+    public boolean isForwarded()
+    {
+        return _forwarded;
+    }
+    
+    /* ------------------------------------------------------------ */
+    /**
+     * Set reverse proxy handling
+     * @param check true if this connector is checking the x-forwarded-for/host/server headers
+     */
+    public void setForwarded(boolean check)
+    {
+        if (check)
+            Log.debug(this+" is forwarded");
+        _forwarded=check;
+    }
+    
+    /* ------------------------------------------------------------ */
+    public String getHostHeader()
+    {
+        return _hostHeader;
+    }
+    
+    /* ------------------------------------------------------------ */
+    /** 
+     * Set a forced valued for the host header to control what is returned
+     * by {@link ServletRequest#getServerName()} and {@link ServletRequest#getServerPort()}.
+     * This value is only used if {@link #isForwarded()} is true.
+     * @param hostHeader The value of the host header to force.
+     */
+    public void setHostHeader(String hostHeader)
+    {
+        _hostHeader=hostHeader;
+    }
+    
+    /* ------------------------------------------------------------ */
+    public String getForwardedHostHeader()
+    {
+        return _forwardedHostHeader;
+    }
+    
+    /* ------------------------------------------------------------ */
+    /**
+     * @param forwardedHostHeader The header name for forwarded hosts (default x-forwarded-host)
+     */
+    public void setForwardedHostHeader(String forwardedHostHeader)
+    {
+        _forwardedHostHeader=forwardedHostHeader;
+    }
+    
+    /* ------------------------------------------------------------ */
+    public String getForwardedServerHeader()
+    {
+        return _forwardedServerHeader;
+    }
+    
+    /* ------------------------------------------------------------ */
+    /**
+     * @param forwardedServerHeader The header name for forwarded server (default x-forwarded-server)
+     */
+    public void setForwardedServerHeader(String forwardedServerHeader)
+    {
+        _forwardedServerHeader=forwardedServerHeader;
+    }
+    
+    /* ------------------------------------------------------------ */
+    public String getForwardedForHeader()
+    {
+        return _forwardedForHeader;
+    }
+    
+    /* ------------------------------------------------------------ */
+    /**
+     * @param forwardedRemoteAddressHeader The header name for forwarded for (default x-forwarded-for)
+     */
+    public void setForwardedForHeader(String forwardedRemoteAddressHeader)
+    {
+        _forwardedForHeader=forwardedRemoteAddressHeader;
+    }
+    
+    /* ------------------------------------------------------------ */
     public String toString()
     {
         String name = this.getClass().getName();
@@ -493,15 +685,16 @@
         public void run()
         {   
             Thread current = Thread.currentThread();
+            String name;
             synchronized(AbstractConnector.this)
             {
                 if (_acceptorThread==null)
                     return;
                 
                 _acceptorThread[_acceptor]=current;
+                name =_acceptorThread[_acceptor].getName();
+                current.setName(name+" - Acceptor"+_acceptor+" "+AbstractConnector.this);
             }
-            String name =_acceptorThread[_acceptor].getName();
-            current.setName(name+" - Acceptor"+_acceptor+" "+AbstractConnector.this);
             int old_priority=current.getPriority();
             
             try
@@ -523,8 +716,7 @@
                     }
                     catch(ThreadDeath e)
                     {
-                        Log.warn(e);
-			throw e;
+                        throw e;
                     }
                     catch(Throwable e)
                     {
@@ -783,4 +975,22 @@
         _acceptorPriorityOffset=offset;
     }
 
+    /* ------------------------------------------------------------ */
+    /**
+     * @return True if the the server socket will be opened in SO_REUSEADDR mode.
+     */
+    public boolean getReuseAddress()
+    {
+        return _reuseAddress;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * @param reuseAddress True if the the server socket will be opened in SO_REUSEADDR mode.
+     */
+    public void setReuseAddress(boolean reuseAddress)
+    {
+        _reuseAddress=reuseAddress;
+    }
+
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/EofException.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/EofException.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/EofException.java	(working copy)
@@ -14,9 +14,9 @@
 
 package org.mortbay.jetty;
 
-import java.io.IOException;
+import java.io.EOFException;
 
-public class EofException extends IOException
+public class EofException extends EOFException
 {
     public EofException()
     {
Index: modules/jetty/src/main/java/org/mortbay/jetty/bio/SocketConnector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/bio/SocketConnector.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/bio/SocketConnector.java	(working copy)
@@ -71,6 +71,7 @@
         // Create a new server socket and set to non blocking mode
         if (_serverSocket==null || _serverSocket.isClosed())
         _serverSocket= newServerSocket(getHost(),getPort(),getAcceptQueueSize());
+        _serverSocket.setReuseAddress(getReuseAddress());
     }
 
     /* ------------------------------------------------------------ */
@@ -185,7 +186,7 @@
         
         public void dispatch() throws InterruptedException, IOException
         {
-            if (!getThreadPool().dispatch(this))
+            if (getThreadPool()==null || !getThreadPool().dispatch(this))
             {
                 Log.warn("dispatch failed for {}",_connection);
                 close();
Index: modules/jetty/src/main/java/org/mortbay/jetty/RequestLog.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/RequestLog.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/RequestLog.java	(working copy)
@@ -17,7 +17,7 @@
 import org.mortbay.component.LifeCycle;
 
 /** 
- * A <code>RequestLog</code> can be attached to a {@link Server} to enable logging of requests/responses.
+ * A <code>RequestLog</code> can be attached to a {@link org.mortbay.jetty.handler.RequestLogHandler} to enable logging of requests/responses.
  * @author Nigel Canonizado
  * @see Server#setRequestLog
  */
Index: modules/jetty/src/main/java/org/mortbay/jetty/SessionIdManager.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/SessionIdManager.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/SessionIdManager.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 
 import javax.servlet.http.HttpServletRequest;
Index: modules/jetty/src/main/java/org/mortbay/jetty/HttpParser.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/HttpParser.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/HttpParser.java	(working copy)
@@ -35,17 +35,19 @@
 public class HttpParser implements Parser
 {
     // States
-    public static final int STATE_START=-11;
-    public static final int STATE_FIELD0=-10;
-    public static final int STATE_SPACE1=-9;
-    public static final int STATE_FIELD1=-8;
-    public static final int STATE_SPACE2=-7;
-    public static final int STATE_END0=-6;
-    public static final int STATE_END1=-5;
-    public static final int STATE_FIELD2=-4;
-    public static final int STATE_HEADER=-3;
-    public static final int STATE_HEADER_NAME=-2;
-    public static final int STATE_HEADER_VALUE=-1;
+    public static final int STATE_START=-13;
+    public static final int STATE_FIELD0=-12;
+    public static final int STATE_SPACE1=-11;
+    public static final int STATE_FIELD1=-10;
+    public static final int STATE_SPACE2=-9;
+    public static final int STATE_END0=-8;
+    public static final int STATE_END1=-7;
+    public static final int STATE_FIELD2=-6;
+    public static final int STATE_HEADER=-5;
+    public static final int STATE_HEADER_NAME=-4;
+    public static final int STATE_HEADER_IN_NAME=-3;
+    public static final int STATE_HEADER_VALUE=-2;
+    public static final int STATE_HEADER_IN_VALUE=-1;
     public static final int STATE_END=0;
     public static final int STATE_EOF_CONTENT=1;
     public static final int STATE_CONTENT=2;
@@ -120,6 +122,11 @@
     {
         return _contentLength;
     }
+    
+    public long getContentRead()
+    {
+        return _contentPosition;
+    }
 
     /* ------------------------------------------------------------------------------- */
     public int getState()
@@ -263,8 +270,10 @@
             }
                 
             if (_buffer.markIndex() == 0 && _buffer.putIndex() == _buffer.capacity())
-                    throw new IOException("FULL");
+                    throw new HttpException(HttpStatus.ORDINAL_413_Request_Entity_Too_Large, "FULL");
             
+            IOException ioex=null;
+            
             if (_endp != null && filled<=0)
             {
                 // Compress buffer if handling _content buffer
@@ -273,8 +282,7 @@
                     _buffer.compact();
 
                 if (_buffer.space() == 0) 
-                    throw new IOException("FULL "+(_buffer==_body?"body":"head"));
-                
+                    throw new HttpException(HttpStatus.ORDINAL_413_Request_Entity_Too_Large, "FULL "+(_buffer==_body?"body":"head"));                
                 try
                 {
                     if (total_filled<0)
@@ -286,8 +294,8 @@
                 catch(IOException e)
                 {
                     Log.debug(e);
-                    reset(true);
-                    throw (e instanceof EofException) ? e:new EofException(e);
+                    ioex=e;
+                    filled=-1;
                 }
             }
 
@@ -295,12 +303,20 @@
             {
                 if ( _state == STATE_EOF_CONTENT)
                 {
+                    if (_buffer.length()>0)
+                    {
+                        // TODO should we do this here or fall down to main loop?
+                        Buffer chunk=_buffer.get(_buffer.length());
+                        _contentPosition += chunk.length();
+                        _contentView.update(chunk);
+                        _handler.content(chunk); // May recurse here 
+                    }
                     _state=STATE_END;
                     _handler.messageComplete(_contentPosition);
                     return total_filled;
                 }
                 reset(true);
-                throw new EofException();
+                throw new EofException(ioex);
             }
             length=_buffer.length();
         }
@@ -320,6 +336,7 @@
                 continue;
             }
             _eol=0;
+            
             switch (_state)
             {
                 case STATE_START:
@@ -396,200 +413,294 @@
                 case STATE_FIELD2:
                     if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED)
                     {
-                        byte digit=_tok1.peek(_tok1.getIndex());
-                        if (digit>='1'&&digit<='5')
+                        // TODO - we really should know if we are parsing request or response!
+                        final Buffer method = HttpMethods.CACHE.lookup(_tok0);
+                        if (method==_tok0 && _tok1.length()==3 && Character.isDigit((char)_tok1.peek()))
                         {
 			    _responseStatus = BufferUtil.toInt(_tok1);
                             _handler.startResponse(HttpVersions.CACHE.lookup(_tok0), _responseStatus,_buffer.sliceFromMark());
                         } 
                         else
-                            _handler.startRequest(HttpMethods.CACHE.lookup(_tok0), _tok1,HttpVersions.CACHE.lookup(_buffer.sliceFromMark()));
+                            _handler.startRequest(method, _tok1,HttpVersions.CACHE.lookup(_buffer.sliceFromMark()));
                         _eol=ch;
                         _state=STATE_HEADER;
                         _tok0.setPutIndex(_tok0.getIndex());
                         _tok1.setPutIndex(_tok1.getIndex());
                         _multiLineValue=null;
-                        return total_filled;
+                        continue;
+                        // return total_filled;
                     }
                     break;
 
                 case STATE_HEADER:
-                    if (ch == HttpTokens.COLON || ch == HttpTokens.SPACE || ch == HttpTokens.TAB)
+                    switch(ch)
                     {
-                        // header value without name - continuation?
-                        _length=-1;
-                        _state=STATE_HEADER_VALUE;
-                    }
-                    else
-                    {
-                        // handler last header if any
-                        if (_cached!=null || _tok0.length() > 0 || _tok1.length() > 0 || _multiLineValue != null)
+                        case HttpTokens.COLON:
+                        case HttpTokens.SPACE:
+                        case HttpTokens.TAB:
                         {
-                            
-                            Buffer header=_cached!=null?_cached:HttpHeaders.CACHE.lookup(_tok0);
-                            _cached=null;
-                            Buffer value=_multiLineValue == null ? (Buffer) _tok1 : (Buffer) new ByteArrayBuffer(_multiLineValue);
-                            
-                            int ho=HttpHeaders.CACHE.getOrdinal(header);
-                            if (ho >= 0)
+                            // header value without name - continuation?
+                            _length=-1;
+                            _state=STATE_HEADER_VALUE;
+                            break;
+                        }
+                        
+                        default:
+                        {
+                            // handler last header if any
+                            if (_cached!=null || _tok0.length() > 0 || _tok1.length() > 0 || _multiLineValue != null)
                             {
-                                int vo=-1; 
                                 
-                                switch (ho)
+                                Buffer header=_cached!=null?_cached:HttpHeaders.CACHE.lookup(_tok0);
+                                _cached=null;
+                                Buffer value=_multiLineValue == null ? (Buffer) _tok1 : (Buffer) new ByteArrayBuffer(_multiLineValue);
+                                
+                                int ho=HttpHeaders.CACHE.getOrdinal(header);
+                                if (ho >= 0)
                                 {
-                                    case HttpHeaders.CONTENT_LENGTH_ORDINAL:
-                                        if (_contentLength != HttpTokens.CHUNKED_CONTENT)
-                                        {
-                                            _contentLength=BufferUtil.toLong(value);
-                                            if (_contentLength <= 0)
-                                                _contentLength=HttpTokens.NO_CONTENT;
-                                        }
-                                        break;
-                                        
-                                    case HttpHeaders.TRANSFER_ENCODING_ORDINAL:
-                                        value=HttpHeaderValues.CACHE.lookup(value);
-                                        vo=HttpHeaderValues.CACHE.getOrdinal(value);
-                                        if (HttpHeaderValues.CHUNKED_ORDINAL == vo)
-                                            _contentLength=HttpTokens.CHUNKED_CONTENT;
-                                        else
-                                        {
-                                            String c=value.toString();
-                                            if (c.endsWith(HttpHeaderValues.CHUNKED))
+                                    int vo=-1; 
+                                    
+                                    switch (ho)
+                                    {
+                                        case HttpHeaders.CONTENT_LENGTH_ORDINAL:
+                                            if (_contentLength != HttpTokens.CHUNKED_CONTENT)
+                                            {
+                                                try
+                                                {
+                                                    _contentLength=BufferUtil.toLong(value);
+                                                }
+                                                catch(NumberFormatException e)
+                                                {
+                                                    Log.ignore(e);
+                                                    throw new HttpException(HttpServletResponse.SC_BAD_REQUEST);
+                                                }
+                                                if (_contentLength <= 0)
+                                                    _contentLength=HttpTokens.NO_CONTENT;
+                                            }
+                                            break;
+                                            
+                                        case HttpHeaders.TRANSFER_ENCODING_ORDINAL:
+                                            value=HttpHeaderValues.CACHE.lookup(value);
+                                            vo=HttpHeaderValues.CACHE.getOrdinal(value);
+                                            if (HttpHeaderValues.CHUNKED_ORDINAL == vo)
                                                 _contentLength=HttpTokens.CHUNKED_CONTENT;
-                                            
-                                            else if (c.indexOf(HttpHeaderValues.CHUNKED) >= 0)
-                                                throw new HttpException(400,null);
-                                        }
-                                        break;
+                                            else
+                                            {
+                                                String c=value.toString();
+                                                if (c.endsWith(HttpHeaderValues.CHUNKED))
+                                                    _contentLength=HttpTokens.CHUNKED_CONTENT;
+                                                
+                                                else if (c.indexOf(HttpHeaderValues.CHUNKED) >= 0)
+                                                    throw new HttpException(400,null);
+                                            }
+                                            break;
+                                    }
                                 }
+                                
+                                _handler.parsedHeader(header, value);
+                                _tok0.setPutIndex(_tok0.getIndex());
+                                _tok1.setPutIndex(_tok1.getIndex());
+                                _multiLineValue=null;
                             }
                             
-                            _handler.parsedHeader(header, value);
-                            _tok0.setPutIndex(_tok0.getIndex());
-                            _tok1.setPutIndex(_tok1.getIndex());
-                            _multiLineValue=null;
-                        }
-                        
-                        
-                        // now handle ch
-                        if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED)
-                        {
-                            // End of header
+                            
+                            // now handle ch
+                            if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED)
+                            {
+                                // End of header
 
-                            // work out the _content demarcation
-                            if (_contentLength == HttpTokens.UNKNOWN_CONTENT)
-			    {
-			    	if (_responseStatus == 0  // request
-				|| _responseStatus == 304 // not-modified response
-				|| _responseStatus == 204 // no-content response
-				|| _responseStatus < 200) // 1xx response
-                                    _contentLength=HttpTokens.NO_CONTENT;
-				else
-                                    _contentLength=HttpTokens.EOF_CONTENT;
-			    }
+                                // work out the _content demarcation
+                                if (_contentLength == HttpTokens.UNKNOWN_CONTENT)
+                                {
+                                    if (_responseStatus == 0  // request
+                                    || _responseStatus == 304 // not-modified response
+                                    || _responseStatus == 204 // no-content response
+                                    || _responseStatus < 200) // 1xx response
+                                        _contentLength=HttpTokens.NO_CONTENT;
+                                    else
+                                        _contentLength=HttpTokens.EOF_CONTENT;
+                                }
 
-                            _contentPosition=0;
-                            _eol=ch;
-                            // We convert _contentLength to an int for this switch statement because
-                            // we don't care about the amount of data available just whether there is some.
-                            switch (_contentLength > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) _contentLength)
-                            {
-                                case HttpTokens.EOF_CONTENT:
-                                    _state=STATE_EOF_CONTENT;
-                                    if(_body==null && _buffers!=null)
-                                        _body=_buffers.getBuffer(_contentBufferSize);
-                                    
-                                    _handler.headerComplete(); // May recurse here !
-                                    break;
-                                    
-                                case HttpTokens.CHUNKED_CONTENT:
-                                    _state=STATE_CHUNKED_CONTENT;
-                                    if (_body==null && _buffers!=null)
-                                        _body=_buffers.getBuffer(_contentBufferSize);
-                                    _handler.headerComplete(); // May recurse here !
-                                    break;
-                                    
-                                case HttpTokens.NO_CONTENT:
-                                    _state=STATE_END;
-                                    _handler.headerComplete(); 
-                                    _handler.messageComplete(_contentPosition);
-                                    break;
-                                    
-                                default:
-                                    _state=STATE_CONTENT;
-                                    if(_forceContentBuffer || 
-                                      (_buffers!=null && _body==null && _buffer==_header && _contentLength>=(_header.capacity()-_header.getIndex())))
-                                        _body=_buffers.getBuffer(_contentBufferSize);
-                                    _handler.headerComplete(); // May recurse here !
-                                    break;
+                                _contentPosition=0;
+                                _eol=ch;
+                                // We convert _contentLength to an int for this switch statement because
+                                // we don't care about the amount of data available just whether there is some.
+                                switch (_contentLength > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) _contentLength)
+                                {
+                                    case HttpTokens.EOF_CONTENT:
+                                        _state=STATE_EOF_CONTENT;
+                                        if(_body==null && _buffers!=null)
+                                            _body=_buffers.getBuffer(_contentBufferSize);
+                                        
+                                        _handler.headerComplete(); // May recurse here !
+                                        break;
+                                        
+                                    case HttpTokens.CHUNKED_CONTENT:
+                                        _state=STATE_CHUNKED_CONTENT;
+                                        if (_body==null && _buffers!=null)
+                                            _body=_buffers.getBuffer(_contentBufferSize);
+                                        _handler.headerComplete(); // May recurse here !
+                                        break;
+                                        
+                                    case HttpTokens.NO_CONTENT:
+                                        _state=STATE_END;
+                                        _handler.headerComplete(); 
+                                        _handler.messageComplete(_contentPosition);
+                                        break;
+                                        
+                                    default:
+                                        _state=STATE_CONTENT;
+                                        if(_forceContentBuffer || 
+                                          (_buffers!=null && _body==null && _buffer==_header && _contentLength>=(_header.capacity()-_header.getIndex())))
+                                            _body=_buffers.getBuffer(_contentBufferSize);
+                                        _handler.headerComplete(); // May recurse here !
+                                        break;
+                                }
+                                return total_filled;
                             }
-                            return total_filled;
-                        }
-                        else
-                        {
-                            // New header
-                            _length=1;
-                            _buffer.mark();
-                            _state=STATE_HEADER_NAME;
-                            
-                            // try cached name!
-                            if (array!=null)
-                                _cached=HttpHeaders.CACHE.getBest(array, _buffer.markIndex(), length+1);
-                            if (_cached!=null)
+                            else
                             {
-                                _length=_cached.length();
-                                _buffer.setGetIndex(_buffer.markIndex()+_length);
-                                length=_buffer.length();
-                            }
+                                // New header
+                                _length=1;
+                                _buffer.mark();
+                                _state=STATE_HEADER_NAME;
+                                
+                                // try cached name!
+                                if (array!=null)
+                                {
+                                    _cached=HttpHeaders.CACHE.getBest(array, _buffer.markIndex(), length+1);
+
+                                    if (_cached!=null)
+                                    {
+                                        _length=_cached.length();
+                                        _buffer.setGetIndex(_buffer.markIndex()+_length);
+                                        length=_buffer.length();
+                                    }
+                                }
+                            } 
                         }
                     }
+                    
                     break;
 
                 case STATE_HEADER_NAME:
-                    if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED)
+                    switch(ch)
                     {
-                        if (_length > 0)
+                        case HttpTokens.CARRIAGE_RETURN:
+                        case HttpTokens.LINE_FEED:
+                            if (_length > 0)
                                 _tok0.update(_buffer.markIndex(), _buffer.markIndex() + _length);
-                        _eol=ch;
-                        _state=STATE_HEADER;
+                            _eol=ch;
+                            _state=STATE_HEADER;
+                            break;
+                        case HttpTokens.COLON:
+                            if (_length > 0 && _cached==null)
+                                _tok0.update(_buffer.markIndex(), _buffer.markIndex() + _length);
+                            _length=-1;
+                            _state=STATE_HEADER_VALUE;
+                            break;
+                        case HttpTokens.SPACE:
+                        case HttpTokens.TAB:
+                            break;
+                        default: 
+                        {
+                            _cached=null;
+                            if (_length == -1) 
+                                _buffer.mark();
+                            _length=_buffer.getIndex() - _buffer.markIndex();
+                            _state=STATE_HEADER_IN_NAME;  
+                        }
                     }
-                    else if (ch == HttpTokens.COLON)
+     
+                    break;
+
+                case STATE_HEADER_IN_NAME:
+                    switch(ch)
                     {
-                        if (_length > 0 && _cached==null)
+                        case HttpTokens.CARRIAGE_RETURN:
+                        case HttpTokens.LINE_FEED:
+                            if (_length > 0)
                                 _tok0.update(_buffer.markIndex(), _buffer.markIndex() + _length);
-                        _length=-1;
-                        _state=STATE_HEADER_VALUE;
+                            _eol=ch;
+                            _state=STATE_HEADER;
+                            break;
+                        case HttpTokens.COLON:
+                            if (_length > 0 && _cached==null)
+                                _tok0.update(_buffer.markIndex(), _buffer.markIndex() + _length);
+                            _length=-1;
+                            _state=STATE_HEADER_VALUE;
+                            break;
+                        case HttpTokens.SPACE:
+                        case HttpTokens.TAB:
+                            _state=STATE_HEADER_NAME;
+                            break;
+                        default:
+                        {
+                            _cached=null;
+                            _length++;
+                        }
                     }
-                    else if (ch != HttpTokens.SPACE && ch != HttpTokens.TAB)
-                    {
-                        // Drag the mark
-                        if (_length == -1) _buffer.mark();
-                        _length=_buffer.getIndex() - _buffer.markIndex();
-                    }
                     break;
 
                 case STATE_HEADER_VALUE:
-                    if (ch == HttpTokens.CARRIAGE_RETURN || ch == HttpTokens.LINE_FEED)
+                    switch(ch)
                     {
-                        if (_length > 0)
-                        {
-                            if (_tok1.length() == 0)
-                                _tok1.update(_buffer.markIndex(), _buffer.markIndex() + _length);
-                            else
+                        case HttpTokens.CARRIAGE_RETURN:
+                        case HttpTokens.LINE_FEED:
+                            if (_length > 0)
                             {
-                                // Continuation line!
-                                if (_multiLineValue == null) _multiLineValue=_tok1.toString();
-                                _tok1.update(_buffer.markIndex(), _buffer.markIndex() + _length);
-                                _multiLineValue += " " + _tok1.toString();
+                                if (_tok1.length() == 0)
+                                    _tok1.update(_buffer.markIndex(), _buffer.markIndex() + _length);
+                                else
+                                {
+                                    // Continuation line!
+                                    if (_multiLineValue == null) _multiLineValue=_tok1.toString();
+                                    _tok1.update(_buffer.markIndex(), _buffer.markIndex() + _length);
+                                    _multiLineValue += " " + _tok1.toString();
+                                }
                             }
-                        }
-                        _eol=ch;
-                        _state=STATE_HEADER;
+                            _eol=ch;
+                            _state=STATE_HEADER;
+                            break;
+                        case HttpTokens.SPACE:
+                        case HttpTokens.TAB:
+                            break;
+                        default:
+                        {
+                            if (_length == -1) 
+                                _buffer.mark();
+                            _length=_buffer.getIndex() - _buffer.markIndex();
+                            _state=STATE_HEADER_IN_VALUE;
+                        }       
                     }
-                    else if (ch != HttpTokens.SPACE && ch != HttpTokens.TAB)
+                    break;
+
+                case STATE_HEADER_IN_VALUE:
+                    switch(ch)
                     {
-                        if (_length == -1) _buffer.mark();
-                        _length=_buffer.getIndex() - _buffer.markIndex();
+                        case HttpTokens.CARRIAGE_RETURN:
+                        case HttpTokens.LINE_FEED:
+                            if (_length > 0)
+                            {
+                                if (_tok1.length() == 0)
+                                    _tok1.update(_buffer.markIndex(), _buffer.markIndex() + _length);
+                                else
+                                {
+                                    // Continuation line!
+                                    if (_multiLineValue == null) _multiLineValue=_tok1.toString();
+                                    _tok1.update(_buffer.markIndex(), _buffer.markIndex() + _length);
+                                    _multiLineValue += " " + _tok1.toString();
+                                }
+                            }
+                            _eol=ch;
+                            _state=STATE_HEADER;
+                            break;
+                        case HttpTokens.SPACE:
+                        case HttpTokens.TAB:
+                            _state=STATE_HEADER_VALUE;
+                            break;
+                        default:
+                            _length++;
                     }
                     break;
             }
@@ -643,6 +754,11 @@
                     _contentView.update(chunk);
                     _handler.content(chunk); // May recurse here 
                     
+                    if(_contentPosition == _contentLength)
+                    {
+                        _state=STATE_END;
+                        _handler.messageComplete(_contentPosition);
+                    }
                     // TODO adjust the _buffer to keep unconsumed content
                     return total_filled;
                 }
@@ -755,7 +871,7 @@
         
         // Fill buffer if we can
         if (space == 0) 
-            throw new IOException("FULL "+(_buffer==_body?"body":"head"));
+            throw new HttpException(HttpStatus.ORDINAL_413_Request_Entity_Too_Large, "FULL "+(_buffer==_body?"body":"head"));
         else
         {
             int filled=-1;
@@ -834,11 +950,16 @@
             {   
                 if (_body.hasContent())
                 {
+                    // There is content in the body after the end of the request.
+                    // This is probably a pipelined header of the next request, so we need to
+                    // copy it to the header buffer.
                     _header.setMarkIndex(-1);
                     _header.compact();
-                    // TODO if pipelined requests received after big input - maybe this is not good?.
-                    _body.skip(_header.put(_body));
-
+                    int take=_header.space();
+                    if (take>_body.length())
+                        take=_body.length();
+                    _body.peek(_body.getIndex(),take);
+                    _body.skip(_header.put(_body.peek(_body.getIndex(),take)));
                 }
 
                 if (_body.length()==0)
@@ -891,6 +1012,12 @@
         return "state=" + _state + " length=" + _length + " buf=" + buf.hashCode();
     }
 
+    /* ------------------------------------------------------------------------------- */
+    public String toString()
+    {
+        return "state=" + _state + " length=" + _length + " len=" + _contentLength;
+    }    
+    
     /* ------------------------------------------------------------ */
     public Buffer getHeaderBuffer()
     {
@@ -927,7 +1054,7 @@
         {
         }
 
-        public void messageComplete(long contextLength) throws IOException
+        public void messageComplete(long contentLength) throws IOException
         {
         }
 
@@ -1015,9 +1142,9 @@
                 try
                 {
                     _parser.parseNext();
-
+                    
                     // parse until some progress is made (or IOException thrown for timeout)
-                    while(_contentView.length() == 0 && !_parser.isState(HttpParser.STATE_END))
+                    while(_contentView.length() == 0 && !_parser.isState(HttpParser.STATE_END) && _endp.isOpen())
                     {
                         // Try to get more _parser._content
                         _parser.parseNext();
@@ -1034,8 +1161,11 @@
                 _parser.parseNext();
                 
                 // parse until some progress is made (or IOException thrown for timeout)
-                while(_contentView.length() == 0 && !_parser.isState(HttpParser.STATE_END))
+                while(_contentView.length() == 0 && !_parser.isState(HttpParser.STATE_END) && _endp.isOpen())
                 {
+                    if (_endp.isBufferingInput() && _parser.parseNext()>0)
+                        continue;
+                    
                     if (!_endp.blockReadable(_maxIdleTime))
                     {
                         _endp.close();
Index: modules/jetty/src/main/java/org/mortbay/jetty/handler/HandlerWrapper.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/handler/HandlerWrapper.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/handler/HandlerWrapper.java	(working copy)
@@ -107,6 +107,19 @@
             ((HandlerContainer)handler).addHandler(old);
     }
     
+    
+    public void removeHandler (Handler handler)
+    {
+        Handler old = getHandler();
+        if (old!=null && (old instanceof HandlerContainer))
+            ((HandlerContainer)old).removeHandler(handler);
+        else if (old!=null && handler.equals(old))
+            setHandler(null);
+        else
+            throw new IllegalStateException("Cannot remove");
+    }
+    
+    
     /* ------------------------------------------------------------ */
     /* 
      * @see org.mortbay.thread.AbstractLifeCycle#doStart()
Index: modules/jetty/src/main/java/org/mortbay/jetty/handler/RewriteHandler.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/handler/RewriteHandler.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/handler/RewriteHandler.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty.handler;
 
 import java.io.IOException;
Index: modules/jetty/src/main/java/org/mortbay/jetty/handler/ContextHandler.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/handler/ContextHandler.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/handler/ContextHandler.java	(working copy)
@@ -69,12 +69,12 @@
  * This handler wraps a call to handle by setting the context and
  * servlet path, plus setting the context classloader.
  * 
- * Note. Because of http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4425695
- * directly replacing war or jar files in a context is not supported.
- * You should use classes instead of jars if they will change, or deploy
- * a packed war file that gets extracted on deployment.
+ * <p>
+ * If the context init parameter "org.mortbay.jetty.servlet.ManagedAttributes"
+ * is set to a coma separated list of names, then they are treated as context
+ * attribute names, which if set as attributes are passed to the servers Container
+ * so that they may be managed with JMX.
  * 
- * 
  * @org.apache.xbean.XBean description="Creates a basic HTTP context"
  *
  * @author gregw
@@ -83,6 +83,7 @@
 public class ContextHandler extends HandlerWrapper implements Attributes, Server.Graceful
 {
     private static ThreadLocal __context=new ThreadLocal();
+    public static final String MANAGED_ATTRIBUTES = "org.mortbay.jetty.servlet.ManagedAttributes";
     
     /* ------------------------------------------------------------ */
     /** Get the current ServletContext implementation.
@@ -99,13 +100,12 @@
 
     protected SContext _scontext;
     
-    private Attributes _attributes;
-    private Attributes _contextAttributes;
+    private AttributesMap _attributes;
+    private AttributesMap _contextAttributes;
     private ClassLoader _classLoader;
-    private String _contextPath;
+    private String _contextPath="/";
     private Map _initParams;
     private String _displayName;
-    private String _docRoot;
     private Resource _baseResource;  
     private MimeTypes _mimeTypes;
     private Map _localeEncodingMap;
@@ -124,6 +124,7 @@
     private Object _contextAttributeListeners;
     private Object _requestListeners;
     private Object _requestAttributeListeners;
+    private Set _managedAttributes;
     
     /* ------------------------------------------------------------ */
     /**
@@ -209,7 +210,6 @@
         }
         else
             super.setServer(server); 
-        
     }
 
     /* ------------------------------------------------------------ */
@@ -221,11 +221,21 @@
      * matching virtual host name.
      * @param vhosts Array of virtual hosts that this context responds to. A
      * null host name or null/empty array means any hostname is acceptable.
-     * Host names may String representation of IP addresses.
+     * Host names may be String representation of IP addresses. Host names may
+     * start with '*.' to wildcard one level of names.
      */
-    public void setVirtualHosts(String[] vhosts)
+    public void setVirtualHosts( String[] vhosts )
     {
-        _vhosts=vhosts;
+        if ( vhosts == null )
+        {
+            _vhosts = vhosts;
+        } 
+        else 
+        {
+            _vhosts = new String[vhosts.length];
+            for ( int i = 0; i < vhosts.length; i++ )
+                _vhosts[i] = normalizeHostname( vhosts[i]);
+        }
     }
 
     /* ------------------------------------------------------------ */
@@ -238,6 +248,7 @@
      * @return Array of virtual hosts that this context responds to. A
      * null host name or empty array means any hostname is acceptable.
      * Host names may be String representation of IP addresses.
+     * Host names may start with '*.' to wildcard one level of names.
      */
     public String[] getVirtualHosts()
     {
@@ -473,13 +484,18 @@
      */
     protected void doStart() throws Exception
     {
+        if (_contextPath==null)
+            throw new IllegalStateException("Null contextPath");
+        
         _logger=Log.getLogger(getDisplayName()==null?getContextPath():getDisplayName());
         ClassLoader old_classloader=null;
         Thread current_thread=null;
-        Object old_context=null;
+        SContext old_context=null;
+
         _contextAttributes=new AttributesMap();
         try
         {
+            
             // Set the classloader
             if (_classLoader!=null)
             {
@@ -492,7 +508,7 @@
             if (_mimeTypes==null)
                 _mimeTypes=new MimeTypes();
             
-            old_context=__context.get();
+            old_context=(SContext)__context.get();
             __context.set(_scontext);
             
             if (_errorHandler==null)
@@ -500,6 +516,7 @@
             
             startContext();
             
+           
         }
         finally
         {
@@ -531,6 +548,23 @@
                 ((ServletContextListener)LazyList.get(_contextListeners, i)).contextInitialized(event);
             }
         }
+
+        String managedAttributes = (String)_initParams.get(MANAGED_ATTRIBUTES);
+        if (managedAttributes!=null)
+        {
+            _managedAttributes=new HashSet();
+            String[] attributes = managedAttributes.toString().split(",");
+	    for (int  i=0;i<attributes.length;i++)
+                _managedAttributes.add(attributes[i]);
+
+            Enumeration e = _scontext.getAttributeNames();
+            while(e.hasMoreElements())
+            {
+                String name = (String)e.nextElement();
+                Object value = _scontext.getAttribute(name);
+                setManagedAttribute(name,value);
+            }
+        }       
     }
     
     /* ------------------------------------------------------------ */
@@ -542,7 +576,7 @@
         ClassLoader old_classloader=null;
         Thread current_thread=null;
 
-        Object old_context=__context.get();
+        SContext old_context=(SContext)__context.get();
         __context.set(_scontext);
         try
         {
@@ -568,6 +602,13 @@
 
             if (_errorHandler!=null)
                 _errorHandler.stop();
+            
+            Enumeration e = _scontext.getAttributeNames();
+            while(e.hasMoreElements())
+            {
+                String name = (String)e.nextElement();
+                setManagedAttribute(name,null);
+            }
         }
         finally
         {
@@ -611,12 +652,21 @@
             // Check the vhosts
             if (_vhosts!=null && _vhosts.length>0)
             {
-                String vhost=request.getServerName();
+                String vhost = normalizeHostname( request.getServerName());
+
                 boolean match=false;
                 
                 // TODO non-linear lookup
                 for (int i=0;!match && i<_vhosts.length;i++)
-                    match=_vhosts[i]!=null && _vhosts[i].equalsIgnoreCase(vhost);
+                {
+                    String contextVhost = _vhosts[i];
+                    if(contextVhost==null) continue;
+                    if(contextVhost.startsWith("*.")) {
+                        // wildcard only at the beginning, and only for one additional subdomain level
+                        match=contextVhost.regionMatches(true,2,vhost,vhost.indexOf(".")+1,contextVhost.length()-2);
+                    } else
+                        match=contextVhost.equalsIgnoreCase(vhost);
+                }
                 if (!match)
                     return;
             }
@@ -695,14 +745,13 @@
                 }
                 
                 // Handle the REALLY SILLY request events!
-                if (_requestListeners!=null)
+                base_request.setRequestListeners(_requestListeners);
+                if (_requestAttributeListeners!=null)
                 {
-                    event = new ServletRequestEvent(_scontext,request);
-                    for(int i=0;i<LazyList.size(_requestListeners);i++)
-                        ((ServletRequestListener)LazyList.get(_requestListeners,i)).requestInitialized(event);
+                    final int s=LazyList.size(_requestAttributeListeners);
+                    for(int i=0;i<s;i++)
+                        base_request.addEventListener(((EventListener)LazyList.get(_requestAttributeListeners,i)));
                 }
-                for(int i=0;i<LazyList.size(_requestAttributeListeners);i++)
-                    base_request.addEventListener(((EventListener)LazyList.get(_requestAttributeListeners,i)));
             }
             
             // Handle the request
@@ -725,11 +774,12 @@
                 // Handle more REALLY SILLY request events!
                 if (new_context)
                 {
-                    for(int i=LazyList.size(_requestListeners);i-->0;)
-                        ((ServletRequestListener)LazyList.get(_requestListeners,i)).requestDestroyed(event);
-                    
-                    for(int i=0;i<LazyList.size(_requestAttributeListeners);i++)
-                        base_request.removeEventListener(((EventListener)LazyList.get(_requestAttributeListeners,i)));
+                    base_request.takeRequestListeners();
+                    if (_requestAttributeListeners!=null)
+                    {
+                        for(int i=LazyList.size(_requestAttributeListeners);i-->0;)
+                            base_request.removeEventListener(((EventListener)LazyList.get(_requestAttributeListeners,i)));
+                    }
                 }
             }
         }
@@ -771,6 +821,7 @@
      */
     public void removeAttribute(String name)
     {
+        setManagedAttribute(name,null);
         _attributes.removeAttribute(name);
     }
 
@@ -783,6 +834,7 @@
      */
     public void setAttribute(String name, Object value)
     {
+        setManagedAttribute(name,value);
         _attributes.setAttribute(name,value);
     }
     
@@ -792,14 +844,54 @@
      */
     public void setAttributes(Attributes attributes)
     {
-        _attributes = attributes;
+        if (attributes instanceof AttributesMap)
+        {
+            _attributes = (AttributesMap)attributes;
+            Enumeration e = _attributes.getAttributeNames();
+            while (e.hasMoreElements())
+            {
+                String name = (String)e.nextElement();
+                setManagedAttribute(name,attributes.getAttribute(name));
+            }
+        }
+        else
+        {
+            _attributes=new AttributesMap();
+            Enumeration e = attributes.getAttributeNames();
+            while (e.hasMoreElements())
+            {
+                String name = (String)e.nextElement();
+                Object value=attributes.getAttribute(name);
+                setManagedAttribute(name,value);
+                _attributes.setAttribute(name,value);
+            }
+        }
     }
 
     /* ------------------------------------------------------------ */
     public void clearAttributes()
     {
+        Enumeration e = _attributes.getAttributeNames();
+        while (e.hasMoreElements())
+        {
+            String name = (String)e.nextElement();
+            setManagedAttribute(name,null);
+        }
         _attributes.clearAttributes();
     }
+
+    /* ------------------------------------------------------------ */
+    private void setManagedAttribute(String name, Object value)
+    {   
+        if (_managedAttributes!=null && _managedAttributes.contains(name))
+        {
+            Object o =_scontext.getAttribute(name);
+            if (o!=null)
+                getServer().getContainer().removeBean(o);
+            if (value!=null)
+                getServer().getContainer().addBean(value);
+        }
+    }
     
     /* ------------------------------------------------------------ */
     /**
@@ -879,23 +971,6 @@
     public void setBaseResource(Resource base) 
     {
         _baseResource=base;
-        _docRoot=null;
-        
-        try
-        {
-            File file=_baseResource.getFile();
-            if (file!=null)
-            {
-                _docRoot=file.getCanonicalPath();
-                if (_docRoot.endsWith(File.pathSeparator))
-                    _docRoot=_docRoot.substring(0,_docRoot.length()-1);
-            }
-        }
-        catch (Exception e)
-        {
-            Log.warn(e);
-            throw new IllegalArgumentException(base.toString());
-        }
     }
 
     /* ------------------------------------------------------------ */
@@ -910,7 +985,8 @@
         }
         catch (Exception e)
         {
-            Log.warn(e);
+            Log.warn(e.toString());
+            Log.debug(e);
             throw new IllegalArgumentException(resourceBase);
         }
     }
@@ -1210,19 +1286,29 @@
          */
         public String getRealPath(String path)
         {
-            if (_docRoot==null)
+            if(path==null)
                 return null;
+            if(path.length()==0)
+                path = URIUtil.SLASH;
+            else if(path.charAt(0)!='/')
+                path = URIUtil.SLASH + path;
+                
+            try
+            {
+                Resource resource=ContextHandler.this.getResource(path);
+                if(resource!=null)
+                {
+                    File file = resource.getFile();
+                    if (file!=null)
+                        return file.getCanonicalPath();
+                }
+            }
+            catch (Exception e)
+            {
+                Log.ignore(e);
+            }
             
-            if (path==null)
-                return null;
-            path=URIUtil.canonicalPath(path);
-            
-            if (!path.startsWith(URIUtil.SLASH))
-                path=URIUtil.SLASH+path;
-            if (File.separatorChar!='/')
-                path =path.replace('/', File.separatorChar);
-            
-            return _docRoot+path;
+            return null;
         }
 
         /* ------------------------------------------------------------ */
@@ -1280,7 +1366,7 @@
          */
         public String getServerInfo()
         {
-            return "jetty-"+getServer().getVersion();
+            return "jetty/"+Server.getVersion();
         }
 
         /* ------------------------------------------------------------ */
@@ -1362,7 +1448,7 @@
         public synchronized Object getAttribute(String name)
         {
             Object o = ContextHandler.this.getAttribute(name);
-            if (o==null)
+            if (o==null && _contextAttributes!=null)
                 o=_contextAttributes.getAttribute(name);
             return o;
         }
@@ -1374,12 +1460,15 @@
         public synchronized Enumeration getAttributeNames()
         {
             HashSet set = new HashSet();
-            Enumeration e = _contextAttributes.getAttributeNames();
+            if (_contextAttributes!=null)
+            {
+            	Enumeration e = _contextAttributes.getAttributeNames();
+            	while(e.hasMoreElements())
+            		set.add(e.nextElement());
+            }
+            Enumeration e = _attributes.getAttributeNames();
             while(e.hasMoreElements())
                 set.add(e.nextElement());
-            e = ContextHandler.this.getAttributeNames();
-            while(e.hasMoreElements())
-                set.add(e.nextElement());
             
             return Collections.enumeration(set);
         }
@@ -1390,9 +1479,15 @@
          */
         public synchronized void setAttribute(String name, Object value)
         {
+            
             if (_contextAttributes==null)
+            {
+            	// Set it on the handler
+            	ContextHandler.this.setAttribute(name, value);
                 return;
-            
+            }
+
+            setManagedAttribute(name,value);
             Object old_value=_contextAttributes==null?null:_contextAttributes.getAttribute(name);
             
             if (value==null)
@@ -1425,6 +1520,15 @@
          */
         public synchronized void removeAttribute(String name)
         {
+            setManagedAttribute(name,null);
+            
+            if (_contextAttributes==null)
+            {
+            	// Set it on the handler
+            	_attributes.removeAttribute(name);
+                return;
+            }
+            
             Object old_value=_contextAttributes.getAttribute(name);
             _contextAttributes.removeAttribute(name);
             if (old_value!=null)
@@ -1464,15 +1568,23 @@
             return _contextPath;
         }
 
-
         /* ------------------------------------------------------------ */
         public String toString()
         {
             return "ServletContext@"+Integer.toHexString(hashCode())+"{"+(getContextPath().equals("")?URIUtil.SLASH:getContextPath())+","+getBaseResource()+"}";
         }
+    }
 
+    /* ------------------------------------------------------------ */
+    private String normalizeHostname( String host )
+    {
+        if ( host == null )
+            return null;
+        
+        if ( host.endsWith( "." ) )
+            return host.substring( 0, host.length() -1);
+      
+            return host;
     }
 
-
-
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/handler/ResourceHandler.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/handler/ResourceHandler.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/handler/ResourceHandler.java	(working copy)
@@ -34,7 +34,9 @@
 import org.mortbay.jetty.Response;
 import org.mortbay.jetty.handler.ContextHandler.SContext;
 import org.mortbay.log.Log;
+import org.mortbay.resource.FileResource;
 import org.mortbay.resource.Resource;
+import org.mortbay.util.StringUtil;
 import org.mortbay.util.TypeUtil;
 import org.mortbay.util.URIUtil;
 
@@ -56,18 +58,55 @@
     String[] _welcomeFiles={"index.html"};
     MimeTypes _mimeTypes = new MimeTypes();
     ByteArrayBuffer _cacheControl;
+    boolean _aliases;
 
     /* ------------------------------------------------------------ */
     public ResourceHandler()
     {
     }
-    
+
     /* ------------------------------------------------------------ */
+    public MimeTypes getMimeTypes()
+    {
+        return _mimeTypes;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setMimeTypes(MimeTypes mimeTypes)
+    {
+        _mimeTypes = mimeTypes;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * @return True if resource aliases are allowed.
+     */
+    public boolean isAliases()
+    {
+        return _aliases;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * Set if resource aliases (eg symlink, 8.3 names, case insensitivity) are allowed.
+     * Allowing aliases can significantly increase security vulnerabilities.
+     * @param aliases True if aliases are supported.
+     */
+    public void setAliases(boolean aliases)
+    {
+        _aliases = aliases;
+    }
+
+    /* ------------------------------------------------------------ */
     public void doStart()
     throws Exception
     {
         SContext scontext = ContextHandler.getCurrentContext();
         _context = (scontext==null?null:scontext.getContextHandler());
+        
+        if (!_aliases && !FileResource.getCheckAliases())
+            throw new IllegalStateException("Alias checking disabled");
+        
         super.doStart();
     }
 
@@ -115,7 +154,8 @@
         }
         catch (Exception e)
         {
-            Log.warn(e);
+            Log.warn(e.toString());
+            Log.debug(e);
             throw new IllegalArgumentException(resourceBase);
         }
     }
@@ -212,13 +252,26 @@
     public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch) throws IOException, ServletException
     {
         Request base_request = request instanceof Request?(Request)request:HttpConnection.getCurrentConnection().getRequest();
-        if (base_request.isHandled() || !request.getMethod().equals(HttpMethods.GET))
+        if (base_request.isHandled())
             return;
+        
+        boolean skipContentBody = false;
+        if(!HttpMethods.GET.equals(request.getMethod()))
+        {
+            if(!HttpMethods.HEAD.equals(request.getMethod()))
+                return;
+            skipContentBody = true;
+        }
      
         Resource resource=getResource(request);
         
         if (resource==null || !resource.exists())
             return;
+        if (!_aliases && resource.getAlias()!=null)
+        {
+            Log.info(resource+" aliased to "+resource.getAlias());
+            return;
+        }
 
         // We are going to server something
         base_request.setHandled(true);
@@ -257,7 +310,9 @@
         
         // set the headers
         doResponseHeaders(response,resource,mime!=null?mime.toString():null);
-
+        response.setDateHeader(HttpHeaders.LAST_MODIFIED,last_modified);
+        if(skipContentBody)
+            return;
         // Send the content
         OutputStream out =null;
         try {out = response.getOutputStream();}
@@ -267,13 +322,11 @@
         if (out instanceof HttpConnection.Output)
         {
             // TODO file mapped buffers
-            response.setDateHeader(HttpHeaders.LAST_MODIFIED,last_modified);
             ((HttpConnection.Output)out).sendContent(resource.getInputStream());
         }
         else
         {
             // Write content normally
-            response.setDateHeader(HttpHeaders.LAST_MODIFIED,last_modified);
             resource.writeTo(out,0,resource.length());
         }
     }
Index: modules/jetty/src/main/java/org/mortbay/jetty/handler/ErrorHandler.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/handler/ErrorHandler.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/handler/ErrorHandler.java	(working copy)
@@ -16,7 +16,6 @@
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.io.Writer;
-import java.net.URLDecoder;
 
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -24,6 +23,7 @@
 import org.mortbay.jetty.HttpConnection;
 import org.mortbay.jetty.HttpGenerator;
 import org.mortbay.jetty.HttpHeaders;
+import org.mortbay.jetty.HttpMethods;
 import org.mortbay.jetty.MimeTypes;
 import org.mortbay.util.ByteArrayISO8859Writer;
 import org.mortbay.util.StringUtil;
@@ -47,10 +47,14 @@
      */
     public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch) throws IOException
     {
-        HttpConnection.getCurrentConnection().getRequest().setHandled(true);
-        response.setContentType(MimeTypes.TEXT_HTML_8859_1);
+        HttpConnection connection = HttpConnection.getCurrentConnection();
+        connection.getRequest().setHandled(true);
+        String method = request.getMethod();
+        if(!method.equals(HttpMethods.GET) && !method.equals(HttpMethods.POST) && !method.equals(HttpMethods.HEAD))
+            return;
+        response.setContentType(MimeTypes.TEXT_HTML_8859_1);        
+        response.setHeader(HttpHeaders.CACHE_CONTROL, "must-revalidate,no-cache,no-store");
         ByteArrayISO8859Writer writer= new ByteArrayISO8859Writer(4096);
-        HttpConnection connection = HttpConnection.getCurrentConnection();
         handleErrorPage(request, writer, connection.getResponse().getStatus(), connection.getResponse().getReason());
         writer.flush();
         response.setContentLength(writer.size());
@@ -87,8 +91,7 @@
         writer.write("<title>Error ");
         writer.write(Integer.toString(code));
         writer.write(' ');
-        if (message==null)
-            writer.write(deScript(message));
+        write(writer,message);
         writer.write("</title>\n");    
     }
 
@@ -101,8 +104,7 @@
         writeErrorPageMessage(request,writer,code,message,uri);
         if (showStacks)
             writeErrorPageStacks(request,writer);
-
-        writer.write("<p><i><small><a href=\"http://jetty.mortbay.org/\">Powered by Jetty://</a></small></i></p>");
+        writer.write("<hr /><i><small>Powered by Jetty://</small></i>");
         for (int i= 0; i < 20; i++)
             writer.write("<br/>                                                \n");
     }
@@ -111,13 +113,13 @@
     protected void writeErrorPageMessage(HttpServletRequest request, Writer writer, int code, String message,String uri)
     throws IOException
     {
-        writer.write("<h2>HTTP ERROR: ");
+        writer.write("<h2>HTTP ERROR ");
         writer.write(Integer.toString(code));
-        writer.write("</h2><pre>");
-        writer.write(deScript(message));
-        writer.write("</pre>\n<p>RequestURI=");
-        writer.write(deScript(uri));
-        writer.write("</p>");
+        writer.write("</h2>\n<p>Problem accessing ");
+        write(writer,uri);
+        writer.write(". Reason:\n<pre>    ");
+        write(writer,message);
+        writer.write("</pre></p>");
     }
 
     /* ------------------------------------------------------------ */
@@ -132,7 +134,7 @@
             PrintWriter pw = new PrintWriter(sw);
             th.printStackTrace(pw);
             pw.flush();
-            writer.write(deScript(sw.getBuffer().toString()));
+            write(writer,sw.getBuffer().toString());
             writer.write("</pre>\n");
 
             th =th.getCause();
@@ -159,13 +161,34 @@
     }
 
     /* ------------------------------------------------------------ */
-    protected String deScript(String string)
+    protected void write(Writer writer,String string)
+        throws IOException
     {
         if (string==null)
-            return null;
-        string=StringUtil.replace(string, "&", "&amp;");
-        string=StringUtil.replace(string, "<", "&lt;");
-        string=StringUtil.replace(string, ">", "&gt;");
-        return string;
+            return;
+        
+        for (int i=0;i<string.length();i++)
+        {
+            char c=string.charAt(i);
+            
+            switch(c)
+            {
+                case '&' :
+                    writer.write("&amp;");
+                    break;
+                case '<' :
+                    writer.write("&lt;");
+                    break;
+                case '>' :
+                    writer.write("&gt;");
+                    break;
+                    
+                default:
+                    if (Character.isISOControl(c) && !Character.isWhitespace(c))
+                        writer.write('?');
+                    else 
+                        writer.write(c);
+            }          
+        }
     }
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/handler/StatisticsHandler.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/handler/StatisticsHandler.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/handler/StatisticsHandler.java	(working copy)
@@ -1,248 +1,217 @@
-//========================================================================
-//Copyright 2006 Mort Bay Consulting Pty. Ltd.
-//------------------------------------------------------------------------
-//Licensed under the Apache License, Version 2.0 (the "License");
-//you may not use this file except in compliance with the License.
-//You may obtain a copy of the License at 
-//http://www.apache.org/licenses/LICENSE-2.0
-//Unless required by applicable law or agreed to in writing, software
-//distributed under the License is distributed on an "AS IS" BASIS,
-//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//See the License for the specific language governing permissions and
-//limitations under the License.
-//========================================================================
+// ========================================================================
+// Copyright 2009-2009 Mort Bay Consulting Pty. Ltd.
+// ------------------------------------------------------------------------
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// http://www.apache.org/licenses/LICENSE-2.0
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+// ========================================================================
 
 package org.mortbay.jetty.handler;
 
 import java.io.IOException;
-
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
 import org.mortbay.jetty.HttpConnection;
-import org.mortbay.jetty.Request;
 import org.mortbay.jetty.Response;
 
-public class StatisticsHandler extends HandlerWrapper
+public class StatisticsHandler extends AbstractStatisticsHandler
 {
-    transient long _statsStartedAt;
-    
-    transient int _requests;
-    
-    transient long _requestsDurationMin;         // min request duration
-    transient long _requestsDurationMax;         // max request duration
-    transient long _requestsDurationTotal;       // total request duration
-    
-    transient int _requestsActive;
-    transient int _requestsActiveMin;            // min number of connections handled simultaneously
-    transient int _requestsActiveMax;
-    transient int _responses1xx; // Informal
-    transient int _responses2xx; // Success
-    transient int _responses3xx; // Redirection
-    transient int _responses4xx; // Client Error
-    transient int _responses5xx; // Server Error
-    
+    private transient long _statsStartedAt;
+    private transient int _requests;
+    private transient long _minRequestTime;
+    private transient long _maxRequestTime;
+    private transient long _totalRequestTime;
+    private transient int _requestsActive;
+    private transient int _requestsActiveMax;
+    private transient int _responses1xx; // Informal
+    private transient int _responses2xx; // Success
+    private transient int _responses3xx; // Redirection
+    private transient int _responses4xx; // Client Error
+    private transient int _responses5xx; // Server Error
 
-    /* ------------------------------------------------------------ */
-    public void statsReset()
+    public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch) throws IOException, ServletException
     {
-        synchronized(this)
+        synchronized (this)
         {
-            if (isStarted())
-                _statsStartedAt=System.currentTimeMillis();
-            _requests=0;
-            _requestsActiveMax=_requestsActive;
-            _responses1xx=0;
-            _responses2xx=0;
-            _responses3xx=0;
-            _responses4xx=0;
-            _responses5xx=0;
-          
-            _requestsActiveMin=_requestsActive;
-            _requestsActiveMax=_requestsActive;
-            _requestsActive=0;
-
-            _requestsDurationMin=0;
-            _requestsDurationMax=0;
-            _requestsDurationTotal=0;
+            ++_requests;
+            ++_requestsActive;
+            if (_requestsActive > _requestsActiveMax)
+                _requestsActiveMax = _requestsActive;
         }
-    }
 
-
-    /* ------------------------------------------------------------ */
-    public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch) throws IOException, ServletException
-    {
-        final Request base_request=(request instanceof Request)?((Request)request):HttpConnection.getCurrentConnection().getRequest();
-        final Response base_response=(response instanceof Response)?((Response)response):HttpConnection.getCurrentConnection().getResponse();
-        
+        long requestStartTime = System.currentTimeMillis();
         try
         {
-            synchronized(this)
-            {
-                _requests++;
-                _requestsActive++;
-                if (_requestsActive>_requestsActiveMax)
-                    _requestsActiveMax=_requestsActive;
-            }
-            
             super.handle(target, request, response, dispatch);
         }
         finally
         {
-            synchronized(this)
+            long requestTime = System.currentTimeMillis() - requestStartTime;
+
+            synchronized (this)
             {
                 _requestsActive--;
-                if (_requestsActive<0)
-                    _requestsActive=0;
-                if (_requestsActive < _requestsActiveMin)
-                    _requestsActiveMin=_requestsActive;
-                
-                long duration = System.currentTimeMillis()-base_request.getTimeStamp();
-                
-                _requestsDurationTotal+=duration;
-                if (_requestsDurationMin==0 || duration<_requestsDurationMin)
-                    _requestsDurationMin=duration;
-                if (duration>_requestsDurationMax)
-                    _requestsDurationMax=duration;
-                
-                switch(base_response.getStatus()/100)
+                if (_requestsActive < 0) _requestsActive = 0;
+
+                _totalRequestTime += requestTime;
+                if (requestTime < _minRequestTime || _minRequestTime == 0)
+                    _minRequestTime = requestTime;
+                if (requestTime > _maxRequestTime)
+                    _maxRequestTime = requestTime;
+
+                Response jettyResponse = (response instanceof Response) ? (Response) response : HttpConnection.getCurrentConnection().getResponse();
+                switch (jettyResponse.getStatus() / 100)
                 {
-                    case 1: _responses1xx++;break;
-                    case 2: _responses2xx++;break;
-                    case 3: _responses3xx++;break;
-                    case 4: _responses4xx++;break;
-                    case 5: _responses5xx++;break;
+                    case 1:
+                        _responses1xx++;
+                        break;
+                    case 2:
+                        _responses2xx++;
+                        break;
+                    case 3:
+                        _responses3xx++;
+                        break;
+                    case 4:
+                        _responses4xx++;
+                        break;
+                    case 5:
+                        _responses5xx++;
+                        break;
+                    default:
+                        break;
                 }
-                
             }
         }
     }
 
-    /* ------------------------------------------------------------ */
-    protected void doStart() throws Exception
+    public void statsReset()
     {
-        super.doStart();
-        _statsStartedAt=System.currentTimeMillis();
+        synchronized (this)
+        {
+            _statsStartedAt = System.currentTimeMillis();
+            _requests = 0;
+            _minRequestTime = 0;
+            _maxRequestTime = 0;
+            _totalRequestTime = 0;
+            _requestsActiveMax = _requestsActive;
+            _requestsActive = 0;
+            _responses1xx = 0;
+            _responses2xx = 0;
+            _responses3xx = 0;
+            _responses4xx = 0;
+            _responses5xx = 0;
+        }
     }
 
-    /* ------------------------------------------------------------ */
-    protected void doStop() throws Exception
+    public int getRequests()
     {
-        super.doStop();
+        synchronized (this)
+        {
+            return _requests;
+        }
     }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Get the number of requests handled by this context
-     * since last call of statsReset(). If setStatsOn(false) then this
-     * is undefined.
-     */
-    public int getRequests() {return _requests;}
+    public int getRequestsActive()
+    {
+        synchronized (this)
+        {
+            return _requestsActive;
+        }
+    }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Number of requests currently active.
-     * Undefined if setStatsOn(false).
-     */
-    public int getRequestsActive() {return _requestsActive;}
+    public int getRequestsActiveMax()
+    {
+        synchronized (this)
+        {
+            return _requestsActiveMax;
+        }
+    }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Maximum number of active requests
-     * since statsReset() called. Undefined if setStatsOn(false).
-     */
-    public int getRequestsActiveMax() {return _requestsActiveMax;}
+    public int getResponses1xx()
+    {
+        synchronized (this)
+        {
+            return _responses1xx;
+        }
+    }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Get the number of responses with a 2xx status returned
-     * by this context since last call of statsReset(). Undefined if
-     * if setStatsOn(false).
-     */
-    public int getResponses1xx() {return _responses1xx;}
+    public int getResponses2xx()
+    {
+        synchronized (this)
+        {
+            return _responses2xx;
+        }
+    }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Get the number of responses with a 100 status returned
-     * by this context since last call of statsReset(). Undefined if
-     * if setStatsOn(false).
-     */
-    public int getResponses2xx() {return _responses2xx;}
+    public int getResponses3xx()
+    {
+        synchronized (this)
+        {
+            return _responses3xx;
+        }
+    }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Get the number of responses with a 3xx status returned
-     * by this context since last call of statsReset(). Undefined if
-     * if setStatsOn(false).
-     */
-    public int getResponses3xx() {return _responses3xx;}
+    public int getResponses4xx()
+    {
+        synchronized (this)
+        {
+            return _responses4xx;
+        }
+    }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Get the number of responses with a 4xx status returned
-     * by this context since last call of statsReset(). Undefined if
-     * if setStatsOn(false).
-     */
-    public int getResponses4xx() {return _responses4xx;}
+    public int getResponses5xx()
+    {
+        synchronized (this)
+        {
+            return _responses5xx;
+        }
+    }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Get the number of responses with a 5xx status returned
-     * by this context since last call of statsReset(). Undefined if
-     * if setStatsOn(false).
-     */
-    public int getResponses5xx() {return _responses5xx;}
-
-    /* ------------------------------------------------------------ */
-    /** 
-     * @return Timestamp stats were started at.
-     */
     public long getStatsOnMs()
     {
-        return System.currentTimeMillis()-_statsStartedAt;
+        synchronized (this)
+        {
+            return System.currentTimeMillis() - _statsStartedAt;
+        }
     }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Returns the requestsActiveMin.
-     */
-    public int getRequestsActiveMin()
+    public long getRequestTimeMin()
     {
-        return _requestsActiveMin;
+        synchronized (this)
+        {
+            return _minRequestTime;
+        }
     }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Returns the requestsDurationMin.
-     */
-    public long getRequestsDurationMin()
+    public long getRequestTimeMax()
     {
-        return _requestsDurationMin;
+        synchronized (this)
+        {
+            return _maxRequestTime;
+        }
     }
 
-    /* ------------------------------------------------------------ */
-    /**
-     * @return Returns the requestsDurationTotal.
-     */
-    public long getRequestsDurationTotal()
+    public long getRequestTimeTotal()
     {
-        return _requestsDurationTotal;
+        synchronized (this)
+        {
+            return _totalRequestTime;
+        }
     }
 
-    /* ------------------------------------------------------------ */
-    /** 
-     * @return Average duration of request handling in milliseconds 
-     * since statsReset() called. Undefined if setStatsOn(false).
-     */
-    public long getRequestsDurationAve() {return _requests==0?0:(_requestsDurationTotal/_requests);}
-
-    /* ------------------------------------------------------------ */
-    /** 
-     * @return Get maximum duration in milliseconds of request handling
-     * since statsReset() called. Undefined if setStatsOn(false).
-     */
-    public long getRequestsDurationMax() {return _requestsDurationMax;}
-    
-
+    public long getRequestTimeAverage()
+    {
+        synchronized (this)
+        {
+            return _requests == 0 ? 0 : (_totalRequestTime / _requests);
+        }
+    }
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/handler/HandlerCollection.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/handler/HandlerCollection.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/handler/HandlerCollection.java	(working copy)
@@ -113,7 +113,7 @@
                 {
                     _handlers[i].handle(target,request, response, dispatch);
                 }
-                catch(EofException e)
+                catch(IOException e)
                 {
                     throw e;
                 }
@@ -129,7 +129,12 @@
                 }
             }
             if (mex!=null)
-                throw new ServletException(mex);
+            {
+                if (mex.size()==1)
+                    throw new ServletException(mex.getThrowable(0));
+                else
+                    throw new ServletException(mex);
+            }
             
         }    
     }
Index: modules/jetty/src/main/java/org/mortbay/jetty/handler/ContextHandlerCollection.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/handler/ContextHandlerCollection.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/handler/ContextHandlerCollection.java	(working copy)
@@ -15,12 +15,7 @@
 package org.mortbay.jetty.handler;
 
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 
 import javax.servlet.ServletException;
@@ -172,21 +167,32 @@
         if (handlers==null || handlers.length==0)
 	    return;
 
-	Request base_request = HttpConnection.getCurrentConnection().getRequest();
+        Request base_request = HttpConnection.getCurrentConnection().getRequest();
+      
+        // data structure which maps a request to a context
+        // each match is called in turn until the request is handled
+        // { context path => 
+        //     { virtual host => context } 
+        // }
 	PathMap map = _contextMap;
 	if (map!=null && target!=null && target.startsWith("/"))
 	{
+            // first, get all contexts matched by context path
 	    Object contexts = map.getLazyMatches(target);
 
             for (int i=0; i<LazyList.size(contexts); i++)
             {
+                // then, match against the virtualhost of each context
                 Map.Entry entry = (Map.Entry)LazyList.get(contexts, i);
                 Object list = entry.getValue();
 
                 if (list instanceof Map)
                 {
                     Map hosts = (Map)list;
-                    list=hosts.get(request.getServerName());
+                    String host = normalizeHostname(request.getServerName());
+
+                    // explicitly-defined virtual hosts, most specific
+                    list=hosts.get(host);
                     for (int j=0; j<LazyList.size(list); j++)
                     {
                         Handler handler = (Handler)LazyList.get(list,j);
@@ -194,6 +200,19 @@
                         if (base_request.isHandled())
                             return;
                     }
+
+                    // wildcard for one level of names 
+                    list=hosts.get("*."+host.substring(host.indexOf(".")+1));
+                    for (int j=0; j<LazyList.size(list); j++)
+                    {
+                        Handler handler = (Handler)LazyList.get(list,j);
+                        handler.handle(target,request, response, dispatch);
+                        if (base_request.isHandled())
+                            return;
+                    }
+
+                    // no virtualhosts defined for the context, least specific
+                    // will handle any request that does not match to a specific virtual host above                    
                     list=hosts.get("*");
                     for (int j=0; j<LazyList.size(list); j++)
                     {
@@ -247,7 +266,7 @@
         }
         catch (Exception e)
         {
-            Log.warn(e);
+            Log.debug(e);
             throw new Error(e);
         }
     }
@@ -275,5 +294,16 @@
         _contextClass = contextClass;
     }
     
-    
+    /* ------------------------------------------------------------ */
+    private String normalizeHostname( String host )
+    {
+        if ( host == null )
+            return null;
+        
+        if ( host.endsWith( "." ) )
+            return host.substring( 0, host.length() -1);
+      
+        return host;
+    }
+
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/Response.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/Response.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/Response.java	(working copy)
@@ -138,7 +138,9 @@
         if (sessionManager==null)
             return url;
         String sessionURLPrefix = sessionManager.getSessionURLPrefix();
-        
+        if (sessionURLPrefix==null)
+            return url;
+
         // should not encode if cookies in evidence
         if (url==null || request==null || request.isRequestedSessionIdFromCookie())
         {
@@ -273,6 +275,7 @@
             }
             else
             {
+                setHeader(HttpHeaders.CACHE_CONTROL, "must-revalidate,no-cache,no-store");
                 setContentType(MimeTypes.TEXT_HTML_8859_1);
                 ByteArrayISO8859Writer writer= new ByteArrayISO8859Writer(2048);
                 if (message != null)
@@ -298,11 +301,12 @@
                 writer.write(message);
                 writer.write("</title>\n</head>\n<body>\n<h2>HTTP ERROR: ");
                 writer.write(Integer.toString(code));
-                writer.write("</h2><pre>");
+                writer.write("</h2>\n<p>Problem accessing ");
+                writer.write(uri);
+                writer.write(". Reason:\n<pre>    ");
                 writer.write(message);
-                writer.write("</pre>\n<p>RequestURI=");
-                writer.write(uri);
-                writer.write("</p>\n");
+                writer.write("</pre>");
+                writer.write("</p>\n<hr /><i><small>Powered by Jetty://</small></i>");
                 
                 for (int i= 0; i < 20; i++)
                     writer.write("\n                                                ");
@@ -382,21 +386,44 @@
             throw new IllegalArgumentException();
 
         if (!URIUtil.hasScheme(location))
-        {
+        {   
             StringBuffer buf = _connection.getRequest().getRootURL();
             if (location.startsWith("/"))
-                buf.append(URIUtil.canonicalPath(location));
+                buf.append(location);
             else
             {
                 String path=_connection.getRequest().getRequestURI();
                 String parent=(path.endsWith("/"))?path:URIUtil.parentPath(path);
-                location=URIUtil.canonicalPath(URIUtil.addPaths(parent,location));
+                location=URIUtil.addPaths(parent,location);
+                if(location==null)
+                    throw new IllegalStateException("path cannot be above root");
                 if (!location.startsWith("/"))
                     buf.append('/');
                 buf.append(location);
             }
 
             location=buf.toString();
+            HttpURI uri = new HttpURI(location);
+            String path=uri.getDecodedPath();
+            String canonical=URIUtil.canonicalPath(path);
+            if (canonical==null)
+                throw new IllegalArgumentException();
+            if (!canonical.equals(path))
+            {
+                buf = _connection.getRequest().getRootURL();
+                buf.append(canonical);
+                if (uri.getQuery()!=null)
+                {
+                    buf.append('?');
+                    buf.append(uri.getQuery());
+                }
+                if (uri.getFragment()!=null)
+                {
+                    buf.append('#');
+                    buf.append(uri.getFragment());
+                }
+                location=buf.toString();
+            }
         }
         resetBuffer();
 
@@ -538,6 +565,12 @@
             _characterEncoding=StringUtil.__ISO_8859_1;
         return _characterEncoding;
     }
+    
+    /* ------------------------------------------------------------ */
+    String getSetCharacterEncoding()
+    {
+        return _characterEncoding;
+    }    
 
     /* ------------------------------------------------------------ */
     /*
@@ -615,8 +648,6 @@
     {
     	if (_connection.isIncluding())
     		return;
-    	
-        // TODO throw unsupported encoding exception ???
         
         if (this._outputState==0 && !isCommitted())
         {
@@ -966,7 +997,10 @@
         }
         
         if (_connection.getConnector().getServer().getSendDateHeader())
-            response_fields.put(HttpHeaders.DATE_BUFFER, _connection.getRequest().getTimeStampBuffer());
+        {
+            Request request=_connection.getRequest();
+            response_fields.put(HttpHeaders.DATE_BUFFER, request.getTimeStampBuffer(),request.getTimeStamp());
+        }
         
         _status=200;
         _reason=null;
Index: modules/jetty/src/main/java/org/mortbay/jetty/HttpConnection.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/HttpConnection.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/HttpConnection.java	(working copy)
@@ -18,86 +18,86 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintWriter;
-
 import javax.servlet.ServletInputStream;
 import javax.servlet.ServletOutputStream;
 import javax.servlet.http.HttpServletResponse;
 
 import org.mortbay.io.Buffer;
+import org.mortbay.io.BufferCache.CachedBuffer;
 import org.mortbay.io.Connection;
 import org.mortbay.io.EndPoint;
 import org.mortbay.io.RuntimeIOException;
-import org.mortbay.io.BufferCache.CachedBuffer;
 import org.mortbay.io.UncheckedPrintWriter;
 import org.mortbay.io.nio.SelectChannelEndPoint;
 import org.mortbay.log.Log;
 import org.mortbay.resource.Resource;
-import org.mortbay.util.DateCache;
+import org.mortbay.util.QuotedStringTokenizer;
+import org.mortbay.util.StringUtil;
 import org.mortbay.util.URIUtil;
 import org.mortbay.util.ajax.Continuation;
 
 /**
- * <p>A HttpConnection represents the connection of a HTTP client to the server
- * and is created by an instance of a {@link Connector}. It's prime function is 
- * to associate {@link Request} and {@link Response} instances with a {@link EndPoint}.
+ * <p>
+ * A HttpConnection represents the connection of a HTTP client to the server and
+ * is created by an instance of a {@link Connector}. It's prime function is to
+ * associate {@link Request} and {@link Response} instances with a
+ * {@link EndPoint}.
  * </p>
  * <p>
- * A connection is also the prime mechanism used by jetty to recycle objects without
- * pooling.  The {@link Request},  {@link Response}, {@link HttpParser}, {@link HttpGenerator}
- * and {@link HttpFields} instances are all recycled for the duraction of
- * a connection. Where appropriate, allocated buffers are also kept associated
- * with the connection via the parser and/or generator.
+ * A connection is also the prime mechanism used by jetty to recycle objects
+ * without pooling. The {@link Request},{@link Response}, {@link HttpParser},
+ * {@link HttpGenerator} and {@link HttpFields} instances are all recycled for
+ * the duration of a connection. Where appropriate, allocated buffers are also
+ * kept associated with the connection via the parser and/or generator.
  * </p>
- * 
- * 
+ *
+ *
  * @author gregw
- * 
+ *
  */
 public class HttpConnection implements Connection
 {
     private static int UNKNOWN = -2;
     private static ThreadLocal __currentConnection = new ThreadLocal();
 
-    private long _timeStamp=System.currentTimeMillis();
+    private long _timeStamp = System.currentTimeMillis();
     private int _requests;
     private boolean _handling;
     private boolean _destroy;
-    
-    
-    protected Connector _connector;
-    protected EndPoint _endp;
-    protected Server _server;
 
-    protected HttpURI _uri=new HttpURI();
+    protected final Connector _connector;
+    protected final EndPoint _endp;
+    protected final Server _server;
+    protected final HttpURI _uri;
 
-    protected Parser _parser;
-    protected HttpFields _requestFields;
-    protected Request _request;
+    protected final Parser _parser;
+    protected final HttpFields _requestFields;
+    protected final Request _request;
     protected ServletInputStream _in;
 
-    protected Generator _generator;
-    protected HttpFields _responseFields;
-    protected Response _response;
+    protected final Generator _generator;
+    protected final HttpFields _responseFields;
+    protected final Response _response;
     protected Output _out;
     protected OutputWriter _writer;
     protected PrintWriter _printWriter;
 
     int _include;
-    
+
     private Object _associatedObject; // associated object
-    
+
     private transient int _expect = UNKNOWN;
     private transient int _version = UNKNOWN;
     private transient boolean _head = false;
     private transient boolean _host = false;
-    private transient boolean  _delayedHandling=false;
+    private transient boolean _delayedHandling = false;
 
     /* ------------------------------------------------------------ */
     public static HttpConnection getCurrentConnection()
     {
-        return (HttpConnection) __currentConnection.get();
+        return (HttpConnection)__currentConnection.get();
     }
-    
+
     /* ------------------------------------------------------------ */
     protected static void setCurrentConnection(HttpConnection connection)
     {
@@ -105,57 +105,74 @@
     }
 
     /* ------------------------------------------------------------ */
-    /** Constructor
-     * 
+    /**
+     * Constructor
+     *
      */
     public HttpConnection(Connector connector, EndPoint endpoint, Server server)
     {
+        _uri = URIUtil.__CHARSET==StringUtil.__UTF8?new HttpURI():new EncodedHttpURI(URIUtil.__CHARSET);
         _connector = connector;
         _endp = endpoint;
-        _parser = new HttpParser(_connector, endpoint, new RequestHandler(), _connector.getHeaderBufferSize(), _connector.getRequestBufferSize());
+        _parser = new HttpParser(_connector,endpoint,new RequestHandler(),_connector.getHeaderBufferSize(),_connector.getRequestBufferSize());
         _requestFields = new HttpFields();
         _responseFields = new HttpFields();
         _request = new Request(this);
         _response = new Response(this);
-        _generator = new HttpGenerator(_connector, _endp, _connector.getHeaderBufferSize(), _connector.getResponseBufferSize());
+        _generator = new HttpGenerator(_connector,_endp,_connector.getHeaderBufferSize(),_connector.getResponseBufferSize());
         _generator.setSendServerVersion(server.getSendServerVersion());
         _server = server;
     }
 
+    protected HttpConnection(Connector connector, EndPoint endpoint, Server server,
+            Parser parser, Generator generator, Request request)
+    {
+        _uri = URIUtil.__CHARSET==StringUtil.__UTF8?new HttpURI():new EncodedHttpURI(URIUtil.__CHARSET);
+        _connector = connector;
+        _endp = endpoint;
+        _parser = parser;
+        _requestFields = new HttpFields();
+        _responseFields = new HttpFields();
+        _request = request;
+        _response = new Response(this);
+        _generator = generator;
+        _generator.setSendServerVersion(server.getSendServerVersion());
+        _server = server;
+    }
+
     /* ------------------------------------------------------------ */
     public void destroy()
     {
-        synchronized(this)
+        synchronized (this)
         {
-            _destroy=true;
-            if (!_handling)   
+            _destroy = true;
+            if (!_handling)
             {
-                if (_parser!=null)
+                if (_parser != null)
                     _parser.reset(true);
 
-                if (_generator!=null)
+                if (_generator != null)
                     _generator.reset(true);
 
-                if (_requestFields!=null)
+                if (_requestFields != null)
                     _requestFields.destroy();
 
-                if (_responseFields!=null)
+                if (_responseFields != null)
                     _responseFields.destroy();
 
-                _server=null;
             }
         }
     }
-    
+
     /* ------------------------------------------------------------ */
     /**
      * @return the parser used by this connection
-     */        
+     */
     public Parser getParser()
     {
         return _parser;
     }
-    
+
     /* ------------------------------------------------------------ */
     /**
      * @return the number of requests handled by this connection
@@ -173,7 +190,7 @@
     {
         return _timeStamp;
     }
-    
+
     /* ------------------------------------------------------------ */
     /**
      * @return Returns the associatedObject.
@@ -185,7 +202,8 @@
 
     /* ------------------------------------------------------------ */
     /**
-     * @param associatedObject The associatedObject to set.
+     * @param associatedObject
+     *            The associatedObject to set.
      */
     public void setAssociatedObject(Object associatedObject)
     {
@@ -221,26 +239,29 @@
 
     /* ------------------------------------------------------------ */
     /**
-     * @return The result of calling {@link #getConnector}.{@link Connector#isConfidential(Request) isCondidential}(request), or false
-     *  if there is no connector.
+     * @return The result of calling {@link #getConnector}.
+     *         {@link Connector#isConfidential(Request) isCondidential}
+     *         (request), or false if there is no connector.
      */
     public boolean isConfidential(Request request)
     {
-        if (_connector!=null)
+        if (_connector != null)
             return _connector.isConfidential(request);
         return false;
     }
-    
+
     /* ------------------------------------------------------------ */
     /**
      * Find out if the request is INTEGRAL security.
+     *
      * @param request
-     * @return <code>true</code> if there is a {@link #getConnector() connector} and it considers <code>request</code>
-     *         to be {@link Connector#isIntegral(Request) integral}
+     * @return <code>true</code> if there is a {@link #getConnector() connector}
+     *         and it considers <code>request</code> to be
+     *         {@link Connector#isIntegral(Request) integral}
      */
     public boolean isIntegral(Request request)
     {
-        if (_connector!=null)
+        if (_connector != null)
             return _connector.isIntegral(request);
         return false;
     }
@@ -283,43 +304,64 @@
 
     /* ------------------------------------------------------------ */
     /**
-     * @return The input stream for this connection. The stream will be created if it does not already exist.
+     * @return The input stream for this connection. The stream will be created
+     *         if it does not already exist.
      */
     public ServletInputStream getInputStream()
     {
-        if (_in == null) 
+        if (_in == null)
             _in = new HttpParser.Input(((HttpParser)_parser),_connector.getMaxIdleTime());
         return _in;
     }
 
     /* ------------------------------------------------------------ */
     /**
-     * @return The output stream for this connection. The stream will be created if it does not already exist.
+     * @return The output stream for this connection. The stream will be created
+     *         if it does not already exist.
      */
     public ServletOutputStream getOutputStream()
     {
-        if (_out == null) 
+        if (_out == null)
             _out = new Output();
         return _out;
     }
 
     /* ------------------------------------------------------------ */
     /**
-     * @return A {@link PrintWriter} wrapping the {@link #getOutputStream output stream}. The writer is created if it
-     *    does not already exist.
+     * @return A {@link PrintWriter} wrapping the {@link #getOutputStream output
+     *         stream}. The writer is created if it does not already exist.
      */
     public PrintWriter getPrintWriter(String encoding)
     {
         getOutputStream();
-        if (_writer==null)
+        if (_writer == null)
         {
-            _writer=new OutputWriter();
-            _printWriter=new UncheckedPrintWriter(_writer);
+            _writer = new OutputWriter();
+            _printWriter = new UncheckedPrintWriter(_writer)
+            {
+                /* ------------------------------------------------------------ */
+                /*
+                 * @see java.io.PrintWriter#close()
+                 */
+                public void close()
+                {
+                    try
+                    {
+                        out.close();
+                    }
+                    catch (IOException e)
+                    {
+                        Log.debug(e);
+                        setError();
+                    }
+                }
+
+            };
         }
         _writer.setCharacterEncoding(encoding);
         return _printWriter;
     }
-    
+
     /* ------------------------------------------------------------ */
     public boolean isResponseCommitted()
     {
@@ -330,64 +372,64 @@
     public void handle() throws IOException
     {
         // Loop while more in buffer
-        boolean more_in_buffer =true; // assume true until proven otherwise
-        int no_progress=0;
-        
+        boolean more_in_buffer = true; // assume true until proven otherwise
+        int no_progress = 0;
+
         while (more_in_buffer)
         {
             try
             {
-                synchronized(this)
+                synchronized (this)
                 {
                     if (_handling)
-                    {
-                        throw new IllegalStateException(); // TODO delete this check
-                    }
-                    _handling=true;
+                        throw new IllegalStateException(); // TODO delete this
+                                                           // check
+                    _handling = true;
                 }
-                
+
                 setCurrentConnection(this);
-                long io=0;
-                
+                long io = 0;
+
                 Continuation continuation = _request.getContinuation();
                 if (continuation != null && continuation.isPending())
                 {
                     Log.debug("resume continuation {}",continuation);
-                    if (_request.getMethod()==null)
+                    if (_request.getMethod() == null)
                         throw new IllegalStateException();
                     handleRequest();
                 }
                 else
                 {
                     // If we are not ended then parse available
-                    if (!_parser.isComplete()) 
-                        io=_parser.parseAvailable();
-                    
+                    if (!_parser.isComplete())
+                        io = _parser.parseAvailable();
+
                     // Do we have more generating to do?
                     // Loop here because some writes may take multiple steps and
-                    // we need to flush them all before potentially blocking in the
+                    // we need to flush them all before potentially blocking in
+                    // the
                     // next loop.
                     while (_generator.isCommitted() && !_generator.isComplete())
                     {
-                        long written=_generator.flush();
-                        io+=written;
-                        if (written<=0)
+                        long written = _generator.flush();
+                        io += written;
+                        if (written <= 0)
                             break;
-                        else if (_endp.isBufferingOutput())
+                        if (_endp.isBufferingOutput())
                             _endp.flush();
                     }
-                    
+
                     // Flush buffers
                     if (_endp.isBufferingOutput())
                     {
                         _endp.flush();
                         if (!_endp.isBufferingOutput())
-                            no_progress=0;
+                            no_progress = 0;
                     }
-                    
-                    if (io>0)
-                        no_progress=0;
-                    else if (no_progress++>=2) 
+
+                    if (io > 0)
+                        no_progress = 0;
+                    else if (no_progress++ >= 2)
                         return;
                 }
             }
@@ -395,12 +437,12 @@
             {
                 if (Log.isDebugEnabled())
                 {
-                    Log.debug("uri="+_uri);
-                    Log.debug("fields="+_requestFields);
+                    Log.debug("uri=" + _uri);
+                    Log.debug("fields=" + _requestFields);
                     Log.debug(e);
                 }
-                _generator.sendError(e.getStatus(), e.getReason(), null, true);
-                
+                _generator.sendError(e.getStatus(),e.getReason(),null,true);
+
                 _parser.reset(true);
                 _endp.close();
                 throw e;
@@ -408,38 +450,48 @@
             finally
             {
                 setCurrentConnection(null);
-                
-                more_in_buffer = _parser.isMoreInBuffer() || _endp.isBufferingInput();  
-                
-                synchronized(this)
+
+                more_in_buffer = _parser.isMoreInBuffer() || _endp.isBufferingInput();
+
+                synchronized (this)
                 {
-                    _handling=false;
-                    
+                    _handling = false;
+
                     if (_destroy)
-                    { 
+                    {
                         destroy();
                         return;
                     }
                 }
-                
+
                 if (_parser.isComplete() && _generator.isComplete() && !_endp.isBufferingOutput())
-                {  
+                {
                     if (!_generator.isPersistent())
                     {
                         _parser.reset(true);
-                        more_in_buffer=false;
+                        more_in_buffer = false;
                     }
-                    
-                    reset(!more_in_buffer);
-                    no_progress=0;
+
+                    if (more_in_buffer)
+                    {
+                        reset(false);
+                        more_in_buffer = _parser.isMoreInBuffer() || _endp.isBufferingInput();
+                    }
+                    else
+                        reset(true);
+
+                    no_progress = 0;
                 }
-                
+
                 Continuation continuation = _request.getContinuation();
                 if (continuation != null && continuation.isPending())
                 {
                     break;
                 }
-                else if (_generator.isCommitted() && !_generator.isComplete() && _endp instanceof SelectChannelEndPoint) // TODO remove SelectChannel dependency
+                else if (_generator.isCommitted() && !_generator.isComplete() && _endp instanceof SelectChannelEndPoint) // TODO
+                                                                                                                         // remove
+                                                                                                                         // SelectChannel
+                                                                                                                         // dependency
                     ((SelectChannelEndPoint)_endp).setWritable(false);
             }
         }
@@ -448,103 +500,111 @@
     /* ------------------------------------------------------------ */
     public void reset(boolean returnBuffers)
     {
-        _parser.reset(returnBuffers); // TODO maybe only release when low on resources
+        _parser.reset(returnBuffers); // TODO maybe only release when low on
+                                      // resources
         _requestFields.clear();
         _request.recycle();
-        
-        _generator.reset(returnBuffers); // TODO maybe only release when low on resources
+
+        _generator.reset(returnBuffers); // TODO maybe only release when low on
+                                         // resources
         _responseFields.clear();
         _response.recycle();
-        
-        _uri.clear(); 
+
+        _uri.clear();
     }
-    
+
     /* ------------------------------------------------------------ */
     protected void handleRequest() throws IOException
     {
-        if (_server != null)
+        if (_server.isRunning())
         {
             boolean retrying = false;
             boolean error = false;
-            String threadName=null;
+            String threadName = null;
+            String info=null;
             try
             {
-                // TODO try to do this lazily or more efficiently
-                String info=URIUtil.canonicalPath(_uri.getDecodedPath());
-                if (info==null)
+                info = URIUtil.canonicalPath(_uri.getDecodedPath());
+                if (info == null)
                     throw new HttpException(400);
                 _request.setPathInfo(info);
-                
-                if (_out!=null)
+
+                if (_out != null)
                     _out.reopen();
-                
+
                 if (Log.isDebugEnabled())
                 {
-                    threadName=Thread.currentThread().getName();
-                    Thread.currentThread().setName(threadName+" - "+_uri);
+                    threadName = Thread.currentThread().getName();
+                    Thread.currentThread().setName(threadName + " - " + _uri);
                 }
-                
-                _connector.customize(_endp, _request);
-                
+
+                _connector.customize(_endp,_request);
+
                 _server.handle(this);
             }
             catch (RetryRequest r)
             {
-                Log.ignore(r);
+                if (Log.isDebugEnabled())
+                    Log.ignore(r);
                 retrying = true;
             }
             catch (EofException e)
             {
-                Log.debug(e);
-                _request.setHandled(true);
-                error=true;
+                Log.ignore(e);
+                error = true;
             }
-            catch (RuntimeIOException e)
+            catch (HttpException e)
             {
                 Log.debug(e);
                 _request.setHandled(true);
+                _response.sendError(e.getStatus(),e.getReason());
                 error = true;
             }
-            catch (HttpException e)
+            catch (RuntimeIOException e)
             {
                 Log.debug(e);
                 _request.setHandled(true);
-                _response.sendError(e.getStatus(), e.getReason());
-                error=true;
+                error = true;
             }
-            catch (Exception e)
+            catch (Throwable e)
             {
-                Log.warn(e);
-                _request.setHandled(true);
-                _generator.sendError(500, null, null, true);
-                error=true;
+                if (e instanceof ThreadDeath)
+                    throw (ThreadDeath)e;
+
+                if (info==null)
+                {
+                    Log.warn(_uri+": "+e);
+                    Log.debug(e);
+                    _request.setHandled(true);
+                    _generator.sendError(400,null,null,true);
+                }
+                else
+                {
+                    Log.warn(""+_uri,e);
+                    _request.setHandled(true);
+                    _generator.sendError(500,null,null,true);
+                }
+                error = true;
             }
-            catch (Error e)
+            finally
             {
-                Log.warn(e);
-                _request.setHandled(true);
-                _generator.sendError(500, null, null, true);
-                error=true;
-            }
-            finally
-            {   
-                if (threadName!=null)
+                if (threadName != null)
                     Thread.currentThread().setName(threadName);
-                
+
                 if (!retrying)
                 {
-                    if (_request.getContinuation()!=null)
+                    if (_request.getContinuation() != null)
                     {
                         Log.debug("continuation still pending {}");
                         _request.getContinuation().reset();
                     }
-                    
-                    if(_endp.isOpen())
+
+                    if (_endp.isOpen())
                     {
                         if (_generator.isPersistent())
                             _connector.persist(_endp);
-                        
-                        if (error) 
+
+                        if (error)
                             _endp.close();
                         else
                         {
@@ -567,10 +627,30 @@
     {
         if (!_generator.isCommitted())
         {
-            _generator.setResponse(_response.getStatus(), _response.getReason());
-            _generator.completeHeader(_responseFields, last);
+            _generator.setResponse(_response.getStatus(),_response.getReason());
+            try
+            {
+                _generator.completeHeader(_responseFields,last);
+            }
+            catch(IOException io)
+            {
+                throw io;
+            }
+            catch(RuntimeException e)
+            {
+                Log.warn("header full: "+e);
+                if (Log.isDebugEnabled() && _generator instanceof HttpGenerator)
+                    Log.debug(((HttpGenerator)_generator)._header.toDetailString(),e);
+                
+                _response.reset();
+                _generator.reset(true);
+                _generator.setResponse(HttpStatus.ORDINAL_500_Internal_Server_Error,null);
+                _generator.completeHeader(_responseFields,HttpGenerator.LAST);
+                _generator.complete();
+                throw e;
+            }
         }
-        if (last) 
+        if (last)
             _generator.complete();
     }
 
@@ -579,8 +659,27 @@
     {
         if (!_generator.isCommitted())
         {
-            _generator.setResponse(_response.getStatus(), _response.getReason());
-            _generator.completeHeader(_responseFields, HttpGenerator.LAST);
+            _generator.setResponse(_response.getStatus(),_response.getReason());
+            try
+            {
+                _generator.completeHeader(_responseFields,HttpGenerator.LAST);
+            }
+            catch(IOException io)
+            {
+                throw io;
+            }
+            catch(RuntimeException e)
+            {
+                Log.warn("header full: "+e);
+                Log.debug(e);
+
+                _response.reset();
+                _generator.reset(true);
+                _generator.setResponse(HttpStatus.ORDINAL_500_Internal_Server_Error,null);
+                _generator.completeHeader(_responseFields,HttpGenerator.LAST);
+                _generator.complete();
+                throw e;
+            }
         }
 
         _generator.complete();
@@ -594,9 +693,9 @@
             commitResponse(HttpGenerator.MORE);
             _generator.flush();
         }
-        catch(IOException e)
+        catch (IOException e)
         {
-            throw (e instanceof EofException) ? e:new EofException(e);
+            throw (e instanceof EofException)?e:new EofException(e);
         }
     }
 
@@ -605,12 +704,11 @@
     {
         return _generator;
     }
-    
 
     /* ------------------------------------------------------------ */
     public boolean isIncluding()
     {
-        return _include>0;
+        return _include > 0;
     }
 
     /* ------------------------------------------------------------ */
@@ -623,7 +721,7 @@
     public void included()
     {
         _include--;
-        if (_out!=null)
+        if (_out != null)
             _out.reopen();
     }
 
@@ -632,49 +730,52 @@
     {
         return _generator.isIdle() && (_parser.isIdle() || _delayedHandling);
     }
-    
+
     /* ------------------------------------------------------------ */
     /* ------------------------------------------------------------ */
     /* ------------------------------------------------------------ */
     private class RequestHandler extends HttpParser.EventHandler
     {
         private String _charset;
-        
+
         /*
-         * 
-         * @see org.mortbay.jetty.HttpParser.EventHandler#startRequest(org.mortbay.io.Buffer,
-         *      org.mortbay.io.Buffer, org.mortbay.io.Buffer)
+         *
+         * @see
+         * org.mortbay.jetty.HttpParser.EventHandler#startRequest(org.mortbay
+         * .io.Buffer, org.mortbay.io.Buffer, org.mortbay.io.Buffer)
          */
         public void startRequest(Buffer method, Buffer uri, Buffer version) throws IOException
         {
             _host = false;
             _expect = UNKNOWN;
-            _delayedHandling=false;
-            _charset=null;
+            _delayedHandling = false;
+            _charset = null;
 
-            if(_request.getTimeStamp()==0)
+            if (_request.getTimeStamp() == 0)
                 _request.setTimeStamp(System.currentTimeMillis());
             _request.setMethod(method.toString());
 
             try
             {
-                _uri.parse(uri.array(), uri.getIndex(), uri.length());
+                _uri.parse(uri.array(),uri.getIndex(),uri.length());
                 _request.setUri(_uri);
 
-                if (version==null)
+                if (version == null)
                 {
                     _request.setProtocol(HttpVersions.HTTP_0_9);
-                    _version=HttpVersions.HTTP_0_9_ORDINAL;
+                    _version = HttpVersions.HTTP_0_9_ORDINAL;
                 }
                 else
                 {
-                    version= HttpVersions.CACHE.get(version);
+                    version = HttpVersions.CACHE.get(version);
                     _version = HttpVersions.CACHE.getOrdinal(version);
-                    if (_version <= 0) _version = HttpVersions.HTTP_1_0_ORDINAL;
+                    if (_version <= 0)
+                        _version = HttpVersions.HTTP_1_0_ORDINAL;
                     _request.setProtocol(version.toString());
                 }
 
-                _head = method == HttpMethods.HEAD_BUFFER; // depends on method being decached.
+                _head = method == HttpMethods.HEAD_BUFFER; // depends on method
+                                                           // being decached.
             }
             catch (Exception e)
             {
@@ -683,7 +784,9 @@
         }
 
         /*
-         * @see org.mortbay.jetty.HttpParser.EventHandler#parsedHeaderValue(org.mortbay.io.Buffer)
+         * @see
+         * org.mortbay.jetty.HttpParser.EventHandler#parsedHeaderValue(org.mortbay
+         * .io.Buffer)
          */
         public void parsedHeader(Buffer name, Buffer value)
         {
@@ -694,37 +797,38 @@
                     // TODO check if host matched a host in the URI.
                     _host = true;
                     break;
-                    
+
                 case HttpHeaders.EXPECT_ORDINAL:
                     value = HttpHeaderValues.CACHE.lookup(value);
                     _expect = HttpHeaderValues.CACHE.getOrdinal(value);
                     break;
-                    
+
                 case HttpHeaders.ACCEPT_ENCODING_ORDINAL:
                 case HttpHeaders.USER_AGENT_ORDINAL:
                     value = HttpHeaderValues.CACHE.lookup(value);
                     break;
-                    
+
                 case HttpHeaders.CONTENT_TYPE_ORDINAL:
                     value = MimeTypes.CACHE.lookup(value);
-                    _charset=MimeTypes.getCharsetFromContentType(value);
+                    _charset = MimeTypes.getCharsetFromContentType(value);
                     break;
 
                 case HttpHeaders.CONNECTION_ORDINAL:
-                    //looks rather clumsy, but the idea is to optimize for a single valued header
+                    // looks rather clumsy, but the idea is to optimize for a
+                    // single valued header
                     int ordinal = HttpHeaderValues.CACHE.getOrdinal(value);
-                    switch(ordinal)
+                    switch (ordinal)
                     {
                         case -1:
-                        { 
+                        {
                             String[] values = value.toString().split(",");
-                            for  (int i=0;values!=null && i<values.length;i++)
+                            for (int i = 0; values != null && i < values.length; i++)
                             {
                                 CachedBuffer cb = HttpHeaderValues.CACHE.get(values[i].trim());
 
-                                if (cb!=null)
+                                if (cb != null)
                                 {
-                                    switch(cb.getOrdinal())
+                                    switch (cb.getOrdinal())
                                     {
                                         case HttpHeaderValues.CLOSE_ORDINAL:
                                             _responseFields.add(HttpHeaders.CONNECTION_BUFFER,HttpHeaderValues.CLOSE_BUFFER);
@@ -732,7 +836,7 @@
                                             break;
 
                                         case HttpHeaderValues.KEEP_ALIVE_ORDINAL:
-                                            if (_version==HttpVersions.HTTP_1_0_ORDINAL)
+                                            if (_version == HttpVersions.HTTP_1_0_ORDINAL)
                                                 _responseFields.add(HttpHeaders.CONNECTION_BUFFER,HttpHeaderValues.KEEP_ALIVE_BUFFER);
                                             break;
                                     }
@@ -746,13 +850,13 @@
                             break;
 
                         case HttpHeaderValues.KEEP_ALIVE_ORDINAL:
-                            if (_version==HttpVersions.HTTP_1_0_ORDINAL)
+                            if (_version == HttpVersions.HTTP_1_0_ORDINAL)
                                 _responseFields.put(HttpHeaders.CONNECTION_BUFFER,HttpHeaderValues.KEEP_ALIVE_BUFFER);
                             break;
-                    } 
+                    }
             }
 
-            _requestFields.add(name, value);
+            _requestFields.add(name,value);
         }
 
         /*
@@ -771,16 +875,15 @@
                     break;
                 case HttpVersions.HTTP_1_1_ORDINAL:
                     _generator.setHead(_head);
-                    
+
                     if (_server.getSendDateHeader())
-                        _responseFields.put(HttpHeaders.DATE_BUFFER, _request.getTimeStampBuffer());
-                   
-                    
+                        _responseFields.put(HttpHeaders.DATE_BUFFER,_request.getTimeStampBuffer(),_request.getTimeStamp());
+
                     if (!_host)
                     {
-                        _generator.setResponse(HttpStatus.ORDINAL_400_Bad_Request, null);
-                        _responseFields.put(HttpHeaders.CONNECTION_BUFFER, HttpHeaderValues.CLOSE_BUFFER);
-                        _generator.completeHeader(_responseFields, true);
+                        _generator.setResponse(HttpStatus.ORDINAL_400_Bad_Request,null);
+                        _responseFields.put(HttpHeaders.CONNECTION_BUFFER,HttpHeaderValues.CLOSE_BUFFER);
+                        _generator.completeHeader(_responseFields,true);
                         _generator.complete();
                         return;
                     }
@@ -789,11 +892,12 @@
                     {
                         if (_expect == HttpHeaderValues.CONTINUE_ORDINAL)
                         {
-                            // TODO delay sending 100 response until a read is attempted.
-                            if (((HttpParser)_parser).getHeaderBuffer()==null || ((HttpParser)_parser).getHeaderBuffer().length()<2)
+                            // TODO delay sending 100 response until a read is
+                            // attempted.
+                            if (((HttpParser)_parser).getHeaderBuffer() == null || ((HttpParser)_parser).getHeaderBuffer().length() < 2)
                             {
-                                _generator.setResponse(HttpStatus.ORDINAL_100_Continue, null);
-                                _generator.completeHeader(null, true);
+                                _generator.setResponse(HttpStatus.ORDINAL_100_Continue,null);
+                                _generator.completeHeader(null,true);
                                 _generator.complete();
                                 _generator.reset(false);
                             }
@@ -803,71 +907,77 @@
                         }
                         else
                         {
-                            _generator.sendError(HttpStatus.ORDINAL_417_Expectation_Failed, null, null, true);
+                            _generator.sendError(HttpStatus.ORDINAL_417_Expectation_Failed,null,null,true);
                             return;
                         }
                     }
-                    
+
                     break;
                 default:
             }
 
-            if(_charset!=null)
+            if (_charset != null)
                 _request.setCharacterEncodingUnchecked(_charset);
-            
+
             // Either handle now or wait for first content
-            if (((HttpParser)_parser).getContentLength()<=0 && !((HttpParser)_parser).isChunking())
+            if (((HttpParser)_parser).getContentLength() <= 0 && !((HttpParser)_parser).isChunking())
                 handleRequest();
             else
-                _delayedHandling=true;
+                _delayedHandling = true;
         }
 
         /* ------------------------------------------------------------ */
         /*
-         * @see org.mortbay.jetty.HttpParser.EventHandler#content(int, org.mortbay.io.Buffer)
+         * @see org.mortbay.jetty.HttpParser.EventHandler#content(int,
+         * org.mortbay.io.Buffer)
          */
         public void content(Buffer ref) throws IOException
         {
             if (_delayedHandling)
             {
-                _delayedHandling=false;
+                _delayedHandling = false;
                 handleRequest();
             }
         }
 
         /*
          * (non-Javadoc)
-         * 
+         *
          * @see org.mortbay.jetty.HttpParser.EventHandler#messageComplete(int)
          */
-        public void messageComplete(long contextLength) throws IOException
+        public void messageComplete(long contentLength) throws IOException
         {
+            if (_delayedHandling)
+            {
+                _delayedHandling = false;
+                handleRequest();
+            }
         }
 
         /*
          * (non-Javadoc)
-         * 
-         * @see org.mortbay.jetty.HttpParser.EventHandler#startResponse(org.mortbay.io.Buffer, int,
-         *      org.mortbay.io.Buffer)
+         *
+         * @see
+         * org.mortbay.jetty.HttpParser.EventHandler#startResponse(org.mortbay
+         * .io.Buffer, int, org.mortbay.io.Buffer)
          */
         public void startResponse(Buffer version, int status, Buffer reason)
         {
-            throw new IllegalStateException("response");
+            Log.debug("Bad request!: " + version + " " + status + " " + reason);
         }
 
     }
 
-    
     /* ------------------------------------------------------------ */
     /* ------------------------------------------------------------ */
     /* ------------------------------------------------------------ */
-    public class Output extends AbstractGenerator.Output 
+    public class Output extends AbstractGenerator.Output
     {
         Output()
         {
             super((AbstractGenerator)HttpConnection.this._generator,_connector.getMaxIdleTime());
         }
-        
+
         /* ------------------------------------------------------------ */
         /*
          * @see java.io.OutputStream#close()
@@ -876,16 +986,15 @@
         {
             if (_closed)
                 return;
-            
+
             if (!isIncluding() && !_generator.isCommitted())
                 commitResponse(HttpGenerator.LAST);
             else
                 flushResponse();
-            
+
             super.close();
         }
 
-        
         /* ------------------------------------------------------------ */
         /*
          * @see java.io.OutputStream#flush()
@@ -898,99 +1007,127 @@
         }
 
         /* ------------------------------------------------------------ */
-        /* 
+        /*
          * @see javax.servlet.ServletOutputStream#print(java.lang.String)
          */
         public void print(String s) throws IOException
         {
             if (_closed)
                 throw new IOException("Closed");
-            PrintWriter writer=getPrintWriter(null);
+            PrintWriter writer = getPrintWriter(null);
             writer.print(s);
         }
 
         /* ------------------------------------------------------------ */
+        public void sendResponse(Buffer response) throws IOException
+        {
+            ((HttpGenerator)_generator).sendResponse(response);
+        }
+
+        /* ------------------------------------------------------------ */
         public void sendContent(Object content) throws IOException
         {
-            Resource resource=null;
-            
+            Resource resource = null;
+
             if (_closed)
                 throw new IOException("Closed");
-            
-            if (_generator.getContentWritten() > 0) throw new IllegalStateException("!empty");
 
+            if (_generator.getContentWritten() > 0)
+                throw new IllegalStateException("!empty");
+
             if (content instanceof HttpContent)
             {
-                HttpContent c = (HttpContent) content;
-                if (c.getContentType() != null && !_responseFields.containsKey(HttpHeaders.CONTENT_TYPE_BUFFER)) 
-                    _responseFields.add(HttpHeaders.CONTENT_TYPE_BUFFER, c.getContentType());
-                if (c.getContentLength() > 0) 
-                    _responseFields.putLongField(HttpHeaders.CONTENT_LENGTH_BUFFER, c.getContentLength());
+                HttpContent c = (HttpContent)content;
+                Buffer contentType = c.getContentType();
+                if (contentType != null && !_responseFields.containsKey(HttpHeaders.CONTENT_TYPE_BUFFER))
+                {
+                    String enc = _response.getSetCharacterEncoding();
+                    if(enc==null)
+                        _responseFields.add(HttpHeaders.CONTENT_TYPE_BUFFER, contentType);
+                    else
+                    {
+                        if(contentType instanceof CachedBuffer)
+                        {
+                            CachedBuffer content_type = ((CachedBuffer)contentType).getAssociate(enc);
+                            if(content_type!=null)
+                                _responseFields.put(HttpHeaders.CONTENT_TYPE_BUFFER, content_type);
+                            else
+                            {
+                                _responseFields.put(HttpHeaders.CONTENT_TYPE_BUFFER,
+                                        contentType+";charset="+QuotedStringTokenizer.quote(enc,";= "));
+                            }
+                        }
+                        else
+                        {
+                            _responseFields.put(HttpHeaders.CONTENT_TYPE_BUFFER,
+                                    contentType+";charset="+QuotedStringTokenizer.quote(enc,";= "));
+                        }
+                    }
+                }
+                if (c.getContentLength() > 0)
+                    _responseFields.putLongField(HttpHeaders.CONTENT_LENGTH_BUFFER,c.getContentLength());
                 Buffer lm = c.getLastModified();
-                if (lm != null) 
-                    _responseFields.put(HttpHeaders.LAST_MODIFIED_BUFFER, lm);
-                else if (c.getResource()!=null)
+                long lml = c.getResource().lastModified();
+                if (lm != null)
+                    _responseFields.put(HttpHeaders.LAST_MODIFIED_BUFFER,lm,lml);
+                else if (c.getResource() != null)
                 {
-                    long lml=c.getResource().lastModified();
-                    if (lml!=-1)
-                        _responseFields.putDateField(HttpHeaders.LAST_MODIFIED_BUFFER, lml);
+                    if (lml != -1)
+                        _responseFields.putDateField(HttpHeaders.LAST_MODIFIED_BUFFER,lml);
                 }
-                    
+
                 content = c.getBuffer();
-                if (content==null)
-                    content=c.getInputStream();
+                if (content == null)
+                    content = c.getInputStream();
             }
             else if (content instanceof Resource)
             {
-                resource=(Resource)content;
-                _responseFields.putLongField(HttpHeaders.LAST_MODIFIED_BUFFER, resource.lastModified());
-                content=resource.getInputStream();
+                resource = (Resource)content;
+                _responseFields.putDateField(HttpHeaders.LAST_MODIFIED_BUFFER,resource.lastModified());
+                content = resource.getInputStream();
             }
-            
-            
-            
+
             if (content instanceof Buffer)
             {
-                _generator.addContent((Buffer) content, HttpGenerator.LAST);
+                _generator.addContent((Buffer)content,HttpGenerator.LAST);
                 commitResponse(HttpGenerator.LAST);
             }
             else if (content instanceof InputStream)
             {
                 InputStream in = (InputStream)content;
-                
+
                 try
                 {
                     int max = _generator.prepareUncheckedAddContent();
                     Buffer buffer = _generator.getUncheckedBuffer();
 
-                    int len=buffer.readFrom(in,max);
+                    int len = buffer.readFrom(in,max);
 
-                    while (len>=0)
+                    while (len >= 0)
                     {
                         _generator.completeUncheckedAddContent();
                         _out.flush();
 
                         max = _generator.prepareUncheckedAddContent();
                         buffer = _generator.getUncheckedBuffer();
-                        len=buffer.readFrom(in,max);
+                        len = buffer.readFrom(in,max);
                     }
                     _generator.completeUncheckedAddContent();
-                    _out.flush();   
+                    _out.flush();
                 }
                 finally
                 {
-                    if (resource!=null)
+                    if (resource != null)
                         resource.release();
                     else
                         in.close();
-                      
+
                 }
             }
             else
                 throw new IllegalArgumentException("unknown content type?");
-            
-            
-        }     
+
+        }
     }
 
     /* ------------------------------------------------------------ */
Index: modules/jetty/src/main/java/org/mortbay/jetty/HttpURI.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/HttpURI.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/HttpURI.java	(working copy)
@@ -21,6 +21,7 @@
 import org.mortbay.util.TypeUtil;
 import org.mortbay.util.URIUtil;
 import org.mortbay.util.UrlEncoded;
+import org.mortbay.util.Utf8StringBuffer;
 
 
 /* ------------------------------------------------------------ */
@@ -47,10 +48,12 @@
     AUTH_OR_PATH=1,
     SCHEME_OR_PATH=2,
     AUTH=4,
-    PORT=5,
-    PATH=6,
-    PARAM=7,
-    QUERY=8;
+    IPV6=5,
+    PORT=6,
+    PATH=7,
+    PARAM=8,
+    QUERY=9,
+    ASTERISK=10;
     
     boolean _partial=false;
     byte[] _raw=__empty;
@@ -65,6 +68,8 @@
     int _fragment;
     int _end;
     
+    Utf8StringBuffer _utf8b = new Utf8StringBuffer(64);
+    
     public HttpURI()
     {
         
@@ -125,39 +130,41 @@
             char c=(char)(0xff&_raw[i]);
             int s=i++;
             
-            switch (state)
+            state: switch (state)
             {
                 case START:
                 {
                     m=s;
-                    if (c=='/')
+                    switch(c)
                     {
-                        state=AUTH_OR_PATH;
+                        case '/':
+                            state=AUTH_OR_PATH;
+                            break;
+                        case ';':
+                            _param=s;
+                            state=PARAM;
+                            break;
+                        case '?':
+                            _param=s;
+                            _query=s;
+                            state=QUERY;
+                            break;
+                        case '#':
+                            _param=s;
+                            _query=s;
+                            _fragment=s;
+                            break;
+                        case '*':
+                            _path=s;
+                            state=ASTERISK;
+                            break;
+                            
+                        default:
+                            if (Character.isLetterOrDigit(c))
+                                state=SCHEME_OR_PATH;
+                            else
+                                throw new IllegalArgumentException(StringUtil.toString(_raw,offset,length,URIUtil.__CHARSET));
                     }
-                    else if (Character.isLetterOrDigit(c))
-                    {
-                        state=SCHEME_OR_PATH;
-                    }
-                    else if (c==';')
-                    {
-                        _param=s;
-                        state=PARAM;
-                    }
-                    else if (c=='?')
-                    {
-                        _param=s;
-                        _query=s;
-                        state=QUERY;
-                    }
-                    else if (c=='#')
-                    {
-                        _param=s;
-                        _query=s;
-                        _fragment=s;
-                        break;
-                    }
-                    else
-                        throw new IllegalArgumentException(new String(_raw,offset,length));
                     
                     continue;
                 }
@@ -210,65 +217,105 @@
                         }
                     }
                     
-                    
-                    if (c==':')
+                    switch (c)
                     {
-                        m=i++;
-                        _authority=m;
-                        _path=m;
-                        c=(char)(0xff&_raw[i]);
-                        if (c=='/')
-                            state=AUTH_OR_PATH;
-                        else 
+                        case ':':
                         {
-                            _host=m;
-                            _port=m;
-                            state=PATH;
+                            m = i++;
+                            _authority = m;
+                            _path = m;
+                            c = (char)(0xff & _raw[i]);
+                            if (c == '/')
+                                state = AUTH_OR_PATH;
+                            else
+                            {
+                                _host = m;
+                                _port = m;
+                                state = PATH;
+                            }
+                            break;
                         }
+                        
+                        case '/':
+                        {
+                            state = PATH;
+                            break;
+                        }
+                        
+                        case ';':
+                        {
+                            _param = s;
+                            state = PARAM;
+                            break;
+                        }
+                        
+                        case '?':
+                        {
+                            _param = s;
+                            _query = s;
+                            state = QUERY;
+                            break;
+                        }
+                        
+                        case '#':
+                        {
+                            _param = s;
+                            _query = s;
+                            _fragment = s;
+                            break;
+                        }
                     }
-                    else if (c=='/')
-                    {
-                        state=PATH;
-                    }
-                    else if (c==';')
-                    {
-                        _param=s;
-                        state=PARAM;
-                    }
-                    else if (c=='?')
-                    {
-                        _param=s;
-                        _query=s;
-                        state=QUERY;
-                    }
-                    else if (c=='#')
-                    {
-                        _param=s;
-                        _query=s;
-                        _fragment=s;
-                        break;
-                    }
                     continue;
                 }
                 
                 case AUTH:
                 {
-                    if (c=='/')
+                    switch (c)
                     {
-                        m=s;
-                        _path=m;
-                        _port=_path;
-                        state=PATH;
+
+                        case '/':
+                        {
+                            m = s;
+                            _path = m;
+                            _port = _path;
+                            state = PATH;
+                            break;
+                        }
+                        case '@':
+                        {
+                            _host = i;
+                            break;
+                        }
+                        case ':':
+                        {
+                            _port = s;
+                            state = PORT;
+                            break;
+                        }
+                        case '[':
+                        {
+                            state = IPV6;
+                            break;
+                        }
                     }
-                    else if (c=='@')
+                    continue;
+                }
+
+                case IPV6:
+                {
+                    switch (c)
                     {
-                        _host=i;
+                        case '/':
+                        {
+                            throw new IllegalArgumentException("No closing ']' for " + StringUtil.toString(_raw,offset,length,URIUtil.__CHARSET));
+                        }
+                        case ']':
+                        {
+                            state = AUTH;
+                            break;
+                        }
                     }
-                    else if (c==':')
-                    {
-                        _port=s;
-                        state=PORT;
-                    }
+
                     continue;
                 }
                 
@@ -287,40 +334,49 @@
                 
                 case PATH:
                 {
-                    if (c==';')
+                    switch (c)
                     {
-                        _param=s;
-                        state=PARAM;
+                        case ';':
+                        {
+                            _param = s;
+                            state = PARAM;
+                            break;
+                        }
+                        case '?':
+                        {
+                            _param = s;
+                            _query = s;
+                            state = QUERY;
+                            break;
+                        }
+                        case '#':
+                        {
+                            _param = s;
+                            _query = s;
+                            _fragment = s;
+                            break state;
+                        }
                     }
-                    else if (c=='?')
-                    {
-                        _param=s;
-                        _query=s;
-                        state=QUERY;
-                    }
-                    else if (c=='#')
-                    {
-                        _param=s;
-                        _query=s;
-                        _fragment=s;
-                        break;
-                    }
                     continue;
                 }
                 
                 case PARAM:
                 {
-                    if (c=='?')
+                    switch (c)
                     {
-                        _query=s;
-                        state=QUERY;
+                        case '?':
+                        {
+                            _query = s;
+                            state = QUERY;
+                            break;
+                        }
+                        case '#':
+                        {
+                            _query = s;
+                            _fragment = s;
+                            break state;
+                        }
                     }
-                    else if (c=='#')
-                    {
-                        _query=s;
-                        _fragment=s;
-                        break;
-                    }
                     continue;
                 }
                 
@@ -329,15 +385,25 @@
                     if (c=='#')
                     {
                         _fragment=s;
-                        break;
+                        break state;
                     }
                     continue;
                 }
                 
+                case ASTERISK:
+                {
+                    throw new IllegalArgumentException("only '*'");
+                }
             }
         }
     }
     
+    private String toUtf8String(int offset,int length)
+    {
+        _utf8b.reset();
+        _utf8b.append(_raw,offset,length);
+        return _utf8b.toString();
+    }
     
     public String getScheme()
     {
@@ -357,21 +423,22 @@
             _raw[_scheme+3]=='p' && 
             _raw[_scheme+4]=='s' )
             return HttpSchemes.HTTPS;
-        return new String(_raw,_scheme,_authority-_scheme-1);
+        
+        return toUtf8String(_scheme,_authority-_scheme-1);
     }
     
     public String getAuthority()
     {
         if (_authority==_path)
             return null;
-        return new String(_raw,_authority,_path-_authority);
+        return toUtf8String(_authority,_path-_authority);
     }
     
     public String getHost()
     {
         if (_host==_port)
             return null;
-        return new String(_raw,_host,_port-_host);
+        return toUtf8String(_host,_port-_host);
     }
     
     public int getPort()
@@ -385,71 +452,116 @@
     {
         if (_path==_param)
             return null;
-        return StringUtil.toString(_raw,_path,_param-_path,URIUtil.__CHARSET);
+        return toUtf8String(_path,_param-_path);
     }
     
     public String getDecodedPath()
     {
         if (_path==_param)
             return null;
-        return URIUtil.decodePath(_raw,_path,_param-_path);
+
+        int length = _param-_path;
+        byte[] bytes=null;
+        int n=0;
+
+        for (int i=_path;i<_param;i++)
+        {
+            byte b = _raw[i];
+            
+            if (b=='%' && (i+2)<_param)
+            {
+                b=(byte)(0xff&TypeUtil.parseInt(_raw,i+1,2,16));
+                i+=2;
+            }
+            else if (bytes==null)
+            {
+                n++;
+                continue;
+            }
+            
+            if (bytes==null)
+            {
+                bytes=new byte[length];
+                for (int j=0;j<n;j++)
+                    bytes[j]=_raw[_path+j];
+            }
+            
+            bytes[n++]=b;
+        }
+
+        if (bytes==null)
+            return toUtf8String(_path,length);
+
+        _utf8b.reset();
+        _utf8b.append(bytes,0,n);
+        return _utf8b.toString();
     }
     
     public String getPathAndParam()
     {
         if (_path==_query)
             return null;
-        return StringUtil.toString(_raw,_path,_query-_path,URIUtil.__CHARSET);
+        return toUtf8String(_path,_query-_path);
     }
     
     public String getCompletePath()
     {
         if (_path==_end)
             return null;
-        return StringUtil.toString(_raw,_path,_end-_path,URIUtil.__CHARSET);
+        return toUtf8String(_path,_end-_path);
     }
     
     public String getParam()
     {
         if (_param==_query)
             return null;
-        return StringUtil.toString(_raw,_param+1,_query-_param-1,URIUtil.__CHARSET);
+        return toUtf8String(_param+1,_query-_param-1);
     }
     
     public String getQuery()
     {
         if (_query==_fragment)
             return null;
-        return StringUtil.toString(_raw,_query+1,_fragment-_query-1,URIUtil.__CHARSET);
+        return toUtf8String(_query+1,_fragment-_query-1);
     }
     
     public String getQuery(String encoding)
     {
         if (_query==_fragment)
             return null;
-        return StringUtil.toString(_raw,_query+1,_fragment-_query-1,encoding==null?URIUtil.__CHARSET:encoding);
+        return StringUtil.toString(_raw,_query+1,_fragment-_query-1,encoding);
     }
     
+    public boolean hasQuery()
+    {
+        return (_fragment>_query);
+    }
+    
     public String getFragment()
     {
         if (_fragment==_end)
             return null;
-        return new String(_raw,_fragment+1,_end-_fragment-1);
+        return toUtf8String(_fragment+1,_end-_fragment-1);
     }
 
+    public void decodeQueryTo(MultiMap parameters) 
+    {
+        if (_query==_fragment)
+            return;
+        _utf8b.reset();
+        UrlEncoded.decodeUtf8To(_raw,_query+1,_fragment-_query-1,parameters,_utf8b);
+    }
+
     public void decodeQueryTo(MultiMap parameters, String encoding) 
         throws UnsupportedEncodingException
     {
         if (_query==_fragment)
             return;
        
-        if (encoding==null)
-            encoding=URIUtil.__CHARSET;
-        
-        if (StringUtil.isUTF8(encoding))
+        if (encoding==null || StringUtil.isUTF8(encoding))
             UrlEncoded.decodeUtf8To(_raw,_query+1,_fragment-_query-1,parameters);
         else
-            UrlEncoded.decodeTo(StringUtil.toString(_raw,_query+1,_fragment-_query-1,encoding),parameters,encoding);
+            UrlEncoded.decodeTo(toUtf8String(_query+1,_fragment-_query-1),parameters,encoding);
     }
 
     public void clear()
@@ -462,8 +574,13 @@
     public String toString()
     {
         if (_rawString==null)
-            _rawString=new String(_raw,_scheme,_end-_scheme);
+            _rawString=toUtf8String(_scheme,_end-_scheme);
         return _rawString;
     }
     
+    public void writeTo(Utf8StringBuffer buf)
+    {
+        buf.append(_raw,_scheme,_end-_scheme);
+    }
+    
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/LocalConnector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/LocalConnector.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/LocalConnector.java	(working copy)
@@ -120,6 +120,34 @@
         _out=_endp.getOut();
         return _out.toString();
     }
+    
+    /* ------------------------------------------------------------ */
+    public ByteArrayBuffer getResponses(ByteArrayBuffer buf, boolean keepOpen)
+    throws Exception
+    {
+        if (_in.space()<buf.length())
+        {
+            ByteArrayBuffer n = new ByteArrayBuffer(_in.length()+buf.length());
+            n.put(_in);
+            _in=n;
+            _endp.setIn(_in);
+        }
+        _in.put(buf);
+        
+        synchronized (this)
+        {
+            _keepOpen=keepOpen;
+            _accepting=true;
+            this.notify();
+            
+            while(_accepting)
+                this.wait();
+        }
+        
+        // System.err.println("\nRESPONSES:\n"+out);
+        _out=_endp.getOut();
+        return _out;
+    }
 
     /* ------------------------------------------------------------ */
     protected Buffer newBuffer(int size)
Index: modules/jetty/src/main/java/org/mortbay/jetty/nio/SelectChannelConnector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/nio/SelectChannelConnector.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/nio/SelectChannelConnector.java	(working copy)
@@ -63,7 +63,7 @@
  */
 public class SelectChannelConnector extends AbstractNIOConnector 
 {
-    private transient ServerSocketChannel _acceptChannel;
+    protected transient ServerSocketChannel _acceptChannel;
     private long _lowResourcesConnections;
     private long _lowResourcesMaxIdleTime;
 
@@ -125,21 +125,25 @@
     }
     
     /* ------------------------------------------------------------ */
-    public void stopAccept(int acceptorID) throws Exception
-    {
-        _manager.doStop(acceptorID);
-    }
-    
-    /* ------------------------------------------------------------ */
     public void close() throws IOException
     {
         synchronized(this)
         {
+            if(_manager.isRunning())
+            {
+                try
+                {
+                    _manager.stop();
+                }
+                catch (Exception e)
+                {
+                    Log.warn(e);
+                }
+            }
             if (_acceptChannel != null)
                 _acceptChannel.close();
             _acceptChannel = null;
         }
-
     }
     
     /* ------------------------------------------------------------------------------- */
@@ -207,11 +211,13 @@
                 _acceptChannel = ServerSocketChannel.open();
 
                 // Bind the server socket to the local host and port
+                _acceptChannel.socket().setReuseAddress(getReuseAddress());
                 InetSocketAddress addr = getHost()==null?new InetSocketAddress(getPort()):new InetSocketAddress(getHost(),getPort());
                 _acceptChannel.socket().bind(addr,getAcceptQueueSize());
 
                 // Set to non blocking mode
                 _acceptChannel.configureBlocking(false);
+                
             }
         }
     }
@@ -316,8 +322,7 @@
      * @see org.mortbay.jetty.AbstractConnector#doStop()
      */
     protected void doStop() throws Exception
-    {
-        _manager.stop();
+    {        
         super.doStop();
     }
 
@@ -346,9 +351,13 @@
 
         public void close() throws IOException
         {
-            RetryContinuation continuation = (RetryContinuation) ((HttpConnection)getConnection()).getRequest().getContinuation();
-            if (continuation != null && continuation.isPending())
-                continuation.reset();
+            Connection con=getConnection();
+            if (con instanceof HttpConnection)
+            {
+                RetryContinuation continuation = (RetryContinuation) ((HttpConnection)getConnection()).getRequest().getContinuation();
+                if (continuation != null && continuation.isPending())
+                    continuation.reset();
+            }
 
             super.close();
         }
@@ -356,20 +365,25 @@
         /* ------------------------------------------------------------ */
         public void undispatch()
         {
-            RetryContinuation continuation = (RetryContinuation) ((HttpConnection)getConnection()).getRequest().getContinuation();
+            Connection con=getConnection();
+            if (con instanceof HttpConnection)
+            {
+                RetryContinuation continuation = (RetryContinuation) ((HttpConnection)getConnection()).getRequest().getContinuation();
 
-            if (continuation != null)
-            {
-                // We have a continuation
-                Log.debug("continuation {}", continuation);
-                if (continuation.undispatch())
+                if (continuation != null)
+                {
+                    // We have a continuation
+                    Log.debug("continuation {}", continuation);
+                    if (continuation.undispatch())
+                        super.undispatch();
+                }
+                else
+                {
                     super.undispatch();
+                }
             }
             else
-            {
                 super.undispatch();
-            }
-               
         }
     }
 
Index: modules/jetty/src/main/java/org/mortbay/jetty/nio/AbstractNIOConnector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/nio/AbstractNIOConnector.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/nio/AbstractNIOConnector.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 /**
  * 
  */
@@ -4,6 +18,8 @@
 package org.mortbay.jetty.nio;
 
 import org.mortbay.io.Buffer;
+import org.mortbay.io.nio.DirectNIOBuffer;
+import org.mortbay.io.nio.IndirectNIOBuffer;
 import org.mortbay.io.nio.NIOBuffer;
 import org.mortbay.jetty.AbstractConnector;
 
@@ -50,9 +66,11 @@
         // 
         Buffer buf = null;
         if (size==getHeaderBufferSize())
-            buf= new NIOBuffer(size, NIOBuffer.INDIRECT);
+            buf= new IndirectNIOBuffer(size);
         else
-            buf = new NIOBuffer(size, _useDirectBuffers?NIOBuffer.DIRECT:NIOBuffer.INDIRECT);
+            buf = _useDirectBuffers
+                ?(NIOBuffer)new DirectNIOBuffer(size)
+                :(NIOBuffer)new IndirectNIOBuffer(size);
         return buf;
     }
     
Index: modules/jetty/src/main/java/org/mortbay/jetty/nio/BlockingChannelConnector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/nio/BlockingChannelConnector.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/nio/BlockingChannelConnector.java	(working copy)
@@ -21,7 +21,6 @@
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
 
-import org.mortbay.io.Buffer;
 import org.mortbay.io.EndPoint;
 import org.mortbay.io.nio.ChannelEndPoint;
 import org.mortbay.jetty.EofException;
@@ -154,9 +153,10 @@
                     {
                         if (getServer().getThreadPool().isLowOnThreads())
                         {
-                            if (_sotimeout!=getLowResourceMaxIdleTime())
+                            int lrmit = getLowResourceMaxIdleTime();
+                            if (lrmit>=0 && _sotimeout!= lrmit)
                             {
-                                _sotimeout=getLowResourceMaxIdleTime();
+                                _sotimeout=lrmit;
                                 ((SocketChannel)getTransport()).socket().setSoTimeout(_sotimeout);
                             }
                         }
Index: modules/jetty/src/main/java/org/mortbay/jetty/Server.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/Server.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/Server.java	(working copy)
@@ -1,5 +1,5 @@
 // ========================================================================
-// Copyright 2004-2005 Mort Bay Consulting Pty. Ltd.
+// Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
 // ------------------------------------------------------------------------
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -32,7 +32,7 @@
 import org.mortbay.jetty.handler.HandlerWrapper;
 import org.mortbay.jetty.security.UserRealm;
 import org.mortbay.log.Log;
-import org.mortbay.thread.BoundedThreadPool;
+import org.mortbay.thread.QueuedThreadPool;
 import org.mortbay.thread.ThreadPool;
 import org.mortbay.util.Attributes;
 import org.mortbay.util.AttributesMap;
@@ -50,10 +50,12 @@
  */
 public class Server extends HandlerWrapper implements Attributes
 {
+    public final static String UNKNOWN_VERSION="6.1.x";
+    public final static String SNAPSHOT_VERSION="6.1-SNAPSHOT";
     private static ShutdownHookThread hookThread = new ShutdownHookThread();
     private static String _version = (Server.class.getPackage()!=null && Server.class.getPackage().getImplementationVersion()!=null)
         ?Server.class.getPackage().getImplementationVersion()
-        :"6.1.x";
+        :UNKNOWN_VERSION;
 
     private ThreadPool _threadPool;
     private Connector[] _connectors;
@@ -185,6 +187,11 @@
         HttpGenerator.setServerVersion(_version);
         MultiException mex=new MultiException();
       
+        for (int i=0;_realms !=null && i<_realms.length; i++)
+        {
+            if (_realms[i] instanceof LifeCycle)
+                ((LifeCycle)_realms[i]).start();
+        }
 
         Iterator itor = _dependentLifeCycles.iterator();
         while (itor.hasNext())
@@ -198,8 +205,8 @@
         
         if (_threadPool==null)
         {
-            BoundedThreadPool btp=new BoundedThreadPool();
-            setThreadPool(btp);
+            QueuedThreadPool tp=new QueuedThreadPool();
+            setThreadPool(tp);
         }
         
         if (_sessionIdManager!=null)
@@ -240,6 +247,12 @@
     {
         MultiException mex=new MultiException();
         
+        for (int i=0;_realms !=null && i<_realms.length; i++)
+        {
+            if (_realms[i] instanceof LifeCycle)
+                ((LifeCycle)_realms[i]).stop();
+        }
+        
         if (_graceful>0)
         {
             if (_connectors!=null)
Index: modules/jetty/src/main/java/org/mortbay/jetty/HttpHeaderValues.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/HttpHeaderValues.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/HttpHeaderValues.java	(working copy)
@@ -14,10 +14,20 @@
 
 package org.mortbay.jetty;
 
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.LineNumberReader;
+
 import org.mortbay.io.Buffer;
 import org.mortbay.io.BufferCache;
+import org.mortbay.io.ByteArrayBuffer;
+import org.mortbay.log.Log;
 
 /**
+ * Cached HTTP Header values.
+ * This class caches the conversion of common HTTP Header values to and from {@link ByteArrayBuffer} instances.
+ * The resource "/org/mortbay/jetty/useragents" is checked for a list of common user agents, so that repeated
+ * creation of strings for these agents can be avoided.
  * 
  * @author gregw
  */
@@ -31,7 +41,9 @@
         KEEP_ALIVE="keep-alive",
         CONTINUE="100-continue",
         PROCESSING="102-processing",
-        TE="TE";
+        TE="TE",
+        BYTES="bytes",
+        NO_CACHE="no-cache";
 
     public final static int
         CLOSE_ORDINAL=1,
@@ -41,7 +53,9 @@
         KEEP_ALIVE_ORDINAL=5,
         CONTINUE_ORDINAL=6,
         PROCESSING_ORDINAL=7,
-        TE_ORDINAL=8;
+        TE_ORDINAL=8,
+        BYTES_ORDINAL=9,
+        NO_CACHE_ORDINAL=10;
     
     public final static HttpHeaderValues CACHE= new HttpHeaderValues();
 
@@ -53,7 +67,9 @@
         KEEP_ALIVE_BUFFER=CACHE.add(KEEP_ALIVE,KEEP_ALIVE_ORDINAL),
         CONTINUE_BUFFER=CACHE.add(CONTINUE, CONTINUE_ORDINAL),
         PROCESSING_BUFFER=CACHE.add(PROCESSING, PROCESSING_ORDINAL),
-        TE_BUFFER=CACHE.add(TE,TE_ORDINAL);
+        TE_BUFFER=CACHE.add(TE,TE_ORDINAL),
+        BYTES_BUFFER=CACHE.add(BYTES,BYTES_ORDINAL),
+        NO_CACHE_BUFFER=CACHE.add(NO_CACHE,NO_CACHE_ORDINAL);
         
     static
     {  
@@ -61,13 +77,25 @@
         CACHE.add("gzip",index++);
         CACHE.add("gzip,deflate",index++);
         CACHE.add("deflate",index++);
-        CACHE.add("Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)",index++);
-        CACHE.add("Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)",index++);
-        CACHE.add("Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.7) Gecko/20060909 Firefox/1.5.0.7",index++);
-        CACHE.add("Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)",index++);
-        CACHE.add("Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)",index++);
-        CACHE.add("Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)",index++);
-        CACHE.add("Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061010 Firefox/2.0",index++);
-        CACHE.add("msnbot/1.0 (+http://search.msn.com/msnbot.htm)",index++);
+        
+        try
+        {
+            InputStream ua = HttpHeaderValues.class.getResourceAsStream("/org/mortbay/jetty/useragents");
+            if (ua!=null)
+            {
+                LineNumberReader in = new LineNumberReader(new InputStreamReader(ua));
+                String line = in.readLine();
+                while (line!=null)
+                {
+                    CACHE.add(line,index++);
+                    line = in.readLine();
+                }
+            }
+        }
+        catch(Exception e)
+        {
+            e.printStackTrace();
+            Log.ignore(e);
+        }
     }
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/AbstractGenerator.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/AbstractGenerator.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/AbstractGenerator.java	(working copy)
@@ -361,8 +361,10 @@
             for (int i=0;i<len;i++)
             {
                 char ch = reason.charAt(i);
-                if (ch==' ' || Character.isJavaIdentifierPart(ch))
+                if (ch!='\r'&&ch!='\n')
                     _reason.put((byte)ch);
+                else
+                    _reason.put((byte)' ');
             }
         }
     }
@@ -401,12 +403,14 @@
     /* ------------------------------------------------------------ */
     public boolean isBufferFull()
     {
-        // Should we flush the buffers?
-        boolean full =  
-            (_buffer != null && _buffer.space() == 0) ||
-            (_content!=null && _content.length()>0);
-             
-        return full;
+        if (_buffer != null && _buffer.space()==0)
+        {
+            if (_buffer.length()==0 && !_buffer.isImmutable())
+                _buffer.compact();
+            return _buffer.space()==0;
+        }
+
+        return _content!=null && _content.length()>0;
     }
     
     /* ------------------------------------------------------------ */
@@ -559,7 +563,7 @@
             // block until everything is flushed
             Buffer content = _generator._content;
             Buffer buffer = _generator._buffer;
-            if (content!=null && content.length()>0 ||buffer!=null && buffer.length()>0)
+            if (content!=null && content.length()>0 || buffer!=null && buffer.length()>0 || _generator.isBufferFull())
             {
                 _generator.flush();
                 
@@ -591,15 +595,19 @@
          */
         public void write(int b) throws IOException
         {
-            if (_closed || !_generator._endp.isOpen())
+            if (_closed)
                 throw new IOException("Closed");
+            if (!_generator._endp.isOpen())
+                throw new EofException();
             
             // Block until we can add _content.
             while (_generator.isBufferFull())
             {
                 blockForOutput();
-                if (_closed || !_generator._endp.isOpen())
+                if (_closed)
                     throw new IOException("Closed");
+                if (!_generator._endp.isOpen())
+                    throw new EofException();
             }
 
             // Add the _content
@@ -617,15 +625,19 @@
         /* ------------------------------------------------------------ */
         private void write(Buffer buffer) throws IOException
         {
-            if (_closed || !_generator._endp.isOpen())
+            if (_closed)
                 throw new IOException("Closed");
+            if (!_generator._endp.isOpen())
+                throw new EofException();
             
             // Block until we can add _content.
             while (_generator.isBufferFull())
             {
                 blockForOutput();
-                if (_closed || !_generator._endp.isOpen())
+                if (_closed)
                     throw new IOException("Closed");
+                if (!_generator._endp.isOpen())
+                    throw new EofException();
             }
 
             // Add the _content
@@ -794,92 +806,90 @@
                             if ((code & 0xffffff80) == 0) 
                             {
                                 // 1b
-                                buffer[bytes++]=(byte)(code);
-                            }
-                            else if((code&0xfffff800)==0)
-                            {
-                                // 2b
-                                if (bytes+2>buffer.length)
+                                if (bytes+1>buffer.length)
                                 {
                                     chars=i;
                                     break;
                                 }
-                                buffer[bytes++]=(byte)(0xc0|(code>>6));
-                                buffer[bytes++]=(byte)(0x80|(code&0x3f));
-
-                                if (bytes+chars-i-1>buffer.length)
-                                    chars-=1;
+                                buffer[bytes++]=(byte)(code);
                             }
-                            else if((code&0xffff0000)==0)
-                            {
-                                // 3b
-                                if (bytes+3>buffer.length)
-                                {
-                                    chars=i;
-                                    break;
-                                }
-                                buffer[bytes++]=(byte)(0xe0|(code>>12));
-                                buffer[bytes++]=(byte)(0x80|((code>>6)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|(code&0x3f));
-
-                                if (bytes+chars-i-1>buffer.length)
-                                    chars-=2;
-                            }
-                            else if((code&0xff200000)==0)
-                            {
-                                // 4b
-                                if (bytes+4>buffer.length)
-                                {
-                                    chars=i;
-                                    break;
-                                }
-                                buffer[bytes++]=(byte)(0xf0|(code>>18));
-                                buffer[bytes++]=(byte)(0x80|((code>>12)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|((code>>6)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|(code&0x3f));
-
-                                if (bytes+chars-i-1>buffer.length)
-                                    chars-=3;
-                            }
-                            else if((code&0xf4000000)==0)
-                            {
-                                // 5b
-                                if (bytes+5>buffer.length)
-                                {
-                                    chars=i;
-                                    break;
-                                }
-                                buffer[bytes++]=(byte)(0xf8|(code>>24));
-                                buffer[bytes++]=(byte)(0x80|((code>>18)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|((code>>12)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|((code>>6)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|(code&0x3f));
-
-                                if (bytes+chars-i-1>buffer.length)
-                                    chars-=4;
-                            }
-                            else if((code&0x80000000)==0)
-                            {
-                                // 6b
-                                if (bytes+6>buffer.length)
-                                {
-                                    chars=i;
-                                    break;
-                                }
-                                buffer[bytes++]=(byte)(0xfc|(code>>30));
-                                buffer[bytes++]=(byte)(0x80|((code>>24)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|((code>>18)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|((code>>12)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|((code>>6)&0x3f));
-                                buffer[bytes++]=(byte)(0x80|(code&0x3f));
-
-                                if (bytes+chars-i-1>buffer.length)
-                                    chars-=5;
-                            }
                             else
-                            {
-                                buffer[bytes++]=(byte)('?');
-                            }
+			    {
+				if((code&0xfffff800)==0)
+				{
+				    // 2b
+				    if (bytes+2>buffer.length)
+				    {
+					chars=i;
+					break;
+				    }
+				    buffer[bytes++]=(byte)(0xc0|(code>>6));
+				    buffer[bytes++]=(byte)(0x80|(code&0x3f));
+				}
+				else if((code&0xffff0000)==0)
+				{
+				    // 3b
+				    if (bytes+3>buffer.length)
+				    {
+					chars=i;
+					break;
+				    }
+				    buffer[bytes++]=(byte)(0xe0|(code>>12));
+				    buffer[bytes++]=(byte)(0x80|((code>>6)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|(code&0x3f));
+				}
+				else if((code&0xff200000)==0)
+				{
+				    // 4b
+				    if (bytes+4>buffer.length)
+				    {
+					chars=i;
+					break;
+				    }
+				    buffer[bytes++]=(byte)(0xf0|(code>>18));
+				    buffer[bytes++]=(byte)(0x80|((code>>12)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|((code>>6)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|(code&0x3f));
+				}
+				else if((code&0xf4000000)==0)
+				{
+				    // 5b
+				    if (bytes+5>buffer.length)
+				    {
+					chars=i;
+					break;
+				    }
+				    buffer[bytes++]=(byte)(0xf8|(code>>24));
+				    buffer[bytes++]=(byte)(0x80|((code>>18)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|((code>>12)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|((code>>6)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|(code&0x3f));
+				}
+				else if((code&0x80000000)==0)
+				{
+				    // 6b
+				    if (bytes+6>buffer.length)
+				    {
+					chars=i;
+					break;
+				    }
+				    buffer[bytes++]=(byte)(0xfc|(code>>30));
+				    buffer[bytes++]=(byte)(0x80|((code>>24)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|((code>>18)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|((code>>12)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|((code>>6)&0x3f));
+				    buffer[bytes++]=(byte)(0x80|(code&0x3f));
+				}
+				else
+				{
+				    buffer[bytes++]=(byte)('?');
+				}
+				if (bytes==buffer.length)
+				{
+				    chars=i+1;
+				    break;
+				}
+			    }
                         }
                         out._bytes.setCount(bytes);
                         break;
Index: modules/jetty/src/main/java/org/mortbay/jetty/ResourceCache.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/ResourceCache.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/ResourceCache.java	(working copy)
@@ -17,14 +17,15 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.Serializable;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.Map;
 
 import org.mortbay.component.AbstractLifeCycle;
 import org.mortbay.io.Buffer;
 import org.mortbay.io.ByteArrayBuffer;
 import org.mortbay.io.View;
-import org.mortbay.log.Log;
 import org.mortbay.resource.Resource;
 import org.mortbay.resource.ResourceFactory;
 
@@ -119,6 +120,14 @@
         {
             synchronized(this)
             {
+                ArrayList values=new ArrayList(_cache.values());
+                Iterator iter = values.iterator();
+                while(iter.hasNext())
+                {
+                    Content content = (Content)iter.next();
+                    content.invalidate();
+                }
+                
                 _cache.clear();
                 _cachedSize=0;
                 _cachedFiles=0;
@@ -368,6 +377,8 @@
                 
                 _prev=null;
                 _next=null;
+                if (_resource!=null)
+                    _resource.release();
                 _resource=null;
                 
             }
Index: modules/jetty/src/main/java/org/mortbay/jetty/AbstractBuffers.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/AbstractBuffers.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/AbstractBuffers.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.jetty;
 
 import java.util.ArrayList;
@@ -14,19 +28,105 @@
  */
 public abstract class AbstractBuffers extends AbstractLifeCycle implements Buffers
 {
-    protected static int BUFFER_LOSS_RATE=256; // Leak buffers to shrink pools
-    
     private int _headerBufferSize=4*1024;
     private int _requestBufferSize=8*1024;
     private int _responseBufferSize=24*1024;
 
-    // Use and array of buffers to avoid contention
-    private transient ArrayList _headerBuffers=new ArrayList();
-    protected transient int _loss;
-    private transient ArrayList _requestBuffers;
-    private transient ArrayList _responseBuffers;
+    final static private int __HEADER=0;
+    final static private int __REQUEST=1;
+    final static private int __RESPONSE=2;
+    final static private int __OTHER=3;
+    final private int[] _pool={2,1,1,2};
 
-    /* ------------------------------------------------------------ */
+    private final ThreadLocal _buffers=new ThreadLocal()
+    {
+        protected Object initialValue()
+        {
+            return new ThreadBuffers(_pool[__HEADER],_pool[__REQUEST],_pool[__RESPONSE],_pool[__OTHER]);
+        }
+    };
+   
+    public AbstractBuffers()
+    {
+        super();
+    }
+
+
+
+    public Buffer getBuffer(final int size )
+    {
+        final int set = (size==_headerBufferSize)?__HEADER
+                :(size==_responseBufferSize)?__RESPONSE
+                        :(size==_requestBufferSize)?__REQUEST:__OTHER;
+
+        final ThreadBuffers thread_buffers = (ThreadBuffers)_buffers.get();
+
+        final Buffer[] buffers=thread_buffers._buffers[set];
+        for (int i=0;i<buffers.length;i++)
+        {
+            final Buffer b=buffers[i];
+            if (b!=null && b.capacity()==size)
+            {
+                buffers[i]=null;
+                return b;
+            }
+        }
+
+        return newBuffer(size);
+    }
+
+    public void returnBuffer( Buffer buffer )
+    {
+        buffer.clear();
+        if (buffer.isVolatile() || buffer.isImmutable())
+            return;
+
+        int size=buffer.capacity();
+        final int set = (size==_headerBufferSize)?__HEADER
+                :(size==_responseBufferSize)?__RESPONSE
+                        :(size==_requestBufferSize)?__REQUEST:__OTHER;
+        
+        final ThreadBuffers thread_buffers = (ThreadBuffers)_buffers.get();
+        final Buffer[] buffers=thread_buffers._buffers[set];
+        for (int i=0;i<buffers.length;i++)
+        {
+            if (buffers[i]==null)
+            {
+                buffers[i]=buffer;
+                return;
+            }
+        }
+
+    }
+
+    protected void doStart()
+        throws Exception
+    {
+        super.doStart();
+        if (_headerBufferSize==_requestBufferSize && _headerBufferSize==_responseBufferSize)
+        {
+            _pool[__HEADER]+=_pool[__REQUEST]+_pool[__RESPONSE];
+            _pool[__REQUEST]=0;
+            _pool[__RESPONSE]=0;
+        }
+        else if (_headerBufferSize==_requestBufferSize)
+        {
+            _pool[__HEADER]+=_pool[__REQUEST];
+            _pool[__REQUEST]=0;
+        }
+        else if (_headerBufferSize==_responseBufferSize)
+        {
+            _pool[__HEADER]+=_pool[__RESPONSE];
+            _pool[__RESPONSE]=0;
+        }
+        else if (_requestBufferSize==_responseBufferSize)
+        {
+            _pool[__RESPONSE]+=_pool[__REQUEST];
+            _pool[__REQUEST]=0;
+        }
+
+    }
+
     /**
      * @return Returns the headerBufferSize.
      */
@@ -34,17 +134,17 @@
     {
         return _headerBufferSize;
     }
-    
-    /* ------------------------------------------------------------ */
+
     /**
      * @param headerBufferSize The headerBufferSize to set.
      */
-    public void setHeaderBufferSize(int headerBufferSize)
+    public void setHeaderBufferSize( int headerBufferSize )
     {
+        if (isStarted())
+            throw new IllegalStateException();
         _headerBufferSize = headerBufferSize;
     }
-    
-    /* ------------------------------------------------------------ */
+
     /**
      * @return Returns the requestBufferSize.
      */
@@ -52,17 +152,17 @@
     {
         return _requestBufferSize;
     }
-    
-    /* ------------------------------------------------------------ */
+
     /**
      * @param requestBufferSize The requestBufferSize to set.
      */
-    public void setRequestBufferSize(int requestBufferSize)
+    public void setRequestBufferSize( int requestBufferSize )
     {
+        if (isStarted())
+          throw new IllegalStateException();
         _requestBufferSize = requestBufferSize;
     }
-    
-    /* ------------------------------------------------------------ */
+
     /**
      * @return Returns the responseBufferSize.
      */
@@ -70,114 +170,35 @@
     {
         return _responseBufferSize;
     }
-    
-    /* ------------------------------------------------------------ */
+
     /**
      * @param responseBufferSize The responseBufferSize to set.
      */
-    public void setResponseBufferSize(int responseBufferSize)
+    public void setResponseBufferSize( int responseBufferSize )
     {
+        if (isStarted())
+            throw new IllegalStateException();
         _responseBufferSize = responseBufferSize;
     }
-
     
-    /* ------------------------------------------------------------ */
-    protected abstract Buffer newBuffer(int size);
+    protected abstract Buffer newBuffer( int size );
 
-    
-    /* ------------------------------------------------------------ */
-    public Buffer getBuffer(int size)
+    protected static class ThreadBuffers
     {
-        if (size==_headerBufferSize)
-        {   
-            synchronized(_headerBuffers)
-            {
-                if (_headerBuffers.size()>0)
-                    return (Buffer) _headerBuffers.remove(_headerBuffers.size()-1);
-            }
-            return newBuffer(size);
-        }
-        else if (size==_responseBufferSize)
+        final Buffer[][] _buffers;
+        ThreadBuffers(int headers,int requests,int responses,int others)
         {
-            synchronized(_responseBuffers)
-            {
-                if (_responseBuffers.size()==0)
-                    return newBuffer(size);
-                return (Buffer) _responseBuffers.remove(_responseBuffers.size()-1);
-            }
-        }
-        else if (size==_requestBufferSize)
-        {
-            synchronized(_requestBuffers)
-            {
-                if (_requestBuffers.size()==0)
-                    return newBuffer(size);
-                return (Buffer) _requestBuffers.remove(_requestBuffers.size()-1);
-            }   
-        }
-        
-        return newBuffer(size);    
-    }
+            _buffers = new Buffer[4][];
+            _buffers[__HEADER]=new Buffer[headers];
+            _buffers[__REQUEST]=new Buffer[requests];
+            _buffers[__RESPONSE]=new Buffer[responses];
+            _buffers[__OTHER]=new Buffer[others];
 
-
-    /* ------------------------------------------------------------ */
-    public void returnBuffer(Buffer buffer)
-    {
-        buffer.clear();
-        if (_loss++>BUFFER_LOSS_RATE)
-        {
-            _loss=0;
-            return;
         }
-
-        buffer.clear();
-        if (!buffer.isVolatile() && !buffer.isImmutable())
-        {
-            int c=buffer.capacity();
-            if (c==_headerBufferSize)
-            {
-                synchronized(_headerBuffers)
-                {
-                    _headerBuffers.add(buffer);
-                }
-            }
-            else if (c==_responseBufferSize)
-            {
-                synchronized(_responseBuffers)
-                {
-                    _responseBuffers.add(buffer);
-                }
-            }
-            else if (c==_requestBufferSize)
-            {
-                synchronized(_requestBuffers)
-                {
-                    _requestBuffers.add(buffer);
-                }
-            }
-        }
     }
-
-    /* ------------------------------------------------------------ */
-    protected void doStart() throws Exception
+    
+    public String toString()
     {
-        super.doStart();
-
-        if (_headerBuffers!=null)
-            _headerBuffers.clear();
-        else
-            _headerBuffers=new ArrayList();
-
-        if (_requestBuffers!=null)
-            _requestBuffers.clear();
-        else
-            _requestBuffers=new ArrayList();
-        
-        if (_responseBuffers!=null)
-            _responseBuffers.clear();
-        else
-            _responseBuffers=new ArrayList(); 
+        return "{{"+_headerBufferSize+","+_requestBufferSize+","+_responseBufferSize+"}}";
     }
-    
-    
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/HandlerContainer.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/HandlerContainer.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/HandlerContainer.java	(working copy)
@@ -19,6 +19,7 @@
 public interface HandlerContainer extends LifeCycle
 {
     public void addHandler(Handler handler);
+    public void removeHandler(Handler handler);
 
     public Handler[] getChildHandlers();
     public Handler[] getChildHandlersByClass(Class byclass);
Index: modules/jetty/src/main/java/org/mortbay/jetty/Main.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/Main.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/Main.java	(working copy)
@@ -81,10 +81,9 @@
             else if ("-webapp".equals(args[1]))
             {
                 WebAppContext webapp = new WebAppContext();
-                webapp.setResourceBase(args[2]);
+                webapp.setWar(args[2]);
                 webapp.setContextPath(URIUtil.SLASH);
                 contexts.addHandler(webapp);
-                
             }
                 
             server.start();
Index: modules/jetty/src/main/java/org/mortbay/jetty/HttpGenerator.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/HttpGenerator.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/HttpGenerator.java	(working copy)
@@ -103,10 +103,7 @@
     public void addContent(Buffer content, boolean last) throws IOException
     {
         if (_noContent)
-        {
-            content.clear();
-            return;
-        }
+            throw new IllegalStateException("NO CONTENT");
 
         if (_last || _state==STATE_END) 
         {
@@ -154,9 +151,31 @@
                 _content = null;
         }
     }
-    
+
     /* ------------------------------------------------------------ */
     /**
+     * send complete response.
+     * 
+     * @param response
+     */
+    public void sendResponse(Buffer response) throws IOException
+    {
+        if (_noContent || _state!=STATE_HEADER || _content!=null && _content.length()>0 || _bufferChunked || _head )
+            throw new IllegalStateException();
+
+        _last = true;
+
+        _content = response;
+        _bypass = true;
+        _state = STATE_FLUSHING;
+
+        // TODO this is not exactly right, but should do.
+        _contentLength =_contentWritten = response.length();
+        
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
      * Add content.
      * 
      * @param b byte
@@ -166,7 +185,7 @@
     public boolean addContent(byte b) throws IOException
     {
         if (_noContent)
-            return false;
+            throw new IllegalStateException("NO CONTENT");
         
         if (_last || _state==STATE_END) 
         {
@@ -404,6 +423,8 @@
                         break;
 
                     case HttpHeaders.CONNECTION_ORDINAL:
+                        if (_method!=null)
+                            field.put(_header);
                         
                         int connection_value = field.getValueOrdinal();
                         switch (connection_value)
@@ -424,7 +445,7 @@
                                                 if (_method==null)
                                                     _close=true;
                                                 keep_alive=false;
-                                                if (_close && _contentLength == HttpTokens.UNKNOWN_CONTENT) 
+                                                if (_close && _method==null && _contentLength == HttpTokens.UNKNOWN_CONTENT) 
                                                     _contentLength = HttpTokens.EOF_CONTENT;
                                                 break;
 
@@ -462,7 +483,7 @@
                                 close=true;
                                 if (_method==null)
                                     _close=true;
-                                if (_close && _contentLength == HttpTokens.UNKNOWN_CONTENT) 
+                                if (_close && _method==null && _contentLength == HttpTokens.UNKNOWN_CONTENT) 
                                     _contentLength = HttpTokens.EOF_CONTENT;
                                 break;
                             }
@@ -520,7 +541,7 @@
                 // written yet?
 
                 // Response known not to have a body
-                if (_contentWritten == 0 && (_status < 200 || _status == 204 || _status == 304))
+                if (_contentWritten == 0 && _method==null && (_status < 200 || _status == 204 || _status == 304))
                     _contentLength = HttpTokens.NO_CONTENT;
                 else if (_last)
                 {
@@ -541,12 +562,16 @@
                     // No idea, so we must assume that a body is coming
                     _contentLength = (_close || _version < HttpVersions.HTTP_1_1_ORDINAL ) ? HttpTokens.EOF_CONTENT : HttpTokens.CHUNKED_CONTENT;
                     if (_method!=null && _contentLength==HttpTokens.EOF_CONTENT)
-                        throw new IllegalStateException("No Content-Length");
+                    {
+                        _contentLength=HttpTokens.NO_CONTENT;
+                        _noContent=true;
+                    }
                 }
                 break;
 
             case HttpTokens.NO_CONTENT:
-                if (content_length == null && _status >= 200 && _status != 204 && _status != 304) _header.put(CONTENT_LENGTH_0);
+                if (content_length == null && _method==null && _status >= 200 && _status != 204 && _status != 304) 
+                    _header.put(CONTENT_LENGTH_0);
                 break;
 
             case HttpTokens.EOF_CONTENT:
@@ -583,35 +608,38 @@
             keep_alive=false;
             _close=true;
         }
-                
-        if (_close && (close || _version > HttpVersions.HTTP_1_0_ORDINAL))
+               
+        if (_method==null)
         {
-            _header.put(CONNECTION_CLOSE);
-            if (connection!=null)
+            if (_close && (close || _version > HttpVersions.HTTP_1_0_ORDINAL))
             {
-                _header.setPutIndex(_header.putIndex()-2);
-                _header.put((byte)',');
-                _header.put(connection.toString().getBytes());
-                _header.put(CRLF);
+                _header.put(CONNECTION_CLOSE);
+                if (connection!=null)
+                {
+                    _header.setPutIndex(_header.putIndex()-2);
+                    _header.put((byte)',');
+                    _header.put(connection.toString().getBytes());
+                    _header.put(CRLF);
+                }
             }
-        }
-        else if (keep_alive)
-        {
-            _header.put(CONNECTION_KEEP_ALIVE);
-            if (connection!=null)
+            else if (keep_alive)
             {
-                _header.setPutIndex(_header.putIndex()-2);
-                _header.put((byte)',');
+                _header.put(CONNECTION_KEEP_ALIVE);
+                if (connection!=null)
+                {
+                    _header.setPutIndex(_header.putIndex()-2);
+                    _header.put((byte)',');
+                    _header.put(connection.toString().getBytes());
+                    _header.put(CRLF);
+                }
+            }
+            else if (connection!=null)
+            {
+                _header.put(CONNECTION_);
                 _header.put(connection.toString().getBytes());
                 _header.put(CRLF);
             }
         }
-        else if (connection!=null)
-        {
-            _header.put(CONNECTION_);
-            _header.put(connection.toString().getBytes());
-            _header.put(CRLF);
-        }
         
         if (!has_server && _status>100 && getSendServerVersion())
             _header.put(SERVER);
@@ -741,15 +769,14 @@
                     }
                 }
                 
-                // If we failed to flush anything twice in a row break
-                if (len <= 0)
-                {
-                    if (last_len <= 0) 
-                        break Flushing;
-                    break;
-                }
+                
+                // break If we failed to flush
+                if (len > 0)
+                    total+=len;
+                else 
+                    break Flushing;
+          
                 last_len = len;
-                total+=len;
             }
             
             return total;
@@ -867,5 +894,25 @@
 
     }
 
+    public int getBytesBuffered()
+    {
+        return(_header==null?0:_header.length())+
+        (_buffer==null?0:_buffer.length())+
+        (_content==null?0:_content.length());
+    }
 
+    public boolean isEmpty()
+    {
+        return (_header==null||_header.length()==0) &&
+        (_buffer==null||_buffer.length()==0) &&
+        (_content==null||_content.length()==0);
+    }
+    
+    public String toString()
+    {
+        return "HttpGenerator s="+_state+
+        " h="+(_header==null?"null":(""+_header.length()))+
+        " b="+(_buffer==null?"null":(""+_buffer.length()))+
+        " c="+(_content==null?"null":(""+_content.length()));
+    }
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/HashUserRealm.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/HashUserRealm.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/HashUserRealm.java	(working copy)
@@ -14,9 +14,12 @@
 
 package org.mortbay.jetty.security;
 
+import java.io.File;
+import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.security.Principal;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -25,10 +28,13 @@
 import java.util.Properties;
 import java.util.StringTokenizer;
 
+import org.mortbay.component.AbstractLifeCycle;
 import org.mortbay.jetty.Request;
 import org.mortbay.jetty.Response;
 import org.mortbay.log.Log;
 import org.mortbay.resource.Resource;
+import org.mortbay.util.Scanner;
+import org.mortbay.util.Scanner.BulkListener;
 
 /* ------------------------------------------------------------ */
 /** HashMapped User Realm.
@@ -55,7 +61,7 @@
  * @see Password
  * @author Greg Wilkins (gregw)
  */
-public class HashUserRealm implements UserRealm, SSORealm
+public class HashUserRealm extends AbstractLifeCycle implements UserRealm, SSORealm
 {
 
     /** HttpContext Attribute to set to activate SSO.
@@ -65,11 +71,13 @@
     /* ------------------------------------------------------------ */
     private String _realmName;
     private String _config;
+    private Resource _configResource;
     protected HashMap _users=new HashMap();
     protected HashMap _roles=new HashMap(7);
     private SSORealm _ssoRealm;
+    private Scanner _scanner;
+    private int _refreshInterval=0;//default is not to reload
     
-    
 
     /* ------------------------------------------------------------ */
     /** Constructor. 
@@ -102,6 +110,11 @@
     {
         return _config;
     }
+    
+    public Resource getConfigResource()
+    {
+        return _configResource;
+    }
 
     /* ------------------------------------------------------------ */
     /** Load realm users from properties file.
@@ -115,39 +128,60 @@
         throws IOException
     {
         _config=config;
-        _users.clear();
-        _roles.clear();
-        
-        if(Log.isDebugEnabled())Log.debug("Load "+this+" from "+config);
-        Properties properties = new Properties();
-        Resource resource=Resource.newResource(config);
-        properties.load(resource.getInputStream());
+        _configResource=Resource.newResource(_config);
+       loadConfig();
+ 
+    }
+    
 
-        Iterator iter = properties.entrySet().iterator();
-        while(iter.hasNext())
+    public void setRefreshInterval (int msec)
+    {
+        _refreshInterval=msec;
+    }
+    
+    public int getRefreshInterval()
+    {
+        return _refreshInterval;
+    }
+    
+    protected void loadConfig () 
+    throws IOException
+    {
+        synchronized (this)
         {
-            Map.Entry entry = (Map.Entry)iter.next();
+            _users.clear();
+            _roles.clear();
+            
+            if(Log.isDebugEnabled())Log.debug("Load "+this+" from "+_config);
+            Properties properties = new Properties();
+            properties.load(_configResource.getInputStream());
 
-            String username=entry.getKey().toString().trim();
-            String credentials=entry.getValue().toString().trim();
-            String roles=null;
-            int c=credentials.indexOf(',');
-            if (c>0)
+            Iterator iter = properties.entrySet().iterator();
+            while(iter.hasNext())
             {
-                roles=credentials.substring(c+1).trim();
-                credentials=credentials.substring(0,c).trim();
-            }
+                Map.Entry entry = (Map.Entry)iter.next();
 
-            if (username!=null && username.length()>0 &&
-                credentials!=null && credentials.length()>0)
-            {
-                put(username,credentials);
-                if(roles!=null && roles.length()>0)
+                String username=entry.getKey().toString().trim();
+                String credentials=entry.getValue().toString().trim();
+                String roles=null;
+                int c=credentials.indexOf(',');
+                if (c>0)
                 {
-                    StringTokenizer tok = new StringTokenizer(roles,", ");
-                    while (tok.hasMoreTokens())
-                        addUserToRole(username,tok.nextToken());
+                    roles=credentials.substring(c+1).trim();
+                    credentials=credentials.substring(0,c).trim();
                 }
+
+                if (username!=null && username.length()>0 &&
+                        credentials!=null && credentials.length()>0)
+                {
+                    put(username,credentials);
+                    if(roles!=null && roles.length()>0)
+                    {
+                        StringTokenizer tok = new StringTokenizer(roles,", ");
+                        while (tok.hasMoreTokens())
+                            addUserToRole(username,tok.nextToken());
+                    }
+                }
             }
         }
     }
@@ -186,7 +220,7 @@
         }
         if (user==null)
             return null;
-
+        
         if (user.authenticate(credentials))
             return user;
         
@@ -332,6 +366,81 @@
             _ssoRealm.clearSingleSignOn(username);
     }
     
+  
+    
+    
+    
+    /** 
+     * @see org.mortbay.component.AbstractLifeCycle#doStart()
+     */
+    protected void doStart() throws Exception
+    {
+        super.doStart();
+        if (_scanner!=null)
+            _scanner.stop(); 
+
+        if (getRefreshInterval() > 0)
+        {
+            _scanner = new Scanner();
+            _scanner.setScanInterval(getRefreshInterval());
+            List dirList = new ArrayList(1);
+            dirList.add(_configResource.getFile());
+            _scanner.setScanDirs(dirList);
+            _scanner.setFilenameFilter(new FilenameFilter ()
+            {
+                public boolean accept(File dir, String name)
+                {
+                    File f = new File(dir,name);
+                    try
+                    {
+                        if (f.compareTo(_configResource.getFile())==0)
+                            return true;
+                    }
+                    catch (IOException e)
+                    {
+                        return false;
+                    }
+
+                    return false;
+                }
+
+            });
+            _scanner.addListener(new BulkListener()
+            {
+                public void filesChanged(List filenames) throws Exception
+                {
+                    if (filenames==null)
+                        return;
+                    if (filenames.isEmpty())
+                        return;
+                    if (filenames.size()==1 && filenames.get(0).equals(_config))
+                        loadConfig();
+                }
+                public String toString()
+                {
+                    return "HashUserRealm$Scanner";
+                }
+
+            });
+            _scanner.setReportExistingFilesOnStartup(false);
+            _scanner.setRecursive(false);
+            _scanner.start();
+        }
+    }
+
+    /** 
+     * @see org.mortbay.component.AbstractLifeCycle#doStop()
+     */
+    protected void doStop() throws Exception
+    {
+        super.doStop();
+        if (_scanner!=null)
+            _scanner.stop();
+        _scanner=null;
+    }
+
+
+
     /* ------------------------------------------------------------ */
     /* ------------------------------------------------------------ */
     /* ------------------------------------------------------------ */
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/DigestAuthenticator.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/DigestAuthenticator.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/DigestAuthenticator.java	(working copy)
@@ -146,14 +146,15 @@
                               boolean stale)
         throws IOException
     {
-        String contextPath=request.getContextPath();
+        String domain=request.getContextPath();
+        if (domain==null)
+            domain="/";
         response.setHeader(HttpHeaders.WWW_AUTHENTICATE,
 			    "Digest realm=\""+realm.getName()+
-			    "\", domain=\""+contextPath +
+			    "\", domain=\""+domain +
 			    "\", nonce=\""+newNonce(request)+
 			    "\", algorithm=MD5, qop=\"auth\"" + (useStale?(" stale="+stale):"")
                           );
-        
         response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
     }
 
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/BasicAuthenticator.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/BasicAuthenticator.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/BasicAuthenticator.java	(working copy)
@@ -95,7 +95,7 @@
     public void sendChallenge(UserRealm realm,Response response)
         throws IOException
     {
-        response.setHeader(HttpHeaders.WWW_AUTHENTICATE, "basic realm=\""+realm.getName()+'"');
+        response.setHeader(HttpHeaders.WWW_AUTHENTICATE, "Basic realm=\""+realm.getName()+'"');
         response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
     }
     
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/JDBCUserRealm.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/JDBCUserRealm.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/JDBCUserRealm.java	(working copy)
@@ -110,36 +110,20 @@
         super(name);
         setConfig(config);
         Loader.loadClass(this.getClass(),_jdbcDriver).newInstance();
-        connectDatabase();
-    }
-    
-    public String getName()
-    {
-        return super.getName();
-    }
-    
-    public void setName(String name)
-    {
-        super.setName(name);
-    }
-    public String getConfig()
-    {
-        return super.getConfig();    
-    }
+    }    
+
     /* ------------------------------------------------------------ */
     /** Load JDBC connection configuration from properties file.
-     *
-     * @param config Filename or url of user properties file.
+     *     
      * @exception IOException 
      */
-    public void setConfig(String config)
+    protected void loadConfig()
         throws IOException
-    {
-        super.setConfig(config);
+    {        
         Properties properties = new Properties();
-        Resource resource=Resource.newResource(config);
-        properties.load(resource.getInputStream());
         
+        properties.load(getConfigResource().getInputStream());
+        
         _jdbcDriver = properties.getProperty("jdbcdriver");
         _url = properties.getProperty("url");
         _userName = properties.getProperty("username");
@@ -154,7 +138,9 @@
         _userRoleTable = properties.getProperty("userroletable");
         _userRoleTableUserKey = properties.getProperty("userroletableuserkey");
         _userRoleTableRoleKey = properties.getProperty("userroletablerolekey");
-        _cacheTime = new Integer(properties.getProperty("cachetime")).intValue();
+        // default cachetime = 30s
+        String cachetime = properties.getProperty("cachetime");
+        _cacheTime = cachetime!=null ? new Integer(cachetime).intValue() : 30;
         
         if (_jdbcDriver == null || _jdbcDriver.equals("")
             || _url == null || _url.equals("")
@@ -218,6 +204,7 @@
                 _users.clear();
                 _roles.clear();
                 _lastHashPurge = now;
+                closeConnection(); //force a fresh connection
             }
             Principal user = super.getPrincipal(username);
             if (user == null)
@@ -229,8 +216,19 @@
         return super.authenticate(username, credentials, request);
     }
     
+    /* ------------------------------------------------------------ */
+    /** Check if a user is in a role.
+     * @param user The user, which must be from this realm 
+     * @param roleName 
+     * @return True if the user can act in the role.
+     */
+    public synchronized boolean isUserInRole(Principal user, String roleName)
+    {
+        if(super.getPrincipal(user.getName())==null)
+            loadUser(user.getName());
+        return super.isUserInRole(user, roleName);
+    }
     
-    
 
 
     
@@ -269,7 +267,20 @@
         {
             Log.warn("UserRealm " + getName()
                       + " could not load user information from database", e);
-            connectDatabase();
+           closeConnection();
         }
     }
+    
+    /**
+     * Close an existing connection
+     */
+    private void closeConnection ()
+    {
+        if (_con != null)
+        {
+            if (Log.isDebugEnabled()) Log.debug("Closing db connection for JDBCUserRealm");
+            try { _con.close(); }catch (Exception e) {Log.ignore(e);}
+        }
+        _con = null;
+    }
 }
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/SslSocketConnector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/SslSocketConnector.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/SslSocketConnector.java	(working copy)
@@ -17,6 +17,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
 import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
@@ -30,6 +31,8 @@
 import java.util.Iterator;
 import java.util.List;
 
+import javax.net.ssl.HandshakeCompletedEvent;
+import javax.net.ssl.HandshakeCompletedListener;
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
@@ -151,6 +154,7 @@
     private boolean _wantClientAuth = false;
     private int _handshakeTimeout = 0; //0 means use maxIdleTime
 
+    private boolean _allowRenegotiate =false;
 
     /* ------------------------------------------------------------ */
     /**
@@ -163,14 +167,52 @@
 
 
     /* ------------------------------------------------------------ */
+    /**
+     * @return True if SSL re-negotiation is allowed (default false)
+     */
+    public boolean isAllowRenegotiate()
+    {
+        return _allowRenegotiate;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * Set if SSL re-negotiation is allowed. CVE-2009-3555 discovered
+     * a vulnerability in SSL/TLS with re-negotiation.  If your JVM
+     * does not have CVE-2009-3555 fixed, then re-negotiation should 
+     * not be allowed.
+     * @param allowRenegotiate true if re-negotiation is allowed (default false)
+     */
+    public void setAllowRenegotiate(boolean allowRenegotiate)
+    {
+        _allowRenegotiate = allowRenegotiate;
+    }
+
+    /* ------------------------------------------------------------ */
     public void accept(int acceptorID)
         throws IOException, InterruptedException
     {   
-        Socket socket = _serverSocket.accept();
-        configure(socket);
-        
-        Connection connection=new SslConnection(socket);
-        connection.dispatch();
+        try
+        {
+            Socket socket = _serverSocket.accept();
+            configure(socket);
+
+            Connection connection=new SslConnection(socket);
+            connection.dispatch();
+        }
+        catch(SSLException e)
+        {
+            Log.warn(e);
+            try
+            {
+                stop();
+            }
+            catch(Exception e2)
+            {
+                Log.warn(e2);
+                throw new IllegalStateException(e2.getMessage());
+            }
+        }
     }
     
     /* ------------------------------------------------------------ */
@@ -184,13 +226,6 @@
     protected SSLServerSocketFactory createFactory() 
         throws Exception
     {
-        if (_password==null)
-            _password=new Password("");
-        if (_keyPassword==null)
-            _keyPassword=_password;
-        if (_trustPassword==null)
-            _trustPassword=_password;
-
         if (_truststore==null)
         {
             _truststore=_keystore;
@@ -198,30 +233,27 @@
         }
 
         KeyManager[] keyManagers = null;
+        InputStream keystoreInputStream = null;
         if (_keystore != null)
-        {
-            KeyStore keyStore = KeyStore.getInstance(_keystoreType);
-            if (_password == null) 
-                throw new SSLException("_password is not set");
-            keyStore.load(Resource.newResource(_keystore).getInputStream(), _password.toString().toCharArray());
-    
-            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(_sslKeyManagerFactoryAlgorithm);        
-            if (_keyPassword == null) 
-                throw new SSLException("_keypassword is not set");
-            keyManagerFactory.init(keyStore,_keyPassword.toString().toCharArray());
-            keyManagers = keyManagerFactory.getKeyManagers();
-        }
+        	keystoreInputStream = Resource.newResource(_keystore).getInputStream();
+        KeyStore keyStore = KeyStore.getInstance(_keystoreType);
+        keyStore.load(keystoreInputStream, _password==null?null:_password.toString().toCharArray());
 
+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(_sslKeyManagerFactoryAlgorithm);        
+        keyManagerFactory.init(keyStore,_keyPassword==null?null:_keyPassword.toString().toCharArray());
+        keyManagers = keyManagerFactory.getKeyManagers();
+
         TrustManager[] trustManagers = null;
+        InputStream truststoreInputStream = null;
         if (_truststore != null)
-        {
-            KeyStore trustStore = KeyStore.getInstance(_truststoreType);
-            trustStore.load(Resource.newResource(_truststore).getInputStream(), _trustPassword.toString().toCharArray());
-            
-            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(_sslTrustManagerFactoryAlgorithm);
-            trustManagerFactory.init(trustStore);
-            trustManagers = trustManagerFactory.getTrustManagers();
-        }
+        	truststoreInputStream = Resource.newResource(_truststore).getInputStream();
+        KeyStore trustStore = KeyStore.getInstance(_truststoreType);
+        trustStore.load(truststoreInputStream,_trustPassword==null?null:_trustPassword.toString().toCharArray());
+        
+        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(_sslTrustManagerFactoryAlgorithm);
+        trustManagerFactory.init(trustStore);
+        trustManagers = trustManagerFactory.getTrustManagers();
+        
 
         SecureRandom secureRandom = _secureRandomAlgorithm==null?null:SecureRandom.getInstance(_secureRandomAlgorithm);
 
@@ -451,8 +483,9 @@
         }
         catch (Exception e)
         {
-            Log.warn(Log.EXCEPTION, e);
-            throw new IOException("Could not create JsseListener: " + e.toString());
+            Log.warn(e.toString());
+            Log.debug(e);
+            throw new IOException("!JsseListener: " + e);
         }
         return socket;
     }
@@ -472,6 +505,9 @@
     }
 
     /* ------------------------------------------------------------ */
+    /**
+     * @param keystore The resource path to the keystore, or null for built in keystores.
+     */
     public void setKeystore(String keystore)
     {
         _keystore = keystore;
@@ -618,13 +654,37 @@
                 if (handshakeTimeout > 0)            
                     _socket.setSoTimeout(handshakeTimeout);
 
-                ((SSLSocket)_socket).startHandshake();
+                final SSLSocket ssl=(SSLSocket)_socket;
+                ssl.addHandshakeCompletedListener(new HandshakeCompletedListener()
+                {
+                    boolean handshook=false;
+                    public void handshakeCompleted(HandshakeCompletedEvent event)
+                    {
+                        if (handshook)
+                        {
+                            if (!_allowRenegotiate)
+                            {
+                                Log.warn("SSL renegotiate denied: "+ssl);
+                                try{ssl.close();}catch(IOException e){Log.warn(e);}
+                            }
+                        }
+                        else
+                            handshook=true;
+                    }
+                });
+                ssl.startHandshake();
 
                 if (handshakeTimeout>0)
                     _socket.setSoTimeout(oldTimeout);
 
                 super.run();
             }
+            catch (SSLException e)
+            {
+                Log.warn(e); 
+                try{close();}
+                catch(IOException e2){Log.ignore(e2);}
+            }
             catch (IOException e)
             {
                 Log.debug(e);
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/ClientCertAuthenticator.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/ClientCertAuthenticator.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/ClientCertAuthenticator.java	(working copy)
@@ -17,13 +17,10 @@
 import java.io.IOException;
 import java.security.Principal;
 
-import javax.net.ssl.SSLSocket;
 import javax.servlet.http.HttpServletResponse;
 
-import org.mortbay.jetty.HttpConnection;
 import org.mortbay.jetty.Request;
 import org.mortbay.jetty.Response;
-import org.mortbay.log.Log;
 
 /* ------------------------------------------------------------ */
 /** Client Certificate Authenticator.
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/HashSSORealm.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/HashSSORealm.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/HashSSORealm.java	(working copy)
@@ -44,7 +44,7 @@
     {
         String ssoID = null;
         Cookie[] cookies = request.getCookies();
-        for (int i = 0; i < cookies.length; i++)
+        for (int i = 0; cookies!=null && i < cookies.length; i++)
         {
             if (cookies[i].getName().equals(SSO_COOKIE_NAME))
             {
@@ -68,9 +68,10 @@
         {
             // TODO - make this work for non webapps
             UserRealm realm = ((WebAppContext)(request.getContext().getContextHandler())).getSecurityHandler().getUserRealm();
-            if (realm.reauthenticate(principal))
+            Principal authPrincipal = realm.authenticate(principal.getName(), credential, request);
+            if (authPrincipal != null)
             {
-                request.setUserPrincipal(principal);
+                request.setUserPrincipal(authPrincipal);
                 return credential;
             }
             else
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/PKCS12Import.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/PKCS12Import.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/PKCS12Import.java	(working copy)
@@ -49,7 +49,7 @@
  * </PRE>
  * then run:
  * <PRE>
- *    java PKCS12Import keystore.pkcs12 keytore.jks
+ *    java PKCS12Import keystore.pkcs12 keystore.jks
  * </PRE>
  *
  * @author Jason Gilbert &lt;jason@doozer.com&gt;
Index: modules/jetty/src/main/java/org/mortbay/jetty/Request.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/Request.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/Request.java	(working copy)
@@ -21,7 +21,7 @@
 import java.io.InputStreamReader;
 import java.io.UnsupportedEncodingException;
 import java.net.InetAddress;
-import java.net.URLDecoder;
+import java.nio.ByteBuffer;
 import java.security.Principal;
 import java.util.Collection;
 import java.util.Collections;
@@ -34,10 +34,13 @@
 import java.util.Map;
 
 import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletContext;
 import javax.servlet.ServletInputStream;
 import javax.servlet.ServletRequestAttributeEvent;
 import javax.servlet.ServletRequestAttributeListener;
+import javax.servlet.ServletRequestListener;
 import javax.servlet.ServletRequestWrapper;
+import javax.servlet.ServletResponse;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpSession;
@@ -46,12 +49,14 @@
 import org.mortbay.io.BufferUtil;
 import org.mortbay.io.EndPoint;
 import org.mortbay.io.Portable;
+import org.mortbay.io.nio.DirectNIOBuffer;
+import org.mortbay.io.nio.IndirectNIOBuffer;
+import org.mortbay.io.nio.NIOBuffer;
 import org.mortbay.jetty.handler.ContextHandler;
 import org.mortbay.jetty.handler.ContextHandler.SContext;
 import org.mortbay.jetty.security.Authenticator;
 import org.mortbay.jetty.security.SecurityHandler;
 import org.mortbay.jetty.security.UserRealm;
-import org.mortbay.jetty.servlet.AbstractSessionManager.Session;
 import org.mortbay.log.Log;
 import org.mortbay.util.Attributes;
 import org.mortbay.util.AttributesMap;
@@ -98,12 +103,6 @@
  */
 public class Request implements HttpServletRequest
 {
-    private static final byte STATE_DELIMITER = 1;
-    private static final byte STATE_NAME = 2;
-    private static final byte STATE_VALUE = 4;
-    private static final byte STATE_QUOTED_VALUE = 8;
-    private static final byte STATE_UNQUOTED_VALUE = 16;
-
     private static final Collection __defaultLocale = Collections.singleton(Locale.getDefault());
     private static final int __NONE=0, _STREAM=1, __READER=2;
     
@@ -117,6 +116,8 @@
     private String _characterEncoding;
     private String _queryEncoding;
     private String _serverName;
+    private String _remoteAddr;
+    private String _remoteHost;
     private String _method;
     private String _pathInfo;
     private int _port;
@@ -136,17 +137,19 @@
     private boolean _paramsExtracted;
     private int _inputState=__NONE;
     private BufferedReader _reader;
+    private String _readerEncoding;
     private boolean _dns=false;
     private ContextHandler.SContext _context;
     private HttpSession _session;
     private SessionManager _sessionManager;
     private boolean _cookiesExtracted=false;
     private Cookie[] _cookies;
-    private String[] _lastCookies;
+    private String[] _unparsedCookies;
     private long _timeStamp;
     private Buffer _timeStampBuffer;
     private Continuation _continuation;
     private Object _requestAttributeListeners;
+    private Object _requestListeners;
     private Map _savedNewSessions;
     private UserRealm _userRealm;
     
@@ -170,8 +173,31 @@
     }
 
     /* ------------------------------------------------------------ */
+    protected void setConnection(HttpConnection connection)
+    {
+        _connection=connection;
+        _endp=connection.getEndPoint();
+        _dns=connection.getResolveNames();
+    }
+    
+    /* ------------------------------------------------------------ */
     protected void recycle()
     {
+        if (_inputState==__READER)
+        {
+            try
+            {
+                int r=_reader.read();
+                while(r!=-1)
+                    r=_reader.read();
+            }
+            catch(Exception e)
+            {
+                Log.ignore(e);
+                _reader=null;
+            }
+        }
+        
         _handled=false;
         if (_context!=null)
             throw new IllegalStateException("Request in context!");
@@ -202,7 +228,7 @@
         _parameters=null;
         _paramsExtracted=false;
         _inputState=__NONE;
-        _reader=null; 
+        
         _cookiesExtracted=false;
         if (_savedNewSessions!=null)
             _savedNewSessions.clear();
@@ -297,6 +323,13 @@
         return _characterEncoding;
     }
     
+    public long getContentRead()
+    {
+        if (_connection==null || _connection.getParser()==null)
+            return -1;
+        
+        return ((HttpParser)_connection.getParser()).getContentRead();
+    }
 
     /* ------------------------------------------------------------ */
     /* 
@@ -334,7 +367,7 @@
     {
         return _contextPath;
     }
-
+    
     /* ------------------------------------------------------------ */
     /* 
      * @see javax.servlet.http.HttpServletRequest#getCookies()
@@ -349,26 +382,26 @@
         {
             _cookies = null;
             _cookiesExtracted = true;
-            _lastCookies = null;
+            _unparsedCookies = null;
             return _cookies;
         }
 
         // Check if cookie headers match last cookies
-        if (_lastCookies != null)
+        if (_unparsedCookies != null)
         {
             int last = 0;
             Enumeration enm = _connection.getRequestFields().getValues(HttpHeaders.COOKIE_BUFFER);
             while (enm.hasMoreElements())
             {
                 String c = (String)enm.nextElement();
-                if (last >= _lastCookies.length || !c.equals(_lastCookies[last]))
+                if (last >= _unparsedCookies.length || !c.equals(_unparsedCookies[last]))
                 {
-                    _lastCookies = null;
+                    _unparsedCookies = null;
                     break;
                 }
                 last++;
             }
-            if (_lastCookies != null && _lastCookies.length==last)
+            if (_unparsedCookies != null && _unparsedCookies.length==last)
             {
                 _cookiesExtracted = true;
                 return _cookies;
@@ -381,125 +414,178 @@
         Object lastCookies = null;
 
         int version = 0;
-
+        
         // For each cookie header
         Enumeration enm = _connection.getRequestFields().getValues(HttpHeaders.COOKIE_BUFFER);
         while (enm.hasMoreElements())
         {
-
             try
             {
-
                 // Save a copy of the unparsed header as cache.
                 String hdr = (String)enm.nextElement();
                 lastCookies = LazyList.add(lastCookies, hdr);
-
+                
                 // Parse the header
                 String name = null;
                 String value = null;
 
                 Cookie cookie = null;
 
-                byte state = STATE_NAME;
-                for (int i = 0, tokenstart = 0, length = hdr.length(); i < length; i++)
+                boolean invalue=false;
+                boolean quoted=false;
+                boolean escaped=false;
+                int tokenstart=-1;
+                int tokenend=-1;
+                for (int i = 0, length = hdr.length(), last=length-1; i < length; i++)
                 {
                     char c = hdr.charAt(i);
-                    switch (c)
+                    
+                    // Handle quoted values for name or value
+                    if (quoted)
                     {
-                        case ',':
-                        case ';':
-                            switch (state)
+                        if (escaped)
+                        {
+                            escaped=false;
+                            continue;
+                        }
+                        
+                        switch (c)
+                        {
+                            case '"':
+                                tokenend=i;
+                                quoted=false;
+
+                                // handle quote as last character specially
+                                if (i==last)
+                                {
+                                    if (invalue)
+                                        value = hdr.substring(tokenstart, tokenend+1);
+                                    else
+                                    {
+                                        name = hdr.substring(tokenstart, tokenend+1);
+                                        value = "";
+                                    }
+                                }
+                                break;
+                                
+                            case '\\':
+                                escaped=true;
+                                continue;
+                            default:
+                                continue;
+                        }
+                    }
+                    else
+                    {
+                        // Handle name and value state machines
+                        if (invalue)
+                        {
+                            // parse the value
+                            switch (c)
                             {
-                                case STATE_DELIMITER:
-                                    state = STATE_NAME;
-                                    tokenstart = i + 1;
+                                case ' ':
+                                case '\t':
+                                    continue;
+                                    
+                                case '"':
+                                    if (tokenstart<0)
+                                    {
+                                        quoted=true;
+                                        tokenstart=i;
+                                    }
+                                    tokenend=i;
+                                    if (i==last)
+                                    {
+                                        value = hdr.substring(tokenstart, tokenend+1);
+                                        break;
+                                    }
+                                    continue;
+
+                                case ';':
+                                case ',':
+                                    if (tokenstart>=0)
+                                        value = hdr.substring(tokenstart, tokenend+1);
+                                    else
+                                        value="";
+                                    tokenstart = -1;
+                                    invalue=false;
                                     break;
-                                case STATE_UNQUOTED_VALUE:
-                                    state = STATE_NAME;
-                                    value = hdr.substring(tokenstart, i).trim();
-                                    if(isRequestedSessionIdFromURL())
-                                        value = URIUtil.decodePath(value);
-                                    tokenstart = i + 1;
-                                    break;
-                                case STATE_NAME:
-                                    name = hdr.substring(tokenstart, i);
-                                    value = "";
-                                    tokenstart = i + 1;
-                                    break;
-                                case STATE_VALUE:
-                                    state = STATE_NAME;
-                                    value = "";
-                                    tokenstart = i + 1;
-                                    break;
+                                    
+                                default:
+                                    if (tokenstart<0)
+                                        tokenstart=i;
+                                    tokenend=i;
+                                    if (i==last)
+                                    {
+                                        value = hdr.substring(tokenstart, tokenend+1);
+                                        break;
+                                    }
+                                    continue;
                             }
-                            break;
-                        case '=':
-                            switch (state)
+                        }
+                        else
+                        {
+                            // parse the name
+                            switch (c)
                             {
-                                case STATE_NAME:
-                                    state = STATE_VALUE;
-                                    name = hdr.substring(tokenstart, i);
-                                    tokenstart = i + 1;
+                                case ' ':
+                                case '\t':
+                                    continue;
+                                    
+                                case '"':
+                                    if (tokenstart<0)
+                                    {
+                                        quoted=true;
+                                        tokenstart=i;
+                                    }
+                                    tokenend=i;
+                                    if (i==last)
+                                    {
+                                        name = hdr.substring(tokenstart, tokenend+1);
+                                        value = "";
+                                        break;
+                                    }
+                                    continue;
+
+                                case ';':
+                                case ',':
+                                    if (tokenstart>=0)
+                                    {
+                                        name = hdr.substring(tokenstart, tokenend+1);
+                                        value = "";
+                                    }
+                                    tokenstart = -1;
                                     break;
-                                case STATE_VALUE:
-                                    state = STATE_UNQUOTED_VALUE;
-                                    tokenstart = i;
-                                    break;
+
+                                case '=':
+                                    if (tokenstart>=0)
+                                        name = hdr.substring(tokenstart, tokenend+1);
+                                    tokenstart = -1;
+                                    invalue=true;
+                                    continue;
+                                    
+                                default:
+                                    if (tokenstart<0)
+                                        tokenstart=i;
+                                    tokenend=i;
+                                    if (i==last)
+                                    {
+                                        name = hdr.substring(tokenstart, tokenend+1);
+                                        value = "";
+                                        break;
+                                    }
+                                    continue;
                             }
-                            break;
-                        case '"':
-                            switch (state)
-                            {
-                                case STATE_VALUE:
-                                    state = STATE_QUOTED_VALUE;
-                                    tokenstart = i + 1;
-                                    break;
-                                case STATE_QUOTED_VALUE:
-                                    state = STATE_DELIMITER;
-                                    value = hdr.substring(tokenstart, i);
-                                    break;
-                            }
-                            break;
-                        case ' ':
-                        case '\t':
-                            break;
-                        default:
-                            switch (state)
-                            {
-                                case STATE_VALUE:
-                                    state = STATE_UNQUOTED_VALUE;
-                                    tokenstart = i;
-                                    break;
-                                case STATE_DELIMITER:
-                                    state = STATE_NAME;
-                                    tokenstart = i;
-                                    break;
-                            }
-                    }
-
-                    if (i + 1 == length)
-                    {
-                        switch (state)
-                        {
-                            case STATE_UNQUOTED_VALUE:
-                                value = hdr.substring(tokenstart).trim();
-                                if(isRequestedSessionIdFromURL())
-                                    value = URIUtil.decodePath(value);
-                                break;
-                            case STATE_NAME:
-                                name = hdr.substring(tokenstart);
-                                value = "";
-                                break;
-                            case STATE_VALUE:
-                                value = "";
-                                break;
                         }
                     }
 
-                    if (name != null && value != null)
+                    // If after processing the current character we have a value and a name, then it is a cookie
+                    if (value!=null && name!=null)
                     {
-                        name = name.trim();
-
+                        // TODO handle unquoting during parsing!  But quoting is uncommon
+                        name=QuotedStringTokenizer.unquote(name);
+                        value=QuotedStringTokenizer.unquote(value);
+                        
                         try
                         {
                             if (name.startsWith("$"))
@@ -507,12 +593,19 @@
                                 String lowercaseName = name.toLowerCase();
                                 if ("$path".equals(lowercaseName))
                                 {
-                                    cookie.setPath(value);
+                                    if (cookie!=null)
+                                        cookie.setPath(value);
                                 }
                                 else if ("$domain".equals(lowercaseName))
                                 {
-                                    cookie.setDomain(value);
+                                    if (cookie!=null)
+                                        cookie.setDomain(value);
                                 }
+                                else if ("$port".equals(lowercaseName))
+                                {
+                                    if (cookie!=null)
+                                        cookie.setComment("port="+value);
+                                }
                                 else if ("$version".equals(lowercaseName))
                                 {
                                     version = Integer.parseInt(value);
@@ -521,18 +614,15 @@
                             else
                             {
                                 cookie = new Cookie(name, value);
-
                                 if (version > 0)
-                                {
                                     cookie.setVersion(version);
-                                }
-
                                 cookies = LazyList.add(cookies, cookie);
                             }
                         }
                         catch (Exception e)
                         {
-                            Log.ignore(e);
+                            Log.warn(e.toString());
+                            Log.debug(e);
                         }
 
                         name = null;
@@ -546,23 +636,31 @@
                 Log.warn(e);
             }
         }
-
+        
+        // how many cookies did we find?
         int l = LazyList.size(cookies);
         _cookiesExtracted = true;
         if (l>0)
         {
+            // Do we need a new cookie array
             if (_cookies == null || _cookies.length != l) 
                 _cookies = new Cookie[l];
+            
+            // Copy the cookies into the array
             for (int i = 0; i < l; i++)
                 _cookies[i] = (Cookie) LazyList.get(cookies, i);
 
+            // 
             l = LazyList.size(lastCookies);
-            _lastCookies = new String[l];
+            _unparsedCookies = new String[l];
             for (int i = 0; i < l; i++)
-                _lastCookies[i] = (String) LazyList.get(lastCookies, i);
+                _unparsedCookies[i] = (String) LazyList.get(lastCookies, i);
         }
         else
+        {
             _cookies=null;
+            _unparsedCookies=null;
+        }
 
 
         if (_cookies==null || _cookies.length==0)
@@ -835,13 +933,25 @@
     {
         if (_inputState!=__NONE && _inputState!=__READER)
             throw new IllegalStateException("STREAMED");
-        if (_reader==null)
+
+        if (_inputState==__READER)
+            return _reader;
+        
+        String encoding=getCharacterEncoding();
+        if (encoding==null)
+            encoding=StringUtil.__ISO_8859_1;
+        
+        if (_reader==null || !encoding.equalsIgnoreCase(_readerEncoding))
         {
-            String encoding=getCharacterEncoding();
-            if (encoding==null)
-                encoding=StringUtil.__ISO_8859_1;
-            _reader=new BufferedReader(new InputStreamReader(getInputStream(),encoding));
-            
+            final ServletInputStream in = getInputStream();
+            _readerEncoding=encoding;
+            _reader=new BufferedReader(new InputStreamReader(in,encoding))
+            {
+                public void close() throws IOException
+                {
+                    in.close();
+                }   
+            };
         }
         _inputState=__READER;
         return _reader;
@@ -864,6 +974,8 @@
      */
     public String getRemoteAddr()
     {
+        if (_remoteAddr != null)
+            return _remoteAddr;	
         return _endp==null?null:_endp.getRemoteAddr();
     }
 
@@ -874,8 +986,14 @@
     public String getRemoteHost()
     {
         if (_dns)
+        {
+            if (_remoteHost != null)
+            {
+                return _remoteHost;
+            }
             return _endp==null?null:_endp.getRemoteHost();
-        return _endp==null?null:_endp.getRemoteAddr();
+        }
+        return getRemoteAddr();
     }
 
     /* ------------------------------------------------------------ */
@@ -1170,7 +1288,12 @@
     public String getQueryString()
     {
         if (_queryString==null && _uri!=null)
-            _queryString=_uri.getQuery(_queryEncoding);
+        {
+            if (_queryEncoding==null)
+                _queryString=_uri.getQuery();
+            else
+                _queryString=_uri.getQuery(_queryEncoding);
+        }
         return _queryString;
     }
     
@@ -1259,11 +1382,18 @@
         {
             if (_requestAttributeListeners!=null)
             {
-                ServletRequestAttributeEvent event =
+                final ServletRequestAttributeEvent event =
                     new ServletRequestAttributeEvent(_context,this,name, old_value);
-
-                for(int i=0;i<LazyList.size(_requestAttributeListeners);i++)
-                    ((ServletRequestAttributeListener)LazyList.get(_requestAttributeListeners,i)).attributeRemoved(event);
+                final int size=LazyList.size(_requestAttributeListeners);
+                for(int i=0;i<size;i++)
+                {
+                    final EventListener listener = (ServletRequestAttributeListener)LazyList.get(_requestAttributeListeners,i);
+                    if (listener instanceof ServletRequestAttributeListener)
+                    {
+                        final ServletRequestAttributeListener l = (ServletRequestAttributeListener)listener;
+                        ((ServletRequestAttributeListener)l).attributeRemoved(event);
+                    }
+                }
             }
         }
     }
@@ -1273,6 +1403,9 @@
      * Set a request attribute.
      * if the attribute name is "org.mortbay.jetty.Request.queryEncoding" then
      * the value is also passed in a call to {@link #setQueryEncoding}.
+     *
+     * if the attribute name is "org.mortbay.jetty.ResponseBuffer", then
+     * the response buffer is flushed with @{link #flushResponseBuffer}  
      * 
      * @see javax.servlet.ServletRequest#setAttribute(java.lang.String, java.lang.Object)
      */
@@ -1282,26 +1415,49 @@
         
         if ("org.mortbay.jetty.Request.queryEncoding".equals(name))
             setQueryEncoding(value==null?null:value.toString());
-        
+        else if("org.mortbay.jetty.ResponseBuffer".equals(name))
+        {
+            try 
+            {
+                ByteBuffer byteBuffer=(ByteBuffer)value;
+                synchronized (byteBuffer)
+                {
+                    NIOBuffer buffer = byteBuffer.isDirect()
+                        ?(NIOBuffer)new DirectNIOBuffer(byteBuffer,true)
+                        :(NIOBuffer)new IndirectNIOBuffer(byteBuffer,true);
+                    ((HttpConnection.Output)getServletResponse().getOutputStream()).sendResponse(buffer);
+                }
+            } 
+            catch (IOException e)
+            {
+                throw new RuntimeException(e);
+            }
+        }
+
+
         if (_attributes==null)
             _attributes=new AttributesMap();
         _attributes.setAttribute(name, value);
         
         if (_requestAttributeListeners!=null)
         {
-            ServletRequestAttributeEvent event =
+            final ServletRequestAttributeEvent event =
                 new ServletRequestAttributeEvent(_context,this,name, old_value==null?value:old_value);
+            final int size=LazyList.size(_requestAttributeListeners);
+            for(int i=0;i<size;i++)
+            {
+                final EventListener listener = (ServletRequestAttributeListener)LazyList.get(_requestAttributeListeners,i);
+                if (listener instanceof ServletRequestAttributeListener)
+                {
+                    final ServletRequestAttributeListener l = (ServletRequestAttributeListener)listener;
 
-            for(int i=0;i<LazyList.size(_requestAttributeListeners);i++)
-            {
-                ServletRequestAttributeListener l = (ServletRequestAttributeListener)LazyList.get(_requestAttributeListeners,i);
-                
-                if (old_value==null)
-                    l.attributeAdded(event);
-                else if (value==null)
-                    l.attributeRemoved(event);
-                else
-                    l.attributeReplaced(event);
+                    if (old_value==null)
+                        l.attributeAdded(event);
+                    else if (value==null)
+                        l.attributeRemoved(event);
+                    else
+                        l.attributeReplaced(event);
+                }
             }
         }
     }
@@ -1316,9 +1472,10 @@
             return;
 
         _characterEncoding=encoding;
-        
+
         // check encoding is supported
-        "".getBytes(encoding);
+        if (!StringUtil.isUTF8(encoding))
+            "".getBytes(encoding);
     }
 
     /* ------------------------------------------------------------ */
@@ -1350,19 +1507,26 @@
         _paramsExtracted = true;
 
         // Handle query string
-        if (_uri!=null && _uri.getQuery()!=null)
+        if (_uri!=null && _uri.hasQuery())
         {
-            try
+            if (_queryEncoding==null)
+                _uri.decodeQueryTo(_baseParameters);
+            else
             {
-                _uri.decodeQueryTo(_baseParameters,_queryEncoding);
+                try
+                {
+                    _uri.decodeQueryTo(_baseParameters,_queryEncoding);
+
+                }
+                catch (UnsupportedEncodingException e)
+                {
+                    if (Log.isDebugEnabled())
+                        Log.warn(e);
+                    else
+                        Log.warn(e.toString());
+                }
             }
-            catch (UnsupportedEncodingException e)
-            {
-                if (Log.isDebugEnabled())
-                    Log.warn(e);
-                else
-                    Log.warn(e.toString());
-            }
+
         }
 
         // handle any _content.
@@ -1372,7 +1536,8 @@
         {
             content_type = HttpFields.valueParameters(content_type, null);
             
-            if (MimeTypes.FORM_ENCODED.equalsIgnoreCase(content_type) && HttpMethods.POST.equals(getMethod()))
+            if (MimeTypes.FORM_ENCODED.equalsIgnoreCase(content_type) && 
+                    (HttpMethods.POST.equals(getMethod()) || HttpMethods.PUT.equals(getMethod())))
             {
                 int content_length = getContentLength();
                 if (content_length != 0)
@@ -1438,7 +1603,7 @@
     
     /* ------------------------------------------------------------ */
     /**
-     * @param host The host to set.
+     * @param port The port to set.
      */
     public void setServerPort(int port)
     {
@@ -1447,6 +1612,24 @@
     
     /* ------------------------------------------------------------ */
     /**
+     * @param addr The address to set.
+     */
+    public void setRemoteAddr(String addr)
+    {
+        _remoteAddr = addr;
+    }
+    
+    /* ------------------------------------------------------------ */
+    /**
+     * @param host The host to set.
+     */
+    public void setRemoteHost(String host)
+    {
+        _remoteHost = host;
+    }
+    
+    /* ------------------------------------------------------------ */
+    /**
      * @return Returns the uri.
      */
     public HttpURI getUri()
@@ -1765,21 +1948,40 @@
         return HttpConnection.getCurrentConnection().getRequest();
     }
     
-
     /* ------------------------------------------------------------ */
-    public synchronized void addEventListener(EventListener listener) 
+    public void addEventListener(final EventListener listener) 
     {
         if (listener instanceof ServletRequestAttributeListener)
             _requestAttributeListeners= LazyList.add(_requestAttributeListeners, listener);
     }
     
     /* ------------------------------------------------------------ */
-    public synchronized void removeEventListener(EventListener listener) 
+    public void removeEventListener(final EventListener listener) 
     {
         _requestAttributeListeners= LazyList.remove(_requestAttributeListeners, listener);
     }
 
     /* ------------------------------------------------------------ */
+    /**
+     * @param requestListeners {@link LazyList} of {@link ServletRequestListener}s
+     */
+    public void setRequestListeners(Object requestListeners)
+    {
+        _requestListeners=requestListeners;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * @return {@link LazyList} of {@link ServletRequestListener}s
+     */
+    public Object takeRequestListeners()
+    {
+        final Object listeners=_requestListeners;
+        _requestListeners=null;
+        return listeners;
+    }
+    
+    /* ------------------------------------------------------------ */
     public void saveNewSession(Object key,HttpSession session)
     {
         if (_savedNewSessions==null)
@@ -1845,5 +2047,17 @@
     {
         return _roleMap;
     }
+    
+    /* ------------------------------------------------------------ */
+    public ServletContext getServletContext()
+    {
+        return _context;
+    }
+
+    /* ------------------------------------------------------------ */
+    public ServletResponse getServletResponse()
+    {
+        return _connection.getResponse();
+    }
 }
 
Index: modules/jetty/src/main/java/org/mortbay/jetty/Connector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/Connector.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/jetty/Connector.java	(working copy)
@@ -167,11 +167,13 @@
      */
     void persist(EndPoint endpoint) throws IOException;
     
-    
-    
+    /* ------------------------------------------------------------ */
     Continuation newContinuation();
+
+    /* ------------------------------------------------------------ */
+    String getHost();
     
-    String getHost();
+    /* ------------------------------------------------------------ */
     void setHost(String hostname);
 
     /* ------------------------------------------------------------ */
Index: modules/jetty/src/main/java/org/mortbay/xml/XmlConfiguration.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/xml/XmlConfiguration.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/xml/XmlConfiguration.java	(working copy)
@@ -69,22 +69,30 @@
         if (__parser != null) return;
 
         __parser = new XmlParser();
-        URL configURL = XmlConfiguration.class.getClassLoader().getResource("org/mortbay/xml/configure_6_0.dtd");
-        __parser.redirectEntity("configure.dtd", configURL);
-        __parser.redirectEntity("configure_1_3.dtd", configURL);
-        __parser.redirectEntity("http://jetty.mortbay.org/configure.dtd", configURL);
-        __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure//EN", configURL);
-        __parser.redirectEntity("http://jetty.mortbay.org/configure_1_3.dtd", configURL);
-        __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure 1.3//EN", configURL);
-        __parser.redirectEntity("configure_1_2.dtd", configURL);
-        __parser.redirectEntity("http://jetty.mortbay.org/configure_1_2.dtd", configURL);
-        __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure 1.2//EN", configURL);
-        __parser.redirectEntity("configure_1_1.dtd", configURL);
-        __parser.redirectEntity("http://jetty.mortbay.org/configure_1_1.dtd", configURL);
-        __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure 1.1//EN", configURL);
-        __parser.redirectEntity("configure_1_0.dtd", configURL);
-        __parser.redirectEntity("http://jetty.mortbay.org/configure_1_0.dtd", configURL);
-        __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure 1.0//EN", configURL);
+        try
+        {
+            URL configURL = Loader.getResource(XmlConfiguration.class, "org/mortbay/xml/configure_6_0.dtd", true);
+            __parser.redirectEntity("configure.dtd", configURL);
+            __parser.redirectEntity("configure_1_3.dtd", configURL);
+            __parser.redirectEntity("http://jetty.mortbay.org/configure.dtd", configURL);
+            __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure//EN", configURL);
+            __parser.redirectEntity("http://jetty.mortbay.org/configure_1_3.dtd", configURL);
+            __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure 1.3//EN", configURL);
+            __parser.redirectEntity("configure_1_2.dtd", configURL);
+            __parser.redirectEntity("http://jetty.mortbay.org/configure_1_2.dtd", configURL);
+            __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure 1.2//EN", configURL);
+            __parser.redirectEntity("configure_1_1.dtd", configURL);
+            __parser.redirectEntity("http://jetty.mortbay.org/configure_1_1.dtd", configURL);
+            __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure 1.1//EN", configURL);
+            __parser.redirectEntity("configure_1_0.dtd", configURL);
+            __parser.redirectEntity("http://jetty.mortbay.org/configure_1_0.dtd", configURL);
+            __parser.redirectEntity("-//Mort Bay Consulting//DTD Configure 1.0//EN", configURL);
+        }
+        catch (ClassNotFoundException e)
+        {
+            Log.warn(e.toString());
+            Log.debug(e);
+        }
     }
 
     /* ------------------------------------------------------------ */
@@ -756,8 +764,6 @@
         }
         else if (defval != null)
             prop=defval;
-        else
-            throw new Exception ("Unresolved property name="+name);
 
         if (id != null) 
             _idMap.put(id, prop);
Index: modules/jetty/src/main/java/org/mortbay/xml/XmlParser.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/xml/XmlParser.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/xml/XmlParser.java	(working copy)
@@ -71,7 +71,6 @@
         String validating_prop = System.getProperty("org.mortbay.xml.XmlParser.Validating", validating_dft ? "true" : "false");
         boolean notValidating = Boolean.getBoolean("org.mortbay.xml.XmlParser.NotValidating"); // deprecated!
         boolean validating = !notValidating && Boolean.valueOf(validating_prop).booleanValue();
-
         setValidating(validating);
     }
 
@@ -107,8 +106,9 @@
             }
 
             _parser.getXMLReader().setFeature("http://xml.org/sax/features/validation", validating);
-            _parser.getXMLReader().setFeature("http://xml.org/sax/features/namespaces", validating);
-            _parser.getXMLReader().setFeature("http://xml.org/sax/features/namespace-prefixes", validating);  }
+            _parser.getXMLReader().setFeature("http://xml.org/sax/features/namespaces", true);
+            _parser.getXMLReader().setFeature("http://xml.org/sax/features/namespace-prefixes", false);  
+        }
         catch (Exception e)
         {
             Log.warn(Log.EXCEPTION, e);
Index: modules/jetty/src/main/java/org/mortbay/servlet/jetty/IncludableGzipFilter.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/servlet/jetty/IncludableGzipFilter.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/servlet/jetty/IncludableGzipFilter.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.servlet.jetty;
 
 import java.io.IOException;
@@ -29,7 +43,7 @@
  */
 public class IncludableGzipFilter extends GzipFilter
 {
-    boolean _uncheckedPrintWriter=false;
+    boolean _uncheckedPrintWriter=true;
     
     public void init(FilterConfig filterConfig) throws ServletException
     {
Index: modules/jetty/src/main/java/org/mortbay/io/nio/NIOBuffer.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/nio/NIOBuffer.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/nio/NIOBuffer.java	(working copy)
@@ -14,18 +14,8 @@
 
 package org.mortbay.io.nio;
 
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.nio.ByteBuffer;
-import java.nio.channels.Channels;
-import java.nio.channels.FileChannel;
-import java.nio.channels.ReadableByteChannel;
-import java.nio.channels.WritableByteChannel;
 
-import org.mortbay.io.AbstractBuffer;
 import org.mortbay.io.Buffer;
 
 /* ------------------------------------------------------------------------------- */
@@ -33,273 +23,12 @@
  * 
  * @author gregw
  */
-public class NIOBuffer extends AbstractBuffer
+public interface NIOBuffer extends Buffer
 {
-  	public final static boolean 
-  		DIRECT=true,
-  		INDIRECT=false;
-  	
-    protected ByteBuffer _buf;
-    private ReadableByteChannel _in;
-    private InputStream _inStream;
-    private WritableByteChannel _out;
-    private OutputStream _outStream;
-
-    public NIOBuffer(int size, boolean direct)
-    {
-        super(READWRITE,NON_VOLATILE);
-        _buf = direct
-        	?ByteBuffer.allocateDirect(size)
-        	:ByteBuffer.allocate(size);
-        _buf.position(0);
-        _buf.limit(_buf.capacity());
-    }
-    
-    /**
-     * @param file
-     */
-    public NIOBuffer(File file) throws IOException
-    {
-        super(READONLY,NON_VOLATILE);
-        FileInputStream fis = new FileInputStream(file);
-        FileChannel fc = fis.getChannel();
-        _buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, file.length());
-        setGetIndex(0);
-        setPutIndex((int)file.length());
-        _access=IMMUTABLE;
-    }
-
-    public byte[] array()
-    {
-        if (!_buf.hasArray())
-            return null;
-        return _buf.array();
-    }
-    
-    public int capacity()
-    {
-        return _buf.capacity();
-    }
-
-    public byte peek(int position)
-    {
-        return _buf.get(position);
-    }
-
-    public int peek(int index, byte[] b, int offset, int length)
-    {
-        int l = length;
-        if (index+l > capacity())
-            l=capacity()-index;
-        if (l <= 0) 
-            return -1;
-        try
-        {
-            _buf.position(index);
-            _buf.get(b,offset,l);
-        }
-        finally
-        {
-            _buf.position(0);
-        }
-        
-        return l;
-    }
-
-    public void poke(int position, byte b)
-    {
-        if (isReadOnly()) throw new IllegalStateException(__READONLY);
-        _buf.put(position,b);
-    }
-
-    public int poke(int index, Buffer src)
-    {
-        if (isReadOnly()) throw new IllegalStateException(__READONLY);
-        
-        byte[] array=src.array();
-        if (array!=null)
-        {
-            int length = poke(index,array,src.getIndex(),src.length());
-            return length;
-        }
-        else
-        {
-            Buffer src_buf=src.buffer();
-            if (src_buf instanceof NIOBuffer)
-            {
-                ByteBuffer src_bytebuf = ((NIOBuffer)src_buf)._buf;
-                if (src_bytebuf==_buf)
-                    src_bytebuf=_buf.duplicate();
-                try
-                {   
-                    _buf.position(index);
-                    int space = _buf.remaining();
-                    
-                    int length=src.length();
-                    if (length>space)    
-                        length=space;
-                    
-                    src_bytebuf.position(src.getIndex());
-                    src_bytebuf.limit(src.getIndex()+length);
-                    
-                    _buf.put(src_bytebuf);
-                    return length;
-                }
-                finally
-                {
-                    _buf.position(0);
-                    src_bytebuf.limit(src_bytebuf.capacity());
-                    src_bytebuf.position(0);
-                }
-            }
-            else
-                return super.poke(index,src);
-        }
-    }
-    
-    public int poke(int index, byte[] b, int offset, int length)
-    {
-        if (isReadOnly()) throw new IllegalStateException(__READONLY);
-        try
-        {
-            _buf.position(index);
-            
-            int space=_buf.remaining();
-            
-            if (length>space)
-                length=space;
-            if (length>0)
-                _buf.put(b,offset,length);
-            return length;
-        }
-        finally
-        {
-            _buf.position(0);
-        }
-    }
-    
-    public ByteBuffer getByteBuffer()
-    {
-        return _buf;
-    }
-    
-    
-    public void setByteBuffer(ByteBuffer buf)
-    {
-        this._buf = buf;
-    }
-
-
     /* ------------------------------------------------------------ */
-    public int readFrom(InputStream in, int max) throws IOException
-    {
-        if (_in==null || !_in.isOpen() || in!=_inStream)
-        {
-            _in=Channels.newChannel(in);
-            _inStream=in;
-        }
+    public ByteBuffer getByteBuffer();
 
-        if (max<0 || max>space())
-            max=space();
-        int p = putIndex();
-        
-        try
-        {
-            int len=0, total=0, available=max;
-            int loop=0;
-            while (total<max) 
-            {
-                _buf.position(p);
-                _buf.limit(p+available);
-                len=_in.read(_buf);
-                if (len<0)
-                {
-                    _in=null;
-                    _inStream=in;
-                    break;
-                }
-                else if (len>0)
-                {
-                    p += len;
-                    total += len;
-                    available -= len;
-                    setPutIndex(p);
-                    loop=0;
-                }
-                else if (loop++>1)
-                    break;
-                if (in.available()<=0)
-                    break;
-            }
-            if (len<0 && total==0)
-                return -1;
-            return total;
-            
-        }
-        catch(IOException e)
-        {
-            _in=null;
-            _inStream=in;
-            throw e;
-        }
-        finally
-        {
-            if (_in!=null && !_in.isOpen())
-            {
-                _in=null;
-                _inStream=in;
-            }
-            _buf.position(0);
-            _buf.limit(_buf.capacity());
-        }
-    }
-
     /* ------------------------------------------------------------ */
-    public void writeTo(OutputStream out) throws IOException
-    {
-        if (_out==null || !_out.isOpen() || _out!=_outStream)
-        {
-            _out=Channels.newChannel(out);
-            _outStream=out;
-        }
+    public boolean isDirect();
 
-        try
-        {
-            int loop=0;
-            while(hasContent() && _out.isOpen())
-            {
-                _buf.position(getIndex());
-                _buf.limit(putIndex());
-                int len=_out.write(_buf);
-                if (len<0)
-                    break;
-                else if (len>0)
-                {
-                    skip(len);
-                    loop=0;
-                }
-                else if (loop++>1)
-                    break;
-            }
-        }
-        catch(IOException e)
-        {
-            _out=null;
-            _outStream=null;
-            throw e;
-        }
-        finally
-        {
-            if (_out!=null && !_out.isOpen())
-            {
-                _out=null;
-                _outStream=null;
-            }
-            _buf.position(0);
-            _buf.limit(_buf.capacity());
-        }
-        
-    }
-    
-    
 }
Index: modules/jetty/src/main/java/org/mortbay/io/nio/ChannelEndPoint.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/nio/ChannelEndPoint.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/nio/ChannelEndPoint.java	(working copy)
@@ -27,6 +27,7 @@
 import org.mortbay.io.Buffer;
 import org.mortbay.io.EndPoint;
 import org.mortbay.io.Portable;
+import org.mortbay.log.Log;
 
 
 /**
@@ -92,16 +93,18 @@
                 {
                     // TODO - is this really required?
                     Socket socket= ((SocketChannel)_channel).socket();
-                    try
-                    {
+                    if (!socket.isClosed() && !socket.isOutputShutdown())
                         socket.shutdownOutput();
-                    }
-                    finally
-                    {
-                        socket.close();
-                    }
                 }
             }
+            catch(IOException e)
+            {
+                Log.ignore(e);
+            }
+            catch(UnsupportedOperationException e)
+            {
+                Log.ignore(e);
+            }
             finally
             {
                 _channel.close();
@@ -369,7 +372,9 @@
         
         if (_remote==null)
             _remote=(InetSocketAddress)_socket.getRemoteSocketAddress();
-        
+
+        if (_remote==null)
+            return null;
         return _remote.getAddress().getCanonicalHostName();
     }
 
@@ -384,7 +389,9 @@
         
         if (_remote==null)
             _remote=(InetSocketAddress)_socket.getRemoteSocketAddress();
-        
+
+        if (_remote==null)
+            return -1;
         return _remote==null?-1:_remote.getPort();
     }
 
Index: modules/jetty/src/main/java/org/mortbay/io/nio/SelectChannelEndPoint.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/nio/SelectChannelEndPoint.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/nio/SelectChannelEndPoint.java	(working copy)
@@ -1,7 +1,20 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.io.nio;
 
 import java.io.IOException;
-import java.nio.channels.CancelledKeyException;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
Index: modules/jetty/src/main/java/org/mortbay/io/nio/SelectorManager.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/nio/SelectorManager.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/nio/SelectorManager.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.io.nio;
 
 import java.io.IOException;
@@ -2,2 +16,3 @@
 import java.nio.channels.CancelledKeyException;
+import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
@@ -9,8 +24,6 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 
 import org.mortbay.component.AbstractLifeCycle;
 import org.mortbay.io.Connection;
@@ -29,6 +42,13 @@
  */
 public abstract class SelectorManager extends AbstractLifeCycle
 {
+    // TODO Tune these by approx system speed.
+    private static final int __JVMBUG_THRESHHOLD=Integer.getInteger("org.mortbay.io.nio.JVMBUG_THRESHHOLD",512).intValue();
+    private static final int __MONITOR_PERIOD=Integer.getInteger("org.mortbay.io.nio.MONITOR_PERIOD",1000).intValue();
+    private static final int __MAX_SELECTS=Integer.getInteger("org.mortbay.io.nio.MAX_SELECTS",15000).intValue();
+    private static final int __BUSY_PAUSE=Integer.getInteger("org.mortbay.io.nio.BUSY_PAUSE",50).intValue();
+    private static final int __BUSY_KEY=Integer.getInteger("org.mortbay.io.nio.BUSY_KEY",4).intValue();
+    
     private boolean _delaySelectKeyUpdate=true;
     private long _maxIdleTime;
     private long _lowResourcesConnections;
@@ -37,7 +57,6 @@
     private int _selectSets=1;
     private volatile int _set;
     
-
     /* ------------------------------------------------------------ */
     /**
      * @param maxIdleTime The maximum period in milli seconds that a connection may be idle before it is closed.
@@ -96,9 +115,13 @@
     {
         int s=_set++; 
         s=s%_selectSets;
-        SelectSet set=_selectSet[s];
-        set.addChange(channel,att);
-        set.wakeup();
+        SelectSet[] sets=_selectSet;
+        if (sets!=null)
+        {
+            SelectSet set=sets[s];
+            set.addChange(channel,att);
+            set.wakeup();
+        }
     }
     
     /* ------------------------------------------------------------ */
@@ -163,10 +186,9 @@
      */
     public void doSelect(int acceptorID) throws IOException
     {
-        
-        if (_selectSet!=null && _selectSet.length>acceptorID && _selectSet[acceptorID]!=null)
-            _selectSet[acceptorID].doSelect();
-        
+        SelectSet[] sets= _selectSet;
+        if (sets!=null && sets.length>acceptorID && sets[acceptorID]!=null)
+            sets[acceptorID].doSelect();
     }
 
 
@@ -207,18 +229,18 @@
     /* ------------------------------------------------------------------------------- */
     protected void doStop() throws Exception
     {
-        for (int i=0;i<_selectSet.length;i++)
-            _selectSet[i].stop();
+        SelectSet[] sets= _selectSet;
+        _selectSet=null;
+        if (sets!=null)
+            for (int i=0;i<sets.length;i++)
+            {
+                SelectSet set = sets[i];
+                if (set!=null)
+                    set.stop();
+            }
         super.doStop();
-        _selectSet=null;
     }
 
-    /* ------------------------------------------------------------------------------- */
-    public void doStop(int i) throws Exception
-    {
-        _selectSet[i].stop();
-    }
-
     /* ------------------------------------------------------------ */
     /**
      * @param endpoint
@@ -262,23 +284,37 @@
         private transient Timeout _retryTimeout;
         private transient Selector _selector;
         private transient int _setID;
-        private transient boolean _selecting;
+        private volatile boolean _selecting;
         private transient int _jvmBug;
+        private int _selects;
+        private long _monitorStart;
+        private long _monitorNext;
+        private boolean _pausing;
+        private SelectionKey _busyKey;
+        private int _busyKeyCount;
+        private long _log;
+        private int _paused;
+        private int _jvmFix0;
+        private int _jvmFix1;
+        private int _jvmFix2;
         
         /* ------------------------------------------------------------ */
         SelectSet(int acceptorID) throws Exception
         {
             _setID=acceptorID;
 
-            _idleTimeout = new Timeout();
+            _idleTimeout = new Timeout(this);
             _idleTimeout.setDuration(getMaxIdleTime());
-            _retryTimeout = new Timeout();
+            _retryTimeout = new Timeout(this);
             _retryTimeout.setDuration(0L);
 
             // create a selector;
             _selector = Selector.open();
             _changes = new ArrayList[] {new ArrayList(),new ArrayList()};
             _change=0;
+            _monitorStart=System.currentTimeMillis();
+            _monitorNext=_monitorStart+__MONITOR_PERIOD;
+            _log=_monitorStart+60000;
         }
         
         /* ------------------------------------------------------------ */
@@ -287,19 +323,18 @@
             synchronized (_changes)
             {
                 _changes[_change].add(point);
-                if (point instanceof SocketChannel)
-                    _changes[_change].add(null);
             }
         }
         
         /* ------------------------------------------------------------ */
-        public void addChange(SocketChannel channel, Object att)
+        public void addChange(SelectableChannel channel, Object att)
         {   
-            synchronized (_changes)
-            {
-                _changes[_change].add(channel);
-                _changes[_change].add(att);
-            }
+            if (att==null)
+                addChange(channel);
+            else if (att instanceof EndPoint)
+                addChange(att);
+            else
+                addChange(new ChangeSelectableChannel(channel,att));
         }
         
         /* ------------------------------------------------------------ */
@@ -324,11 +359,13 @@
             try
             {
                 List changes;
+                final Selector selector;
                 synchronized (_changes)
                 {
                     changes=_changes[_change];
                     _change=_change==0?1:0;
                     _selecting=true;
+                    selector=_selector;
                 }
 
                 // Make any key changes required
@@ -337,6 +374,7 @@
                     try
                     {
                         Object o = changes.get(i);
+                        
                         if (o instanceof EndPoint)
                         {
                             // Update the operations for a key.
@@ -347,39 +385,59 @@
                         {
                             dispatch((Runnable)o);
                         }
-                        else if (o instanceof SocketChannel)
+                        else if (o instanceof ChangeSelectableChannel)
                         {
                             // finish accepting/connecting this connection
-                            SocketChannel channel=(SocketChannel)o;
-                            Object att = changes.get(++i);
-                            
-                            if (channel.isRegistered()) // TODO remove this if when all tested and working
-                                throw new IllegalStateException();
+                            final ChangeSelectableChannel asc = (ChangeSelectableChannel)o;
+                            final SelectableChannel channel=asc._channel;
+                            final Object att = asc._attachment;
 
+                            if ((channel instanceof SocketChannel) && ((SocketChannel)channel).isConnected())
+                            {
+                                key = channel.register(selector,SelectionKey.OP_READ,att);
+                                SelectChannelEndPoint endpoint = newEndPoint((SocketChannel)channel,this,key);
+                                key.attach(endpoint);
+                                endpoint.dispatch();
+                            }
+                            else if (channel.isOpen())
+                            {
+                                channel.register(selector,SelectionKey.OP_CONNECT,att);
+                            }
+                        }
+                        else if (o instanceof SocketChannel)
+                        {
+                            final SocketChannel channel=(SocketChannel)o;
+
                             if (channel.isConnected())
                             {
-                                key = channel.register(_selector,SelectionKey.OP_READ,att);
+                                key = channel.register(selector,SelectionKey.OP_READ,null);
                                 SelectChannelEndPoint endpoint = newEndPoint(channel,this,key);
                                 key.attach(endpoint);
                                 endpoint.dispatch();
                             }
                             else if (channel.isOpen())
                             {
-                                channel.register(_selector,SelectionKey.OP_CONNECT,att);
+                                channel.register(selector,SelectionKey.OP_CONNECT,null);
                             }
-
                         }
                         else if (o instanceof ServerSocketChannel)
                         {
                             ServerSocketChannel channel = (ServerSocketChannel)o;
                             channel.register(getSelector(),SelectionKey.OP_ACCEPT);
                         }
+                        else if (o instanceof ChangeTask)
+                        {
+                            ((ChangeTask)o).run();
+                        }
                         else
                             throw new IllegalArgumentException(o.toString());
                     }
                     catch (Exception e)
                     {
-			Log.ignore(e);
+                        if (isRunning())
+                            Log.warn(e);
+                        else
+                            Log.debug(e);
                     }
                 }
                 changes.clear();
@@ -391,7 +449,7 @@
                 {
                     _idleTimeout.setNow(now);
                     _retryTimeout.setNow(now);
-                    if (_lowResourcesConnections>0 && _selector.keys().size()>_lowResourcesConnections)
+                    if (_lowResourcesConnections>0 && selector.keys().size()>_lowResourcesConnections)
                         _idleTimeout.setDuration(_lowResourcesMaxIdleTime);
                     else 
                         _idleTimeout.setDuration(_maxIdleTime);
@@ -407,55 +465,163 @@
                     wait = retry_next;
     
                 // Do the select.
-                if (wait > 10) // TODO tune or configure this
+                if (wait > 2) // TODO tune or configure this
                 {
+                    // If we are in pausing mode
+                    if (_pausing)
+                    {
+                        try
+                        {
+                            Thread.sleep(__BUSY_PAUSE); // pause to reduce impact of  busy loop
+                        }
+                        catch(InterruptedException e)
+                        {
+                            Log.ignore(e);
+                        }
+                    }
+                        
                     long before=now;
-                    int selected=_selector.select(wait);
+                    int selected=selector.select(wait);
                     now = System.currentTimeMillis();
                     _idleTimeout.setNow(now);
                     _retryTimeout.setNow(now);
+                    _selects++;
 
-                    // Look for JVM bug 
-                    if (selected==0 && wait>0 && (now-before)<wait/2 && _selector.selectedKeys().size()==0)
+                    // Look for JVM bugs over a monitor period.
+                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6403933
+                    // http://bugs.sun.com/view_bug.do?bug_id=6693490
+                    if (now>_monitorNext)
                     {
-                        if (_jvmBug++>5)  // TODO tune or configure this
+                        _selects=(int)(_selects*__MONITOR_PERIOD/(now-_monitorStart));
+                        _pausing=_selects>__MAX_SELECTS;
+                        if (_pausing)
+                            _paused++;
+                            
+                        _selects=0;
+                        _jvmBug=0;
+                        _monitorStart=now;
+                        _monitorNext=now+__MONITOR_PERIOD;
+                    }
+                    
+                    if (now>_log)
+                    {
+                        if (_paused>0)  
+                            Log.info(this+" Busy selector - injecting delay "+_paused+" times");
+
+                        if (_jvmFix2>0)
+                            Log.info(this+" JVM BUG(s) - injecting delay"+_jvmFix2+" times");
+
+                        if (_jvmFix1>0)
+                            Log.info(this+" JVM BUG(s) - recreating selector "+_jvmFix1+" times, canceled keys "+_jvmFix0+" times");
+
+                        else if(Log.isDebugEnabled() && _jvmFix0>0)
+                            Log.info(this+" JVM BUG(s) - canceled keys "+_jvmFix0+" times");
+                        _paused=0;
+                        _jvmFix2=0;
+                        _jvmFix1=0;
+                        _jvmFix0=0;
+                        _log=now+60000;
+                    }
+                    
+                    // If we see signature of possible JVM bug, increment count.
+                    if (selected==0 && wait>10 && (now-before)<(wait/2))
+                    {
+                        // Increment bug count and try a work around
+                        _jvmBug++;
+                        if (_jvmBug>(__JVMBUG_THRESHHOLD))
                         {
-                            // Probably JVM BUG!
-                            
-                            Iterator iter = _selector.keys().iterator();
-                            while(iter.hasNext())
+                            try
                             {
-                                key = (SelectionKey) iter.next();
-                                if (key.isValid()&&key.interestOps()==0)
+                                if (_jvmBug==__JVMBUG_THRESHHOLD+1)
+                                    _jvmFix2++;
+                                    
+                                Thread.sleep(__BUSY_PAUSE); // pause to avoid busy loop
+                            }
+                            catch(InterruptedException e)
+                            {
+                                Log.ignore(e);
+                            }
+                        }
+                        else if (_jvmBug==__JVMBUG_THRESHHOLD)
+                        {
+                            synchronized (this)
+                            {
+                                // BLOODY SUN BUG !!!  Try refreshing the entire selector.
+                                _jvmFix1++;
+                                
+                                final Selector new_selector = Selector.open();
+                                Iterator iterator = _selector.keys().iterator();
+                                while (iterator.hasNext())
                                 {
-                                    key.cancel();
+                                    SelectionKey k = (SelectionKey)iterator.next();
+                                    if (!k.isValid() || k.interestOps()==0)
+                                        continue;
+                                    
+                                    final SelectableChannel channel = k.channel();
+                                    final Object attachment = k.attachment();
+                                    
+                                    if (attachment==null)
+                                        addChange(channel);
+                                    else
+                                        addChange(channel,attachment);
                                 }
+                                _selector.close();
+                                _selector=new_selector;
+                                return;
                             }
-                            try
+                        }
+                        else if (_jvmBug%32==31) // heuristic attempt to cancel key 31,63,95,... loops
+                        {
+                            // Cancel keys with 0 interested ops
+                            int cancelled=0;
+                            Iterator iter = selector.keys().iterator();
+                            while(iter.hasNext())
                             {
-                                Thread.sleep(20);  // tune or configure this
+                                SelectionKey k = (SelectionKey) iter.next();
+                                if (k.isValid()&&k.interestOps()==0)
+                                {
+                                    k.cancel();
+                                    cancelled++;
+                                }
                             }
-                            catch (InterruptedException e)
+                            if (cancelled>0)
+                                _jvmFix0++;
+                            
+                            return;
+                        }
+                    }
+                    else if (__BUSY_KEY>0 && selected==1 && _selects>__MAX_SELECTS)
+                    {
+                        // Look for busy key
+                        SelectionKey busy = (SelectionKey)selector.selectedKeys().iterator().next();
+                        if (busy==_busyKey)
+                        {
+                            if (++_busyKeyCount>__BUSY_KEY && !(busy.channel() instanceof ServerSocketChannel))
                             {
-                                Log.ignore(e);
+                                SelectChannelEndPoint endpoint = (SelectChannelEndPoint)busy.attachment();
+                                Log.warn("Busy Key "+busy.channel()+" "+endpoint);
+                                busy.cancel();
+                                if (endpoint!=null)
+                                    endpoint.close();
                             }
-                        } 
+                        }
+                        else
+                            _busyKeyCount=0;
+                        _busyKey=busy;
                     }
-                    else
-                        _jvmBug=0;
                 }
                 else 
                 {
-                    _selector.selectNow();
-                    _jvmBug=0;
+                    selector.selectNow();
+                    _selects++;
                 }
 
-                // have we been destroyed while sleeping\
-                if (_selector==null || !_selector.isOpen())
+                // have we been destroyed while sleeping
+                if (_selector==null || !selector.isOpen())
                     return;
 
                 // Look for things to do
-                Iterator iter = _selector.selectedKeys().iterator();
+                Iterator iter = selector.selectedKeys().iterator();
                 while (iter.hasNext())
                 {
                     key = (SelectionKey) iter.next();
@@ -470,8 +636,9 @@
                                 endpoint.doUpdateKey();
                             continue;
                         }
-
+                        
                         Object att = key.attachment();
+                        
                         if (att instanceof SelectChannelEndPoint)
                         {
                             SelectChannelEndPoint endpoint = (SelectChannelEndPoint)att;
@@ -565,32 +732,12 @@
                 }
                 
                 // Everything always handled
-                _selector.selectedKeys().clear();
+                selector.selectedKeys().clear();
 
                 // tick over the timers
-                Timeout.Task task=null;
-                synchronized (this)
-                {
-                    task=_idleTimeout.expired();
-                    if (task==null)
-                        task=_retryTimeout.expired();
-                }
-
-                // handle any expired timers
-                while (task!=null)
-                {
-                    task.expire();
-
-                    // get the next timer tasks
-                    synchronized(this)
-                    {
-                        if (_selector==null)
-                            break;
-                        task=_idleTimeout.expired();
-                        if (task==null)
-                            task=_retryTimeout.expired();
-                    }
-                }
+                _idleTimeout.tick(now);
+                _retryTimeout.tick(now);
+                
             }
             catch (CancelledKeyException e)
             {
@@ -598,10 +745,7 @@
             }
             finally
             {
-                synchronized(this)
-                {
-                    _selecting=false;
-                }
+                _selecting=false;
             }
         }
 
@@ -651,7 +795,7 @@
         {
             return _selector;
         }
-
+        
         /* ------------------------------------------------------------ */
         void stop() throws Exception
         {
@@ -659,10 +803,7 @@
             while(selecting)
             {
                 wakeup();
-                synchronized (this)
-                {
-                    selecting=_selecting;
-                }
+                selecting=_selecting;
             }
             
             ArrayList keys=new ArrayList(_selector.keys());
@@ -673,9 +814,10 @@
                 SelectionKey key = (SelectionKey)iter.next();
                 if (key==null)
                     continue;
-                EndPoint endpoint = (EndPoint)key.attachment();
-                if (endpoint!=null)
+                Object att=key.attachment();
+                if (att instanceof EndPoint)
                 {
+                    EndPoint endpoint = (EndPoint)att;
                     try
                     {
                         endpoint.close();
@@ -689,6 +831,13 @@
             
             synchronized (this)
             {
+                selecting=_selecting;
+                while(selecting)
+                {
+                    wakeup();
+                    selecting=_selecting;
+                }
+                
                 _idleTimeout.cancelAll();
                 _retryTimeout.cancelAll();
                 try
@@ -705,4 +854,23 @@
         }
     }
 
+    /* ------------------------------------------------------------ */
+    private static class ChangeSelectableChannel
+    {
+        final SelectableChannel _channel;
+        final Object _attachment;
+        
+        public ChangeSelectableChannel(SelectableChannel channel, Object attachment)
+        {
+            super();
+            _channel = channel;
+            _attachment = attachment;
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    private interface ChangeTask
+    {
+        public void run();
+    }
 }
Index: modules/jetty/src/main/java/org/mortbay/io/View.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/View.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/View.java	(working copy)
@@ -131,9 +131,9 @@
      * 
      * @see java.lang.Object#equals(java.lang.Object)
      */
-    public boolean equals(Object arg0)
+    public boolean equals(Object obj)
     {
-        return  this==arg0 || super.equals(arg0);
+        return  this==obj ||((obj instanceof Buffer)&&((Buffer)obj).equals(this)) || super.equals(obj);
     }
 
     /**
@@ -228,5 +228,10 @@
         {
             super(buffer);
         }
+        
+        public boolean equals(Object obj)
+        {
+            return  this==obj ||((obj instanceof Buffer)&&((Buffer)obj).equalsIgnoreCase(this)) || super.equals(obj);
+        }
     }
 }
Index: modules/jetty/src/main/java/org/mortbay/io/bio/SocketEndPoint.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/bio/SocketEndPoint.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/bio/SocketEndPoint.java	(working copy)
@@ -21,6 +21,7 @@
 import java.net.Socket;
 
 import org.mortbay.io.Portable;
+import org.mortbay.log.Log;
 
 /**
  * @author gregw
@@ -57,9 +58,25 @@
      */
     public void close() throws IOException
     {
+        if (!_socket.isClosed() && !_socket.isOutputShutdown())
+        {
+            try
+            {
+                _socket.shutdownOutput();
+            }
+            catch(IOException e)
+            {
+                Log.ignore(e);
+            }
+            catch(UnsupportedOperationException e)
+            {
+                Log.ignore(e);
+            }
+        }
         _socket.close();
         _in=null;
         _out=null;
+        
     }
     
 
@@ -101,6 +118,8 @@
     {
         if (_local==null)
             _local=(InetSocketAddress)_socket.getLocalSocketAddress();
+        if (_local==null)
+            return -1;
         return _local.getPort();
     }
 
@@ -112,7 +131,8 @@
     {
         if (_remote==null)
             _remote=(InetSocketAddress)_socket.getRemoteSocketAddress();
-        
+        if (_remote==null)
+            return null;
         InetAddress addr = _remote.getAddress();
         return ( addr == null ? null : addr.getHostAddress() );
     }
@@ -125,7 +145,8 @@
     {
         if (_remote==null)
             _remote=(InetSocketAddress)_socket.getRemoteSocketAddress();
-        
+        if (_remote==null)
+            return null;
         return _remote.getAddress().getCanonicalHostName();
     }
 
@@ -137,10 +158,11 @@
     {
         if (_remote==null)
             _remote=(InetSocketAddress)_socket.getRemoteSocketAddress();
+        if (_remote==null)
+            return -1;
         return _remote.getPort();
     }
 
-
     /* ------------------------------------------------------------ */
     /* 
      * @see org.mortbay.io.EndPoint#getConnection()
Index: modules/jetty/src/main/java/org/mortbay/io/BufferDateCache.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/BufferDateCache.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/BufferDateCache.java	(working copy)
@@ -1,3 +1,17 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.io;
 
 import java.text.DateFormatSymbols;
Index: modules/jetty/src/main/java/org/mortbay/io/ByteArrayBuffer.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/ByteArrayBuffer.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/ByteArrayBuffer.java	(working copy)
@@ -17,6 +17,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.Arrays;
 
 /* ------------------------------------------------------------------------------- */
 /**
@@ -24,8 +26,13 @@
  */
 public class ByteArrayBuffer extends AbstractBuffer
 {
-    private byte[] _bytes;
+    protected byte[] _bytes;
 
+    protected ByteArrayBuffer(int access, boolean isVolatile)
+    {
+        super(access, isVolatile);
+    }
+    
     public ByteArrayBuffer(byte[] bytes)
     {
         this(bytes, 0, bytes.length, READWRITE);
@@ -70,6 +77,16 @@
         _string = value;
     }
 
+    public ByteArrayBuffer(String value,String encoding) throws UnsupportedEncodingException
+    {
+        super(READWRITE,NON_VOLATILE);
+        _bytes = value.getBytes(encoding);
+        setGetIndex(0);
+        setPutIndex(_bytes.length);
+        _access=IMMUTABLE;
+        _string = value;
+    }
+
     public byte[] array()
     {
         return _bytes;
@@ -79,49 +96,242 @@
     {
         return _bytes.length;
     }
+    
+    public void compact()
+    {
+        if (isReadOnly()) 
+            throw new IllegalStateException(__READONLY);
+        int s = markIndex() >= 0 ? markIndex() : getIndex();
+        if (s > 0)
+        {
+            int length = putIndex() - s;
+            if (length > 0)
+            {
+                Portable.arraycopy(_bytes, s,_bytes, 0, length);
+            }
+            if (markIndex() > 0) setMarkIndex(markIndex() - s);
+            setGetIndex(getIndex() - s);
+            setPutIndex(putIndex() - s);
+        }
+    }
 
+
+    public boolean equals(Object obj)
+    {
+        if (obj==this)
+            return true;
+
+        if (obj == null || !(obj instanceof Buffer)) 
+            return false;
+        
+        if (obj instanceof Buffer.CaseInsensitve)
+            return equalsIgnoreCase((Buffer)obj);
+        
+
+        Buffer b = (Buffer) obj;
+        
+        // reject different lengths
+        if (b.length() != length()) 
+            return false;
+
+        // reject AbstractBuffer with different hash value
+        if (_hash != 0 && obj instanceof AbstractBuffer)
+        {
+            AbstractBuffer ab = (AbstractBuffer) obj;
+            if (ab._hash != 0 && _hash != ab._hash) 
+                return false;
+        }
+
+        // Nothing for it but to do the hard grind.
+        int get=getIndex();
+        int bi=b.putIndex();
+        for (int i = putIndex(); i-->get;)
+        {
+            byte b1 = _bytes[i];
+            byte b2 = b.peek(--bi);
+            if (b1 != b2) return false;
+        }
+        return true;
+    }
+
+
+    public boolean equalsIgnoreCase(Buffer b)
+    {
+        if (b==this)
+            return true;
+        
+        // reject different lengths
+        if (b==null || b.length() != length()) 
+            return false;
+
+        // reject AbstractBuffer with different hash value
+        if (_hash != 0 && b instanceof AbstractBuffer)
+        {
+            AbstractBuffer ab = (AbstractBuffer) b;
+            if (ab._hash != 0 && _hash != ab._hash) return false;
+        }
+
+        // Nothing for it but to do the hard grind.
+        int get=getIndex();
+        int bi=b.putIndex();
+        byte[] barray=b.array();
+        if (barray==null)
+        {
+            for (int i = putIndex(); i-->get;)
+            {
+                byte b1 = _bytes[i];
+                byte b2 = b.peek(--bi);
+                if (b1 != b2)
+                {
+                    if ('a' <= b1 && b1 <= 'z') b1 = (byte) (b1 - 'a' + 'A');
+                    if ('a' <= b2 && b2 <= 'z') b2 = (byte) (b2 - 'a' + 'A');
+                    if (b1 != b2) return false;
+                }
+            }
+        }
+        else
+        {
+            for (int i = putIndex(); i-->get;)
+            {
+                byte b1 = _bytes[i];
+                byte b2 = barray[--bi];
+                if (b1 != b2)
+                {
+                    if ('a' <= b1 && b1 <= 'z') b1 = (byte) (b1 - 'a' + 'A');
+                    if ('a' <= b2 && b2 <= 'z') b2 = (byte) (b2 - 'a' + 'A');
+                    if (b1 != b2) return false;
+                }
+            }
+        }
+        return true;
+    }
+
     public byte get()
     {
         return _bytes[_get++];
     }
+
+    public int hashCode()
+    {
+        if (_hash == 0 || _hashGet!=_get || _hashPut!=_put) 
+        {
+            int get=getIndex();
+            for (int i = putIndex(); i-- >get;)
+            {
+                byte b = _bytes[i];
+                if ('a' <= b && b <= 'z') 
+                    b = (byte) (b - 'a' + 'A');
+                _hash = 31 * _hash + b;
+            }
+            if (_hash == 0) 
+                _hash = -1;
+            _hashGet=_get;
+            _hashPut=_put;
+        }
+        return _hash;
+    }
     
+    
     public byte peek(int index)
     {
         return _bytes[index];
     }
-
+    
     public int peek(int index, byte[] b, int offset, int length)
     {
         int l = length;
-        if (index + l > capacity()) l = capacity() - index;
-        if (l <= 0) return -1;
+        if (index + l > capacity())
+        {
+            l = capacity() - index;
+            if (l==0)
+                return -1;
+        }
+        
+        if (l < 0) 
+            return -1;
+        
         Portable.arraycopy(_bytes, index, b, offset, l);
         return l;
     }
 
     public void poke(int index, byte b)
     {
-        if (isReadOnly()) throw new IllegalStateException(__READONLY);
-        if (index < 0) throw new IllegalArgumentException("index<0: " + index + "<0");
+        /* 
+        if (isReadOnly()) 
+            throw new IllegalStateException(__READONLY);
+        
+        if (index < 0) 
+            throw new IllegalArgumentException("index<0: " + index + "<0");
         if (index > capacity())
                 throw new IllegalArgumentException("index>capacity(): " + index + ">" + capacity());
+        */
         _bytes[index] = b;
     }
     
-    public static class CaseInsensitive extends ByteArrayBuffer implements Buffer.CaseInsensitve
+    public int poke(int index, Buffer src)
     {
-        public CaseInsensitive(String s)
+        _hash=0;
+        
+        /* 
+        if (isReadOnly()) 
+            throw new IllegalStateException(__READONLY);
+        if (index < 0) 
+            throw new IllegalArgumentException("index<0: " + index + "<0");
+        */
+        
+        int length=src.length();
+        if (index + length > capacity())
         {
-            super(s);
+            length=capacity()-index;
+            /*
+            if (length<0)
+                throw new IllegalArgumentException("index>capacity(): " + index + ">" + capacity());
+            */
         }
+        
+        byte[] src_array = src.array();
+        if (src_array != null)
+            Portable.arraycopy(src_array, src.getIndex(), _bytes, index, length);
+        else if (src_array != null)
+        {
+            int s=src.getIndex();
+            for (int i=0;i<length;i++)
+                poke(index++,src_array[s++]);
+        }
+        else 
+        {
+            int s=src.getIndex();
+            for (int i=0;i<length;i++)
+                _bytes[index++]=src.peek(s++);
+        }
+        
+        return length;
+    }
+    
 
-        public CaseInsensitive(byte[] b, int o, int l, int rw)
+    public int poke(int index, byte[] b, int offset, int length)
+    {
+        _hash=0;
+        /*
+        if (isReadOnly()) 
+            throw new IllegalStateException(__READONLY);
+        if (index < 0) 
+            throw new IllegalArgumentException("index<0: " + index + "<0");
+        */
+        
+        if (index + length > capacity())
         {
-            super(b,o,l,rw);
+            length=capacity()-index;
+            /* if (length<0)
+                throw new IllegalArgumentException("index>capacity(): " + index + ">" + capacity());
+            */
         }
+        
+        Portable.arraycopy(b, offset, _bytes, index, length);
+        
+        return length;
     }
 
-
     /* ------------------------------------------------------------ */
     /** Wrap a byte array.
      * @param b
@@ -186,4 +396,33 @@
             return -1;
         return total;
     }
+
+    /* ------------------------------------------------------------ */
+    public int space()
+    {
+        return _bytes.length - _put;
+    }
+
+    
+    /* ------------------------------------------------------------ */
+    /* ------------------------------------------------------------ */
+    /* ------------------------------------------------------------ */
+    public static class CaseInsensitive extends ByteArrayBuffer implements Buffer.CaseInsensitve
+    {
+        public CaseInsensitive(String s)
+        {
+            super(s);
+        }
+
+        public CaseInsensitive(byte[] b, int o, int l, int rw)
+        {
+            super(b,o,l,rw);
+        }
+
+        public boolean equals(Object obj)
+        {
+            return equalsIgnoreCase((Buffer)obj);
+        }
+        
+    }
 }
Index: modules/jetty/src/main/java/org/mortbay/io/AbstractBuffer.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/io/AbstractBuffer.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/io/AbstractBuffer.java	(working copy)
@@ -36,11 +36,11 @@
     protected int _get;
     protected int _put;
     protected int _hash;
-    private int _hashGet;
-    private int _hashPut;
-    private int _mark;
+    protected int _hashGet;
+    protected int _hashPut;
+    protected int _mark;
     protected String _string;
-    private View _view;
+    protected View _view;
 
     /**
      * Constructor for BufferView
@@ -171,10 +171,12 @@
         }
 
         // Nothing for it but to do the hard grind.
-        for (int i = length(); i-- > 0;)
+        int get=getIndex();
+        int bi=b.putIndex();
+        for (int i = putIndex(); i-->get;)
         {
-            byte b1 = peek(getIndex() + i);
-            byte b2 = b.peek(b.getIndex() + i);
+            byte b1 = peek(i);
+            byte b2 = b.peek(--bi);
             if (b1 != b2) return false;
         }
         return true;
@@ -196,17 +198,39 @@
         }
 
         // Nothing for it but to do the hard grind.
-        for (int i = length(); i-- > 0;)
+        int get=getIndex();
+        int bi=b.putIndex();
+        
+        byte[] array = array();
+        byte[] barray= b.array();
+        if (array!=null && barray!=null)
         {
-            byte b1 = peek(getIndex() + i);
-            byte b2 = b.peek(b.getIndex() + i);
-            if (b1 != b2)
+            for (int i = putIndex(); i-->get;)
             {
-                if ('a' <= b1 && b1 <= 'z') b1 = (byte) (b1 - 'a' + 'A');
-                if ('a' <= b2 && b2 <= 'z') b2 = (byte) (b2 - 'a' + 'A');
-                if (b1 != b2) return false;
+                byte b1 = array[i];
+                byte b2 = barray[--bi];
+                if (b1 != b2)
+                {
+                    if ('a' <= b1 && b1 <= 'z') b1 = (byte) (b1 - 'a' + 'A');
+                    if ('a' <= b2 && b2 <= 'z') b2 = (byte) (b2 - 'a' + 'A');
+                    if (b1 != b2) return false;
+                }
             }
         }
+        else
+        {
+            for (int i = putIndex(); i-->get;)
+            {
+                byte b1 = peek(i);
+                byte b2 = b.peek(--bi);
+                if (b1 != b2)
+                {
+                    if ('a' <= b1 && b1 <= 'z') b1 = (byte) (b1 - 'a' + 'A');
+                    if ('a' <= b2 && b2 <= 'z') b2 = (byte) (b2 - 'a' + 'A');
+                    if (b1 != b2) return false;
+                }
+            }
+        }
         return true;
     }
 
@@ -219,10 +243,15 @@
     {
         int gi = getIndex();
         int l=length();
+        if (l==0)
+            return -1;
+        
         if (length>l)
             length=l;
+        
         length = peek(gi, b, offset, length);
-        setGetIndex(gi + length);
+        if (length>0)
+            setGetIndex(gi + length);
         return length;
     }
 
@@ -248,15 +277,33 @@
     {
         if (_hash == 0 || _hashGet!=_get || _hashPut!=_put) 
         {
-            for (int i = putIndex(); i-- > getIndex();)
+            int get=getIndex();
+            byte[] array = array();
+            if (array==null)
             {
-                byte b = peek(i);
-                if ('a' <= b && b <= 'z') b = (byte) (b - 'a' + 'A');
-                _hash = 31 * _hash + b;
+                for (int i = putIndex(); i-- >get;)
+                {
+                    byte b = peek(i);
+                    if ('a' <= b && b <= 'z') 
+                        b = (byte) (b - 'a' + 'A');
+                    _hash = 31 * _hash + b;
+                }
             }
-            if (_hash == 0) _hash = -1;
+            else
+            {
+                for (int i = putIndex(); i-- >get;)
+                {
+                    byte b = array[i];
+                    if ('a' <= b && b <= 'z') 
+                        b = (byte) (b - 'a' + 'A');
+                    _hash = 31 * _hash + b;
+                }
+            }
+            if (_hash == 0) 
+                _hash = -1;
             _hashGet=_get;
             _hashPut=_put;
+            
         }
         return _hash;
     }
@@ -322,15 +369,21 @@
     public int poke(int index, Buffer src)
     {
         _hash=0;
-        if (isReadOnly()) throw new IllegalStateException(__READONLY);
-        if (index < 0) throw new IllegalArgumentException("index<0: " + index + "<0");
+        /* 
+        if (isReadOnly()) 
+            throw new IllegalStateException(__READONLY);
+        if (index < 0) 
+            throw new IllegalArgumentException("index<0: " + index + "<0");
+        */
         
         int length=src.length();
         if (index + length > capacity())
         {
             length=capacity()-index;
+            /*
             if (length<0)
                 throw new IllegalArgumentException("index>capacity(): " + index + ">" + capacity());
+            */
         }
         
         byte[] src_array = src.array();
@@ -363,14 +416,18 @@
     public int poke(int index, byte[] b, int offset, int length)
     {
         _hash=0;
-        if (isReadOnly()) throw new IllegalStateException(__READONLY);
-        if (index < 0) throw new IllegalArgumentException("index<0: " + index + "<0");
-
+        /*
+        if (isReadOnly()) 
+            throw new IllegalStateException(__READONLY);
+        if (index < 0) 
+            throw new IllegalArgumentException("index<0: " + index + "<0");
+        */
         if (index + length > capacity())
         {
             length=capacity()-index;
-            if (length<0)
+            /* if (length<0)
                 throw new IllegalArgumentException("index>capacity(): " + index + ">" + capacity());
+            */
         }
         
         byte[] dst_array = array();
@@ -432,13 +489,15 @@
         setMarkIndex(-1);
     }
 
-
     public void setGetIndex(int getIndex)
     {
         /* bounds checking
-        if (isImmutable()) new throw IllegalStateException(__IMMUTABLE);
-        if (getIndex < 0) throw new IllegalArgumentException("getIndex<0: " + getIndex + "<0");
-        if (getIndex > putIndex()) throw new IllegalArgumentException("getIndex>putIndex: " + getIndex + ">" + putIndex());
+        if (isImmutable()) 
+            throw new IllegalStateException(__IMMUTABLE);
+        if (getIndex < 0)
+            throw new IllegalArgumentException("getIndex<0: " + getIndex + "<0");
+        if (getIndex > putIndex())
+            throw new IllegalArgumentException("getIndex>putIndex: " + getIndex + ">" + putIndex());
          */
         _get = getIndex;
         _hash=0;
@@ -446,14 +505,18 @@
 
     public void setMarkIndex(int index)
     {
-        if (index>=0 && isImmutable()) throw new IllegalStateException(__IMMUTABLE);
+        /*
+        if (index>=0 && isImmutable()) 
+            throw new IllegalStateException(__IMMUTABLE);
+        */
         _mark = index;
     }
 
     public void setPutIndex(int putIndex)
     {
         /* bounds checking
-        if (isImmutable()) new throw IllegalStateException(__IMMUTABLE);
+        if (isImmutable()) 
+            throw new IllegalStateException(__IMMUTABLE);
         if (putIndex > capacity())
                 throw new IllegalArgumentException("putIndex>capacity: " + putIndex + ">" + capacity());
         if (getIndex() > putIndex)
@@ -490,7 +553,7 @@
 
     public int space()
     {
-        return capacity() - putIndex();
+        return capacity() - _put;
     }
 
     public String toDetailString()
@@ -570,7 +633,7 @@
     public void writeTo(OutputStream out)
     	throws IOException
     {
-        byte array[] = array();
+        byte[] array = array();
         
         if (array!=null)
         {
@@ -578,11 +641,16 @@
         }
         else
         {
-            // System.err.println(this.getClass()+" OUCH!!!! Abstract writeTo: ? "+getIndex()+"-"+putIndex());
-            
-            // TODO perhaps in buffer?
-            for (int i=_get;i<_put;i++)
-                out.write(peek(i));
+            int len = this.length();
+            byte[] buf=new byte[len>1024?1024:len];
+            int offset=_get;
+            while (len>0)
+            {
+                int l=peek(offset,buf,0,len>buf.length?buf.length:len);
+                out.write(buf,0,l);
+                offset+=l;
+                len-=l;
+            }
         } 
         clear();
     }
@@ -590,17 +658,32 @@
     /* ------------------------------------------------------------ */
     public int readFrom(InputStream in,int max) throws IOException
     {
-        // System.err.println(this.getClass()+" OUCH!!!! Abstract readFrom "+max+" "+getIndex()+"-"+putIndex());
-        int len=0;
-        while (space()>0)
+        byte[] array = array();
+        int s=space();
+        if (s>max)
+            s=max;
+
+        if (array!=null)
         {
-            // TODO perhaps buffer
-            int b = in.read();
-            if (b<0)
-                return -1;
-            put((byte)b);
-            len++;
+            int l=in.read(array,_put,s);
+            if (l>0)
+                _put+=l;
+            return l;
         }
-        return len;
+        else
+        {
+            byte[] buf=new byte[s>1024?1024:s];
+            int total=0;
+            while (s>0)
+            {
+                int l=in.read(buf,0,buf.length);
+                if (l<0)
+                    return total>0?total:-1;
+                int p=put(buf,0,l);
+                assert l==p;
+                s-=l;
+            }
+            return total; 
+        }
     }
 }
Index: modules/jetty/src/main/java/org/mortbay/resource/JarResource.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/resource/JarResource.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/resource/JarResource.java	(working copy)
@@ -22,9 +22,11 @@
 import java.net.URL;
 import java.util.jar.JarEntry;
 import java.util.jar.JarInputStream;
+import java.util.jar.Manifest;
 
 import org.mortbay.log.Log;
 import org.mortbay.util.IO;
+import org.mortbay.util.URIUtil;
 
 
 /* ------------------------------------------------------------ */
@@ -138,10 +140,10 @@
         JarInputStream jin = new JarInputStream(is);
         JarEntry entry;
         boolean shouldExtract;
+        String directoryCanonicalPath = directory.getCanonicalPath()+"/";
         while((entry=jin.getNextJarEntry())!=null)
         {
             String entryName = entry.getName();
-           
             if ((subEntryName != null) && (entryName.startsWith(subEntryName)))
             { 
                 //if there is a particular subEntry that we are looking for, only
@@ -183,8 +185,16 @@
                 continue;
             }
                 
-           
+            String dotCheck = entryName.replace('\\', '/');   
+            dotCheck = URIUtil.canonicalPath(dotCheck);
+            if (dotCheck == null)
+            {
+                if (Log.isDebugEnabled()) Log.debug("Invalid entry: "+entryName);
+                continue;
+            }
+            
             File file=new File(directory,entryName);
+          
             if (entry.isDirectory())
             {
                 // Make directory
@@ -217,6 +227,21 @@
             if (deleteOnExit)
                 file.deleteOnExit();
         }
+        
+        if ((subEntryName == null) || (subEntryName != null && subEntryName.equalsIgnoreCase("META-INF/MANIFEST.MF")))
+        {
+            Manifest manifest = jin.getManifest();
+            if (manifest != null)
+            {
+                File metaInf = new File (directory, "META-INF");
+                metaInf.mkdir();
+                File f = new File(metaInf, "MANIFEST.MF");
+                FileOutputStream fout = new FileOutputStream(f);
+                manifest.write(fout);
+                fout.close();   
+            }
+        }
+        IO.close(jin);
     }
     
     /* ------------------------------------------------------------ */
Index: modules/jetty/src/main/java/org/mortbay/resource/FileResource.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/resource/FileResource.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/resource/FileResource.java	(working copy)
@@ -51,7 +51,9 @@
             (System.getProperty("org.mortbay.util.FileResource.checkAliases","true"));
  
        if (__checkAliases)
-            Log.debug("Checking Resource aliases");
+           Log.debug("Checking Resource aliases");
+       else
+           Log.warn("Resource alias checking is disabled");
     }
     
     /* ------------------------------------------------------------ */
Index: modules/jetty/src/main/java/org/mortbay/resource/Resource.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/resource/Resource.java	(revision 5689)
+++ modules/jetty/src/main/java/org/mortbay/resource/Resource.java	(working copy)
@@ -30,6 +30,7 @@
 import org.mortbay.util.Loader;
 import org.mortbay.util.StringUtil;
 import org.mortbay.util.URIUtil;
+import org.mortbay.util.UrlEncoded;
 
 
 /* ------------------------------------------------------------ */
@@ -148,7 +149,7 @@
                         resource=resource.substring(2);
                     
                     File file=new File(resource).getCanonicalFile();
-                    url=file.toURI().toURL();                    
+                    url=new URL(URIUtil.encodePath(file.toURL().toString()));                    
                     
                     URLConnection connection=url.openConnection();
                     connection.setUseCaches(useCaches);
@@ -417,11 +418,11 @@
      * @param parent True if the parent directory should be included
      * @return String of HTML
      */
-    public String getListHTML(String base,
-                              boolean parent)
+    public String getListHTML(String base,boolean parent)
         throws IOException
     {
-        if (!isDirectory())
+        base=URIUtil.canonicalPath(base);
+        if (base==null || !isDirectory())
             return null;
         
         String[] ls = list();
@@ -430,43 +431,47 @@
         Arrays.sort(ls);
         
         String decodedBase = URIUtil.decodePath(base);
-        String title = "Directory: "+decodedBase;
+        String title = "Directory: "+deTag(decodedBase);
 
         StringBuffer buf=new StringBuffer(4096);
         buf.append("<HTML><HEAD><TITLE>");
         buf.append(title);
         buf.append("</TITLE></HEAD><BODY>\n<H1>");
         buf.append(title);
-        buf.append("</H1><TABLE BORDER=0>");
+        buf.append("</H1>\n<TABLE BORDER=0>\n");
         
         if (parent)
         {
-            buf.append("<TR><TD><A HREF=");
+            buf.append("<TR><TD><A HREF=\"");
             buf.append(URIUtil.addPaths(base,"../"));
-            buf.append(">Parent Directory</A></TD><TD></TD><TD></TD></TR>\n");
+            buf.append("\">Parent Directory</A></TD><TD></TD><TD></TD></TR>\n");
         }
         
+        String defangedBase = defangURI(base);
+        
         DateFormat dfmt=DateFormat.getDateTimeInstance(DateFormat.MEDIUM,
                                                        DateFormat.MEDIUM);
         for (int i=0 ; i< ls.length ; i++)
         {
-            String encoded=URIUtil.encodePath(ls[i]);
             Resource item = addPath(ls[i]);
             
-            buf.append("<TR><TD><A HREF=\"");
-            String path=URIUtil.addPaths(base,encoded);
+            buf.append("\n<TR><TD><A HREF=\"");
+            String path=URIUtil.addPaths(defangedBase,URIUtil.encodePath(ls[i]));
             
+            buf.append(path);
+            
             if (item.isDirectory() && !path.endsWith("/"))
-                path=URIUtil.addPaths(path,URIUtil.SLASH);
-            buf.append(path);
+                buf.append(URIUtil.SLASH);
+            
+            // URIUtil.encodePath(buf,path);
             buf.append("\">");
-            buf.append(StringUtil.replace(StringUtil.replace(ls[i],"<","&lt;"),">","&gt;"));
+            buf.append(deTag(ls[i]));
             buf.append("&nbsp;");
             buf.append("</TD><TD ALIGN=right>");
             buf.append(item.length());
             buf.append(" bytes&nbsp;</TD><TD>");
             buf.append(dfmt.format(new Date(item.lastModified())));
-            buf.append("</TD></TR>\n");
+            buf.append("</TD></TR>");
         }
         buf.append("</TABLE>\n");
 	buf.append("</BODY></HTML>\n");
@@ -474,6 +479,70 @@
         return buf.toString();
     }
     
+    /**
+     * Defang any characters that could break the URI string in an HREF.
+     * Such as <a href="/path/to;<script>Window.alert("XSS"+'%20'+"here");</script>">Link</a>
+     * 
+     * The above example would parse incorrectly on various browsers as the "<" or '"' characters
+     * would end the href attribute value string prematurely.
+     * 
+     * @param raw the raw text to defang.
+     * @return the defanged text.
+     */
+    private static String defangURI(String raw) 
+    {
+        StringBuffer buf = null;
+        
+        if (buf==null)
+        {
+            for (int i=0;i<raw.length();i++)
+            {
+                char c=raw.charAt(i);
+                switch(c)
+                {
+                    case '\'':
+                    case '"':
+                    case '<':
+                    case '>':
+                        buf=new StringBuffer(raw.length()<<1);
+                        break;
+                }
+            }
+            if (buf==null)
+                return raw;
+        }
+        
+        for (int i=0;i<raw.length();i++)
+        {
+            char c=raw.charAt(i);       
+            switch(c)
+            {
+              case '"':
+                  buf.append("%22");
+                  continue;
+              case '\'':
+                  buf.append("%27");
+                  continue;
+              case '<':
+                  buf.append("%3C");
+                  continue;
+              case '>':
+                  buf.append("%3E");
+                  continue;
+              default:
+                  buf.append(c);
+                  continue;
+            }
+        }
+
+        return buf.toString();
+    }
+    
+    private static String deTag(String raw) 
+    {
+        return StringUtil.replace( StringUtil.replace(raw,"<","&lt;"), ">", "&gt;");
+    }
+    
     /* ------------------------------------------------------------ */
     /** 
      * @param out 
@@ -490,7 +559,7 @@
             if (count<0)
                 IO.copy(in,out);
             else
-                IO.copy(in,out,(int)count);
+                IO.copy(in,out,count);
         }
         finally
         {
Index: modules/jetty/src/main/resources/org/mortbay/jetty/mime.properties
===================================================================
--- modules/jetty/src/main/resources/org/mortbay/jetty/mime.properties	(revision 5689)
+++ modules/jetty/src/main/resources/org/mortbay/jetty/mime.properties	(working copy)
@@ -2,6 +2,7 @@
 aif	= audio/x-aiff
 aifc	= audio/x-aiff
 aiff	= audio/x-aiff
+apk     = application/vnd.android.package-archive
 asc	= text/plain
 asf     = video/x.ms.asf
 asx     = video/x.ms.asx
@@ -36,6 +37,7 @@
 gzip	= application/gzip
 hdf	= application/x-hdf
 hqx	= application/mac-binhex40
+htc = text/x-component
 html	= text/html
 htm	= text/html
 ice	= x-conference/x-cooltalk
@@ -76,7 +78,24 @@
 msi	= application/octet-stream
 nc	= application/x-netcdf
 oda	= application/oda
+odb     = application/vnd.oasis.opendocument.database
+odc     = application/vnd.oasis.opendocument.chart
+odf     = application/vnd.oasis.opendocument.formula
+odg     = application/vnd.oasis.opendocument.graphics
+odi     = application/vnd.oasis.opendocument.image
+odm     = application/vnd.oasis.opendocument.text-master
+odp     = application/vnd.oasis.opendocument.presentation
+ods     = application/vnd.oasis.opendocument.spreadsheet
+odt     = application/vnd.oasis.opendocument.text
 ogg	= application/ogg
+otc     = application/vnd.oasis.opendocument.chart-template
+otf     = application/vnd.oasis.opendocument.formula-template
+otg     = application/vnd.oasis.opendocument.graphics-template
+oth     = application/vnd.oasis.opendocument.text-web
+oti     = application/vnd.oasis.opendocument.image-template
+otp     = application/vnd.oasis.opendocument.presentation-template
+ots     = application/vnd.oasis.opendocument.spreadsheet-template
+ott     = application/vnd.oasis.opendocument.text-template
 pbm	= image/x-portable-bitmap
 pdb	= chemical/x-pdb
 pdf	= application/pdf
@@ -85,6 +104,7 @@
 png	= image/png
 pnm	= image/x-portable-anymap
 ppm	= image/x-portable-pixmap
+pps = application/vnd.ms-powerpoint
 ppt	= application/vnd.ms-powerpoint
 ps	= application/postscript
 qt	= video/quicktime
Index: modules/jetty/src/main/resources/org/mortbay/jetty/webapp/webdefault.xml
===================================================================
--- modules/jetty/src/main/resources/org/mortbay/jetty/webapp/webdefault.xml	(revision 5689)
+++ modules/jetty/src/main/resources/org/mortbay/jetty/webapp/webdefault.xml	(working copy)
@@ -69,6 +69,10 @@
   <!--   dirAllowed       If true, directory listings are returned if no    -->
   <!--                    welcome file is found. Else 403 Forbidden.        -->
   <!--                                                                      -->
+  <!--   welcomeServlets  If true, attempt to dispatch to welcome files     -->
+  <!--                    that are servlets, if no matching static          --> 
+  <!--                    resources can be found.                           -->
+  <!--                                                                      -->
   <!--   redirectWelcome  If true, redirect welcome file requests           -->
   <!--                    else use request dispatcher forwards              -->
   <!--                                                                      -->
@@ -118,16 +122,20 @@
       <param-value>true</param-value>
     </init-param>
     <init-param>
+      <param-name>welcomeServlets</param-name>
+      <param-value>false</param-value>
+    </init-param>
+    <init-param>
       <param-name>redirectWelcome</param-name>
       <param-value>false</param-value>
     </init-param>
     <init-param>
       <param-name>maxCacheSize</param-name>
-      <param-value>4000000</param-value>
+      <param-value>256000000</param-value>
     </init-param>
     <init-param>
       <param-name>maxCachedFileSize</param-name>
-      <param-value>254000</param-value>
+      <param-value>10000000</param-value>
     </init-param>
     <init-param>
       <param-name>maxCachedFiles</param-name>
Index: modules/jetty/src/main/resources/org/mortbay/xml/configure_6_0.dtd
===================================================================
--- modules/jetty/src/main/resources/org/mortbay/xml/configure_6_0.dtd	(revision 5689)
+++ modules/jetty/src/main/resources/org/mortbay/xml/configure_6_0.dtd	(working copy)
@@ -2,8 +2,8 @@
 
 <!--
 This is the document type descriptor for the
-org.mortbay.util.XmlConfiguration class.  It allows a java object to be
-configured by with a sequence of Set, Put and Call elements.  These tags are 
+org.mortbay.XmlConfiguration class.  It allows a java object to be
+configured by with a sequence of Set, Put and Call elements.  These tags are
 mapped to methods on the object to be configured as follows:
 
   <Set  name="Test">value</Set>              ==  obj.setTest("value");
@@ -19,8 +19,8 @@
 $Id: configure_1_3.dtd,v 1.2 2005/10/26 20:48:48 gregwilkins Exp $
 -->
 
-<!ENTITY % CONFIG "Get|Set|Put|Call|New|Ref|Array|Property">
-<!ENTITY % VALUE "#PCDATA|Call|New|Get|SystemProperty|Array|Ref|Property">
+<!ENTITY % CONFIG "Set|Get|Put|Call|New|Ref|Array|Map|Property">
+<!ENTITY % VALUE "#PCDATA|Get|Call|New|Ref|Array|Map|SystemProperty|Property">
 
 <!ENTITY % TYPEATTR "type CDATA #IMPLIED " > <!-- String|Character|Short|Byte|Integer|Long|Boolean|Float|Double|char|short|byte|int|long|boolean|float|double|URL|InetAddress|InetAddrPort| #classname -->
 <!ENTITY % IMPLIEDCLASSATTR "class NMTOKEN #IMPLIED" >
@@ -29,14 +29,14 @@
 <!ENTITY % DEFAULTATTR "default CDATA #IMPLIED" >
 <!ENTITY % IDATTR "id NMTOKEN #IMPLIED" >
 <!ENTITY % REQUIREDIDATTR "id NMTOKEN #REQUIRED" >
+
+
 <!--
 Configure Element.
 This is the root element that specifies the class of object that
 can be configured:
 
     <Configure class="com.acme.MyClass"> ... </Configure>
-
-A Configure element can contain Set, Put or Call elements.
 -->
 <!ELEMENT Configure (%CONFIG;)* >
 <!ATTLIST Configure %IMPLIEDCLASSATTR; %IDATTR; >
@@ -44,12 +44,13 @@
 
 <!--
 Set Element.
-This element maps to a call to a set method on the current object.
-The name and optional type attributes are used to select the set 
+This element maps to a call to a setter method or field on the current object.
+The name and optional type attributes are used to select the setter
 method. If the name given is xxx, then a setXxx method is used, or
-the xxx field is used of setXxx cannot be found. 
-A Set element can contain value text and/or the value elements Call,
-New and SystemProperty. If no value type is specified, then white
+the xxx field is used of setXxx cannot be found.
+A Set element can contain value text and/or the value objects returned
+by other elements such as Call, New, SystemProperty, etc.
+If no value type is specified, then white
 space is trimmed out of the value. If it contains multiple value
 elements they are added as strings before being converted to any
 specified type.
@@ -62,27 +63,28 @@
 
 <!--
 Get Element.
-This element maps to a call to a get method or field on the current object.
+This element maps to a call to a getter method or field on the current object.
 The name attribute is used to select the get method.
 If the name given is xxx, then a getXxx method is used, or
-the xxx field is used of setXxx cannot be found. 
-A Get element can contain Set, Put and/or Call elements which act on the object
-returned by the get call.
+the xxx field is used if getXxx cannot be found.
+A Get element can contain other elements such as Set, Put, Call, etc.
+which act on the object returned by the get call.
 
 A Get with a class attribute is treated as a static get method or field.
 -->
 <!ELEMENT Get (%CONFIG;)*>
 <!ATTLIST Get %NAMEATTR; %IMPLIEDCLASSATTR; %IDATTR; >
 
+
 <!--
 Put Element.
 This element maps to a call to a put method on the current object,
-which must implement the Map interface. The name attribute is used 
-as the put key and the optional type attribute can force the type 
+which must implement the Map interface. The name attribute is used
+as the put key and the optional type attribute can force the type
 of the value.
 
-A Put element can contain value text and/or the value elements Call,
-New and SystemProperty. If no value type is specified, then white
+A Put element can contain value text and/or value elements such as Call,
+New, SystemProperty, etc. If no value type is specified, then white
 space is trimmed out of the value. If it contains multiple value
 elements they are added as strings before being converted to any
 specified type.
@@ -97,10 +99,13 @@
 The name attribute and Arg elements are used to select the method.
 
 A Call element can contain a sequence of Arg elements followed by
-a sequence of Set, Put and/or Call elements which act on any object
+a sequence of other elements such as Set, Put, Call, etc. which act on any object
 returned by the original call:
 
- <Call name="test"><Arg>value1</Arg><Set name="Test">Value2</Set></Call>
+ <Call id="o2" name="test">
+   <Arg>value1</Arg>
+   <Set name="Test">Value2</Set>
+ </Call>
 
 This is equivalent to:
 
@@ -108,7 +113,6 @@
  o2.setTest("value2");
 
 A Call with a class attribute is treated as a static call.
-
 -->
 <!ELEMENT Call (Arg*,(%CONFIG;)*)>
 <!ATTLIST Call %NAMEATTR; %IMPLIEDCLASSATTR; %IDATTR;>
@@ -119,8 +123,8 @@
 This element defines a positional argument for the Call element.
 The optional type attribute can force the type of the value.
 
-An Arg element can contain value text and/or the value elements Call,
-New and SystemProperty. If no value type is specified, then white
+An Arg element can contain value text and/or value elements such as Call,
+New, SystemProperty, etc. If no value type is specified, then white
 space is trimmed out of the value. If it contains multiple value
 elements they are added as strings before being converted to any
 specified type.
@@ -129,51 +133,51 @@
 <!ATTLIST Arg %TYPEATTR; >
 
 
-
 <!--
 New Element.
-This element allows the creation of a new object as part of a 
-value of a Set, Put or Arg element. The class attribute determines
-the type of the new object and the contained Arg elements 
+This element allows the creation of a new object as part of a
+value for elements such as Set, Put, Arg, etc. The class attribute determines
+the type of the new object and the contained Arg elements
 are used to select the constructor for the new object.
 
 A New element can contain a sequence of Arg elements followed by
-a sequence of Set, Put and/or Call elements which act on the new object:
+a sequence of elements such as Set, Put, Call, etc. elements
+which act on the new object:
 
- <New class="com.acme.MyClass">
-   <Arg>value1</Arg><Set name="Test">Value2</Set>
+ <New id="o" class="com.acme.MyClass">
+   <Arg>value1</Arg>
+   <Set name="test">Value2</Set>
  </New>
 
 This is equivalent to:
 
  Object o = new com.acme.MyClass("value1");
- o.setTest("value2");
-
+ o.setTest("Value2");
 -->
 <!ELEMENT New (Arg*,(%CONFIG;)*)>
 <!ATTLIST New %CLASSATTR; %IDATTR;>
 
+
 <!--
 Ref Element.
-This element allows a previously created object to be reference by id.
-
-A Ref element can contain a sequence of Set, Put and/or Call elements 
+This element allows a previously created object to be referenced by id.
+A Ref element can contain a sequence of elements such as Set, Put, Call, etc.
 which act on the referenced object:
 
  <Ref id="myobject">
    <Set name="Test">Value2</Set>
  </New>
-
 -->
 <!ELEMENT Ref ((%CONFIG;)*)>
 <!ATTLIST Ref %REQUIREDIDATTR;>
 
+
 <!--
 Array Element.
-This element allows the creation of a new array as part of a 
-value of a Set, Put or Arg element. The type attribute determines
-the type of the new array and the contained Item elements 
-are used for each element of the array
+This element allows the creation of a new array as part of a
+value of elements such as Set, Put, Arg, etc. The type attribute determines
+the type of the new array and the contained Item elements
+are used for each element of the array:
 
  <Array type="java.lang.String">
    <Item>value0</Item>
@@ -182,17 +186,17 @@
 
 This is equivalent to:
  String[] a = new String[] { "value0", new String("value1") };
-
 -->
 <!ELEMENT Array (Item*)>
 <!ATTLIST Array %TYPEATTR; %IDATTR; >
 
+
 <!--
 Map Element.
-This element allows the creation of a new array as part of a 
-value of a Set, Put or Arg element. The type attribute determines
-the type of the new array and the contained Item elements 
-are used for each element of the array
+This element allows the creation of a new map as part of a
+value of elements such as Set, Put, Arg, etc. The type attribute determines
+the type of the new array and the contained Item elements
+are used for each element of the array:
 
  <Map>
    <Entry>
@@ -202,8 +206,8 @@
  </Map>
 
 This is equivalent to:
- String[] a = new String[] { "value0", new String("value1") };
-
+ Map m = new HashMap();
+ m.put("keyName", new String("value1"));
 -->
 <!ELEMENT Map (Entry*)>
 <!ATTLIST Map %IDATTR; >
@@ -215,11 +219,11 @@
 This element defines an entry for the Array or Map Entry elements.
 The optional type attribute can force the type of the value.
 
-An Item element can contain value text and/or the value elements Call,
-New and SystemProperty. If no value type is specified, then white
-space is trimmed out of the value. If it contains multiple value
-elements they are added as strings before being converted to any
-specified type.
+An Item element can contain value text and/or the value object of
+elements such as Call, New, SystemProperty, etc. If no value type
+is specified, then white space is trimmed out of the value.
+If it contains multiple value elements they are added as strings
+before being converted to any specified type.
 -->
 <!ELEMENT Item ( %VALUE; )* >
 <!ATTLIST Item %TYPEATTR; %IDATTR; >
@@ -228,31 +232,34 @@
 <!--
 System Property Element.
 This element allows JVM System properties to be retrieved as
-part of the value of a Set, Put or Arg element.
+part of the value of elements such as Set, Put, Arg, etc.
 The name attribute specifies the property name and the optional
 default argument provides a default value.
 
- <SystemProperty name="Test" default="value"/>
+ <SystemProperty name="Test" default="value" />
 
 This is equivalent to:
 
  System.getProperty("Test","value");
-
 -->
 <!ELEMENT SystemProperty EMPTY>
 <!ATTLIST SystemProperty %NAMEATTR; %DEFAULTATTR; %IDATTR;>
 
+
 <!--
 Property Element.
-This element allows arbitrary properties to be retrieved as
-part of the value of a Set, Put or Arg element.
+This element allows arbitrary properties to be retrieved by name.
 The name attribute specifies the property name and the optional
 default argument provides a default value.
 
-   <Property name="Test" default="value"/>
+A Property element can contain a sequence of elements such as Set, Put, Call, etc.
+which act on the retrieved object:
+
+ <Property name="Server">
+   <Call id="jdbcIdMgr" name="getAttribute">
+     <Arg>jdbcIdMgr</Arg>
+   </Call>
+ </Property>
 -->
-<!ELEMENT Property EMPTY>
+<!ELEMENT Property ((%CONFIG;)*)>
 <!ATTLIST Property %NAMEATTR; %DEFAULTATTR; %IDATTR;>
-
-
-

Property changes on: modules/jetty/src/main/resources/org/mortbay/xml/configure_6_0.dtd
___________________________________________________________________
Added: svn:eol-style
   + native

Index: modules/jetty/pom.xml
===================================================================
--- modules/jetty/pom.xml	(revision 5689)
+++ modules/jetty/pom.xml	(working copy)
@@ -9,22 +9,33 @@
   <groupId>org.mortbay.jetty</groupId>
   <artifactId>jetty</artifactId>
   <name>Jetty Server</name>
-  <url>http://jetty.mortbay.org</url>
   <description>Jetty server core</description>
   <build>
-    <defaultGoal>install</defaultGoal>
-    <resources>
-      <resource>
-        <directory>src/main/resources</directory>
-      </resource>
-    </resources>
-    <testResources>
-      <testResource>
-        <directory>src/test/resources</directory>
-      </testResource>
-    </testResources>
     <plugins>
       <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-dependency-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>copy-deps</id>
+            <phase>install</phase>
+            <goals>
+              <goal>copy</goal>
+            </goals>
+            <configuration>
+              <artifactItems>
+                <artifactItem>
+                  <groupId>org.mortbay.jetty</groupId>
+                  <artifactId>servlet-api</artifactId>
+                  <version>${servlet-version}</version>
+                </artifactItem>
+              </artifactItems>
+              <outputDirectory>../../lib</outputDirectory>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
         <artifactId>maven-antrun-plugin</artifactId>
         <executions>
           <execution>
@@ -37,8 +48,18 @@
               <tasks>
                 <delete includeemptydirs="true">
                   <fileset dir="../../lib/" includes="${project.artifactId}-${project.version}.${project.packaging}" />
-                  <fileset dir="../../lib/" includes="servlet-api-2.5.jar" />
-                  <fileset dir="../../etc/" includes="webdefault.xml" />
+                  <fileset dir="../../lib/" includes="servlet-api-${servlet-version}.jar" />
+                  <fileset dir="../../etc/" >
+                    <include name="webdefault.xml"/>
+                    <include name="jetty.xml"/>
+                    <include name="jetty-bio.xml"/>
+                    <include name="jetty-ssl.xml"/>
+                    <include name="keystore"/>
+                    <include name="jetty-stats.xml"/>
+                    <include name="jetty-xinetd.xml"/>
+                    <include name="realm.properties"/>
+                    <include name="jdbcRealm.properties"/>
+                  </fileset>
                 </delete>
               </tasks>
             </configuration>
@@ -53,42 +74,24 @@
               <tasks>
                 <copy failonerror="false" file="target/${project.artifactId}-${project.version}.${project.packaging}" tofile="../../lib/${project.artifactId}-${project.version}.${project.packaging}" />
                 <copy failonerror="false" file="src/main/resources/org/mortbay/jetty/webapp/webdefault.xml" tofile="../../etc/webdefault.xml" />
+                <copy failonerror="false" includeEmptyDirs="false" todir="../../etc">
+                  <flattenmapper />
+                  <fileset dir="src/main/config/etc">
+                    <include name="jetty.xml"/>
+                    <include name="jetty-bio.xml"/>
+                    <include name="jetty-xinetd.xml"/>
+                    <include name="jetty-ssl.xml"/>
+                    <include name="keystore"/>
+                    <include name="jetty-stats.xml"/>
+                    <include name="realm.properties"/>
+                    <include name="jdbcRealm.properties"/>
+                  </fileset>
+                </copy>
               </tasks>
             </configuration>
           </execution>
         </executions>
       </plugin>
-      <plugin>
-        <groupId>org.apache.felix</groupId>
-        <artifactId>maven-bundle-plugin</artifactId>
-        <version>1.4.2</version>
-        <extensions>true</extensions>
-        <executions>
-          <execution>
-            <goals>
-              <goal>manifest</goal>
-            </goals>
-            <configuration>
-              <instructions>
-                <Bundle-SymbolicName>org.mortbay.jetty.server</Bundle-SymbolicName>
-                <Bundle-RequiredExcutionEnvironment>J2SE-1.4</Bundle-RequiredExcutionEnvironment>
-                <Bundle-DocURL>http://jetty.mortbay.org</Bundle-DocURL>
-                <Import-Package>!org.mortbay.jetty.*,!org.mortbay.xml.*,!org.mortbay.resource.*,!org.mortbay.io.*,*</Import-Package>
-              </instructions>
-            </configuration>
-           </execution>
-        </executions>
-      </plugin>
-            <plugin>
-              <groupId>org.apache.maven.plugins</groupId>
-              <artifactId>maven-jar-plugin</artifactId>
-              <version>2.1</version>
-              <configuration>
-                <archive>
-                  <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
-                </archive>
-              </configuration>
-            </plugin>
     </plugins>
   </build>
   <dependencies>
@@ -104,8 +107,8 @@
     </dependency>
     <dependency>
       <groupId>org.mortbay.jetty</groupId>
-      <artifactId>servlet-api-2.5</artifactId>
-      <version>${project.version}</version>
+      <artifactId>servlet-api</artifactId>
+      <version>${servlet-version}</version>
     </dependency>
   </dependencies>
 </project>

Property changes on: modules/util5
___________________________________________________________________
Modified: svn:ignore
   - target

   + 
*.diff
*.iml
*.ipr
*.iws
*.log
*.patch
*.swp
*~
.classpath
.fbprefs
.pmd
.project
.settings
target


Index: modules/util5/pom.xml
===================================================================
--- modules/util5/pom.xml	(revision 5689)
+++ modules/util5/pom.xml	(working copy)
@@ -2,7 +2,7 @@
   <parent>
     <artifactId>project</artifactId>
     <groupId>org.mortbay.jetty</groupId>
-    <version>6.1.22.z6</version>
+    <version>6.1.22.z5</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
   <modelVersion>4.0.0</modelVersion>
@@ -60,39 +60,6 @@
           </execution>
         </executions>
       </plugin>
-      <plugin>
-        <groupId>org.apache.felix</groupId>
-        <artifactId>maven-bundle-plugin</artifactId>
-        <version>${maven-bundle-plugin-version}</version>
-        <extensions>true</extensions>
-        <executions>
-          <execution>
-            <goals>
-              <goal>manifest</goal>
-            </goals>
-            <configuration>
-              <instructions>
-                <Bundle-SymbolicName>org.mortbay.jetty.util5</Bundle-SymbolicName>
-                <Bundle-RequiredExecutionEnvironment>J2SE-1.5</Bundle-RequiredExecutionEnvironment>
-                <Import-Package>!org.mortbay.*,org.slf4j;resolution:=optional,*</Import-Package>
-                <Bundle-DocURL>http://jetty.mortbay.org</Bundle-DocURL>
-              </instructions>
-            </configuration>
-           </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <!--
-        Required for OSGI
-        -->
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <configuration>
-          <archive>               
-            <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
-          </archive>
-        </configuration>
-      </plugin>
     </plugins>
   </build>
   <dependencies>

Property changes on: modules/util
___________________________________________________________________
Modified: svn:ignore
   - .project
.classpath
.settings
target

   + 
*.diff
*.iml
*.ipr
*.iws
*.log
*.patch
*.swp
*~
.classpath
.fbprefs
.pmd
.project
.settings
target


Index: modules/util/src/test/java/org/mortbay/util/URITest.java
===================================================================
--- modules/util/src/test/java/org/mortbay/util/URITest.java	(revision 5689)
+++ modules/util/src/test/java/org/mortbay/util/URITest.java	(working copy)
@@ -58,6 +58,9 @@
         URIUtil.encodeString(buf,"foo%23;,:=b a r",";,= ");
         assertEquals("foo%2523%3b%2c:%3db%20a%20r",buf.toString());
         
+        buf.setLength(0);
+        URIUtil.encodePath(buf,"/context/'list'/\"me\"/;<script>window.alert('xss');</script>");
+        assertEquals("/context/%27list%27/%22me%22/%3B%3Cscript%3Ewindow.alert(%27xss%27)%3B%3C/script%3E", buf.toString());
     }    
     
     /* ------------------------------------------------------------ */
Index: modules/util/src/test/java/org/mortbay/util/DateCacheTest.java
===================================================================
--- modules/util/src/test/java/org/mortbay/util/DateCacheTest.java	(revision 5689)
+++ modules/util/src/test/java/org/mortbay/util/DateCacheTest.java	(working copy)
@@ -63,7 +63,7 @@
                               last.substring(0,17),
                               date.substring(0,17));
                 
-                if (last.substring(17).equals(date.substring(17)))
+                if (!last.substring(17).equals(date.substring(17)))
                     change=true;
                 else
                 {
@@ -75,10 +75,7 @@
                     int ds=Integer.parseInt(date.substring(23,25));
 
                     // This won't work at midnight!
-                    assertTrue(  "Time changed",
-                                 ds==ls+1 ||
-                                 ds==0 && dm==lm+1 ||
-                                 ds==0 && dm==0 && dh==lh+1);
+                    change|= ds!=ls || dm!=lm || dh!=lh;
                 }
                 last=date;
             }
Index: modules/util/src/test/java/org/mortbay/util/ajax/JSONTest.java
===================================================================
--- modules/util/src/test/java/org/mortbay/util/ajax/JSONTest.java	(revision 5689)
+++ modules/util/src/test/java/org/mortbay/util/ajax/JSONTest.java	(working copy)
@@ -1,20 +1,67 @@
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
+
 package org.mortbay.util.ajax;
+import java.io.StringReader;
+import java.lang.reflect.Array;
+import java.math.BigDecimal;
+import java.text.DateFormatSymbols;
+import java.text.SimpleDateFormat;
+import java.util.Date;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
+import java.util.TimeZone;
 
-import org.mortbay.util.ajax.JSON;
-
 import junit.framework.TestCase;
 
+import org.mortbay.util.DateCache;
+import org.mortbay.util.ajax.JSON.Output;
+
 public class JSONTest extends TestCase
-{
-
+{   
+    String test="\n\n\n\t\t    "+
+    "// ignore this ,a [ \" \n"+
+    "/* and this \n" +
+    "/* and * // this \n" +
+    "*/" +
+    "{ "+
+    "\"onehundred\" : 100  ,"+
+    "\"small\":-0.2,"+
+    "\"name\" : \"fred\"  ," +
+    "\"empty\" : {}  ," +
+    "\"map\" : {\"a\":-1.0e2}  ," +
+    "\"array\" : [\"a\",-1.0e2,[],null,true,false]  ," +
+    "\"w0\":{\"class\":\"org.mortbay.util.ajax.JSONTest$Woggle\",\"name\":\"woggle0\",\"nested\":{\"class\":\"org.mortbay.util.ajax.JSONTest$Woggle\",\"name\":\"woggle1\",\"nested\":null,\"number\":-101},\"number\":100}" +
+    "}";
+    
     public void testToString()
     {
         HashMap map = new HashMap();
         HashMap obj6 = new HashMap();
         HashMap obj7 = new HashMap();
         
+        Woggle w0 = new Woggle();
+        Woggle w1 = new Woggle();
+        
+        w0.name="woggle0";
+        w0.nested=w1;
+        w0.number=100;
+        w1.name="woggle1";
+        w1.nested=null;
+        w1.number=-101;
+        
         map.put("n1",null);
         map.put("n2",new Integer(2));
         map.put("n3",new Double(-0.00000000003));
@@ -24,11 +71,12 @@
         map.put("n7",obj7);
         map.put("n8",new int[]{1,2,3,4});
         map.put("n9",new JSON.Literal("[{},  [],  {}]"));
+        map.put("w0",w0);
         
         obj7.put("x","value");
         
         String s = JSON.toString(map);
-        // System.err.println(s);
+        System.err.println(s);
         assertTrue(s.indexOf("\"n1\":null")>=0);
         assertTrue(s.indexOf("\"n2\":2")>=0);
         assertTrue(s.indexOf("\"n3\":-3.0E-11")>=0);
@@ -38,35 +86,70 @@
         assertTrue(s.indexOf("\"n7\":{\"x\":\"value\"}")>=0);
         assertTrue(s.indexOf("\"n8\":[1,2,3,4]")>=0);
         assertTrue(s.indexOf("\"n9\":[{},  [],  {}]")>=0);
+        assertTrue(s.indexOf("\"w0\":{\"class\":\"org.mortbay.util.ajax.JSONTest$Woggle\",\"name\":\"woggle0\",\"nested\":{\"class\":\"org.mortbay.util.ajax.JSONTest$Woggle\",\"name\":\"woggle1\",\"nested\":null,\"number\":-101},\"number\":100}")>=0);
+
+        Gadget gadget = new Gadget();
+        gadget.setShields(42);
+        gadget.setWoggles(new Woggle[]{w0,w1});
         
+        s = JSON.toString(new Gadget[]{gadget});
+        System.err.println(s);
+        assertTrue(s.startsWith("["));
+        assertTrue(s.indexOf("\"modulated\":false")>=0);
+        assertTrue(s.indexOf("\"shields\":42")>=0);
+        assertTrue(s.indexOf("\"name\":\"woggle0\"")>=0);
+        assertTrue(s.indexOf("\"name\":\"woggle1\"")>=0);
+
     }
     
+    
+    
+    /* ------------------------------------------------------------ */
+    /* (non-Javadoc)
+     * @see junit.framework.TestCase#setUp()
+     */
+    protected void setUp() throws Exception
+    {
+        JSON.registerConvertor(Gadget.class,new JSONObjectConvertor(false));
+    }
+
+
+
+    /* ------------------------------------------------------------ */
     public void testParse()
     {
-        String test="\n\n\n\t\t    "+
-        "// ignore this ,a [ \" \n"+
-        "/* and this \n" +
-        "/* and * // this \n" +
-        "*/" +
-        "{ "+
-        "\"onehundred\" : 100  ,"+
-        "\"name\" : \"fred\"  ," +
-        "\"empty\" : {}  ," +
-        "\"map\" : {\"a\":-1.0e2}  ," +
-        "\"array\" : [\"a\",-1.0e2,[],null,true,false]  ," +
-        "}";
-        
         Map map = (Map)JSON.parse(test);
-        // System.err.println(JSON.toString(map));
         assertEquals(new Long(100),map.get("onehundred"));
         assertEquals("fred",map.get("name"));
+        assertEquals(new Double(-0.2),map.get("small"));
         assertTrue(map.get("array").getClass().isArray());
+        assertTrue(map.get("w0") instanceof Woggle);
+        assertTrue(((Woggle)map.get("w0")).nested instanceof Woggle);
+        assertEquals(-101,((Woggle)((Woggle)map.get("w0")).nested).number);
         
+        
         test="{\"data\":{\"source\":\"15831407eqdaawf7\",\"widgetId\":\"Magnet_8\"},\"channel\":\"/magnets/moveStart\",\"connectionId\":null,\"clientId\":\"15831407eqdaawf7\"}";
         map = (Map)JSON.parse(test);
+
+        
     }
+
+    /* ------------------------------------------------------------ */
+    public void testParseReader() throws Exception
+    {
+        Map map = (Map)JSON.parse(new StringReader(test));
+   
+        assertEquals(new Long(100),map.get("onehundred"));
+        assertEquals("fred",map.get("name"));
+        assertTrue(map.get("array").getClass().isArray());
+        assertTrue(map.get("w0") instanceof Woggle);
+        assertTrue(((Woggle)map.get("w0")).nested instanceof Woggle);
+        
+        test="{\"data\":{\"source\":\"15831407eqdaawf7\",\"widgetId\":\"Magnet_8\"},\"channel\":\"/magnets/moveStart\",\"connectionId\":null,\"clientId\":\"15831407eqdaawf7\"}";
+        map = (Map)JSON.parse(test);
+    }
     
-    
+    /* ------------------------------------------------------------ */
     public void testStripComment()
     {
         String test="\n\n\n\t\t    "+
@@ -87,4 +170,289 @@
         assertEquals("fred",((Map)o).get("name"));
         
     }
+    
+    /* ------------------------------------------------------------ */
+    public void testQuote()
+    {
+        String test="\"abc123|\\\"|\\\\|\\/|\\b|\\f|\\n|\\r|\\t|\\uaaaa|\"";
+        
+        String result = (String)JSON.parse(test,false);
+        assertEquals("abc123|\"|\\|/|\b|\f|\n|\r|\t|\uaaaa|",result);
+    }
+
+    /* ------------------------------------------------------------ */
+    public void testBigDecimal()
+    {
+        Object obj = JSON.parse("1.0E7");
+        assertTrue(obj instanceof Double);
+        BigDecimal bd = new BigDecimal(1000.1D);
+        String string = JSON.toString(new Object[]{bd}); 
+        obj = Array.get(JSON.parse(string),0);
+        assertTrue(obj instanceof Double);
+    }
+    
+    /* ------------------------------------------------------------ */
+    public static class Gadget 
+    {
+        private boolean modulated;
+        private long shields;
+        private Woggle[] woggles;
+        /* ------------------------------------------------------------ */
+        /**
+         * @return the modulated
+         */
+        public boolean isModulated()
+        {
+            return modulated;
+        }
+        /* ------------------------------------------------------------ */
+        /**
+         * @param modulated the modulated to set
+         */
+        public void setModulated(boolean modulated)
+        {
+            this.modulated=modulated;
+        }
+        /* ------------------------------------------------------------ */
+        /**
+         * @return the shields
+         */
+        public long getShields()
+        {
+            return shields;
+        }
+        /* ------------------------------------------------------------ */
+        /**
+         * @param shields the shields to set
+         */
+        public void setShields(long shields)
+        {
+            this.shields=shields;
+        }
+        /* ------------------------------------------------------------ */
+        /**
+         * @return the woggles
+         */
+        public Woggle[] getWoggles()
+        {
+            return woggles;
+        }
+        /* ------------------------------------------------------------ */
+        /**
+         * @param woggles the woggles to set
+         */
+        public void setWoggles(Woggle[] woggles)
+        {
+            this.woggles=woggles;
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    public void testConvertor()
+    {
+        // test case#1 - force timezone to GMT
+        JSON json = new JSON();
+        json.addConvertor(Date.class, new JSONDateConvertor("MM/dd/yyyy HH:mm:ss zzz", TimeZone.getTimeZone("GMT"),false));
+        json.addConvertor(Object.class,new JSONObjectConvertor());
+
+        Woggle w0 = new Woggle();
+        Gizmo g0 = new Gizmo();
+        
+        w0.name="woggle0";
+        w0.nested=g0;
+        w0.number=100;
+        g0.name="woggle1";
+        g0.nested=null;
+        g0.number=-101;
+        g0.tested=true;
+        
+        HashMap map = new HashMap();
+        Date dummyDate = new Date(1);
+        map.put("date", dummyDate);
+        map.put("w0",w0);
+
+        StringBuffer buf = new StringBuffer();
+        json.append(buf,map);
+        String js=buf.toString();
+        
+        System.err.println(js);
+        assertTrue(js.indexOf("\"date\":\"01/01/1970 00:00:00 GMT\"")>=0);
+        assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Woggle")>=0);
+        assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Gizmo")<0);
+        assertTrue(js.indexOf("\"tested\":true")>=0);
+
+        // test case#3
+        TimeZone tzone = TimeZone.getTimeZone("JST");
+        String tzone3Letter = tzone.getDisplayName(false, TimeZone.SHORT);
+        String format = "EEE MMMMM dd HH:mm:ss zzz yyyy";
+
+        Locale l = new Locale("ja", "JP");
+        if (l!=null)
+        {
+            json.addConvertor(Date.class, new JSONDateConvertor(format, tzone, false, l));
+            buf = new StringBuffer();
+            json.append(buf,map);
+            js=buf.toString();
+
+            assertTrue(js.indexOf("\"date\":\"\u6728 1\u6708 01 09:00:00 JST 1970\"")>=0);
+            assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Woggle")>=0);
+            assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Gizmo")<0);
+            assertTrue(js.indexOf("\"tested\":true")>=0);
+        }
+        
+        // test case#4 
+        json.addConvertor(Date.class,new JSONDateConvertor(true));
+        w0.nested=null;
+        buf = new StringBuffer();
+        json.append(buf,map);
+        js=buf.toString();
+        System.err.println(js);
+        assertTrue(js.indexOf("\"date\":\"Thu Jan 01 00:00:00 GMT 1970\"")<0);
+        assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Woggle")>=0);
+        assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Gizmo")<0);
+        
+        map=(HashMap)json.parse(new JSON.StringSource(js));
+        
+        assertTrue(map.get("date") instanceof Date);
+        assertTrue(map.get("w0") instanceof Woggle);
+    }
+    
+/* java 1.5 only 
+    enum Color { Red, Green, Blue };
+
+    public void testEnumConvertor()
+    {
+        JSON json = new JSON();
+        Locale l = new Locale("en", "US");
+        json.addConvertor(Date.class,new JSONDateConvertor(DateCache.DEFAULT_FORMAT,TimeZone.getTimeZone("GMT"),false,l));
+        json.addConvertor(Enum.class,new JSONEnumConvertor(false));
+        json.addConvertor(Object.class,new JSONObjectConvertor());
+
+        Woggle w0 = new Woggle();
+        Gizmo g0 = new Gizmo();
+        
+        w0.name="woggle0";
+        w0.nested=g0;
+        w0.number=100;
+        w0.other=Color.Blue;
+        g0.name="woggle1";
+        g0.nested=null;
+        g0.number=-101;
+        g0.tested=true;
+        g0.other=Color.Green;
+        
+        HashMap map = new HashMap();
+        map.put("date",new Date(1));
+        map.put("w0",w0);
+        map.put("g0",g0);
+
+        StringBuffer buf = new StringBuffer();
+        json.append(buf,map);
+        String js=buf.toString();
+        
+        System.err.println(js);
+        assertTrue(js.indexOf("\"date\":\"Thu Jan 01 00:00:00 GMT 1970\"")>=0);
+        assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Woggle")>=0);
+        assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Gizmo")<0);
+        assertTrue(js.indexOf("\"tested\":true")>=0);
+        assertTrue(js.indexOf("\"Green\"")>=0);
+        assertTrue(js.indexOf("\"Blue\"")<0);
+
+        json.addConvertor(Date.class,new JSONDateConvertor(DateCache.DEFAULT_FORMAT,TimeZone.getTimeZone("GMT"),true,l));
+        json.addConvertor(Enum.class,new JSONEnumConvertor(false));
+        w0.nested=null;
+        buf = new StringBuffer();
+        json.append(buf,map);
+        js=buf.toString();
+        System.err.println(js);
+        assertTrue(js.indexOf("\"date\":\"Thu Jan 01 00:00:00 GMT 1970\"")<0);
+        assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Woggle")>=0);
+        assertTrue(js.indexOf("org.mortbay.util.ajax.JSONTest$Gizmo")<0);
+        
+        Map map2=(HashMap)json.parse(new JSON.StringSource(js));
+        
+        assertTrue(map2.get("date") instanceof Date);
+        assertTrue(map2.get("w0") instanceof Woggle);
+        assertEquals(null, ((Woggle)map2.get("w0")).getOther() );
+        assertEquals(Color.Green.toString(), ((Map)map2.get("g0")).get("other"));
+        
+        
+
+        json.addConvertor(Date.class,new JSONDateConvertor(DateCache.DEFAULT_FORMAT,TimeZone.getTimeZone("GMT"),true,l));
+        json.addConvertor(Enum.class,new JSONEnumConvertor(true));
+        buf = new StringBuffer();
+        json.append(buf,map);
+        js=buf.toString();
+        System.err.println(js);
+        map2=(HashMap)json.parse(new JSON.StringSource(js));
+        
+        assertTrue(map2.get("date") instanceof Date);
+        assertTrue(map2.get("w0") instanceof Woggle);
+        assertEquals(null, ((Woggle)map2.get("w0")).getOther() );
+        Object o=((Map)map2.get("g0")).get("other");
+        assertEquals(Color.Green, o);
+           
+    }
+*/
+
+    /* ------------------------------------------------------------ */
+    public static class Gizmo
+    {
+        String name;
+        Gizmo nested;
+        long number;
+        boolean tested;
+        Object other;
+        
+        public String getName()
+        {
+            return name;
+        }
+        public Gizmo getNested()
+        {
+            return nested;
+        }
+        public long getNumber()
+        {
+            return number;
+        }
+        public boolean isTested()
+        {
+            return tested;
+        }
+        public Object getOther()
+        {
+            return other;
+        }
+    }
+    
+    /* ------------------------------------------------------------ */
+    public static class Woggle extends Gizmo implements JSON.Convertible
+    {
+        
+        public Woggle()
+        {
+        }
+        
+        public void fromJSON(Map object)
+        {
+            name=(String)object.get("name");
+            nested=(Gizmo)object.get("nested");
+            number=((Number)object.get("number")).intValue();
+        }
+
+        public void toJSON(Output out)
+        {
+            out.addClass(Woggle.class);
+            out.add("name",name);
+            out.add("nested",nested);
+            out.add("number",number);
+        }
+        
+        public String toString()
+        {
+            return name+"<<"+nested+">>"+number;
+        }
+        
+    }
 }
Index: modules/util/src/test/java/org/mortbay/util/QuotedStringTokenizerTest.java
===================================================================
--- modules/util/src/test/java/org/mortbay/util/QuotedStringTokenizerTest.java	(revision 5689)
+++ modules/util/src/test/java/org/mortbay/util/QuotedStringTokenizerTest.java	(working copy)
@@ -105,6 +105,10 @@
         assertEquals("\"abcefg\"",buf.toString());
         
         buf.setLength(0);
+        QuotedStringTokenizer.quote(buf,"abcefg\"");
+        assertEquals("\"abcefg\\\"\"",buf.toString());
+        
+        buf.setLength(0);
         QuotedStringTokenizer.quoteIfNeeded(buf,"abc \n efg");
         assertEquals("\"abc \\n efg\"",buf.toString());
         
Index: modules/util/src/test/java/org/mortbay/util/URLEncodedTest.java
===================================================================
--- modules/util/src/test/java/org/mortbay/util/URLEncodedTest.java	(revision 5689)
+++ modules/util/src/test/java/org/mortbay/util/URLEncodedTest.java	(working copy)
@@ -71,10 +71,10 @@
         assertEquals("noValue get","", url_encoded.getString("Name3"));
     
         url_encoded.clear();
-        url_encoded.decode("Name4=Value+4%21");
+        url_encoded.decode("Name4=V\u0629lue+4%21");
         assertEquals("encoded param size",1, url_encoded.size());
-        assertEquals("encoded encode","Name4=Value+4%21", url_encoded.encode());
-        assertEquals("encoded get","Value 4!", url_encoded.getString("Name4"));
+        assertEquals("encoded encode","Name4=V%D8%A9lue+4%21", url_encoded.encode());
+        assertEquals("encoded get","V\u0629lue 4!", url_encoded.getString("Name4"));
 
         url_encoded.clear();
         url_encoded.decode("Name4=Value%2B4%21");
@@ -112,16 +112,38 @@
         assertEquals("encoded param size",1, url_encoded.size());
         assertEquals("encoded encode","Name8=xx%2C++yy++%2Czz", url_encoded.encode());
         assertEquals("encoded get", url_encoded.getString("Name8"),"xx,  yy  ,zz");
-
-       /* Not every jvm supports this encoding, so don't run this test for now
         
         url_encoded.clear();
-        url_encoded.decode("Name9=%83e%83X%83g", "SJIS"); // "Test" in Japanese Katakana
+        url_encoded.decode("Name11=xxVerdi+%C6+og+2zz", "ISO-8859-1");
         assertEquals("encoded param size",1, url_encoded.size());
-        assertEquals("encoded get", "\u30c6\u30b9\u30c8", url_encoded.getString("Name9"));   
+        assertEquals("encoded get", url_encoded.getString("Name11"),"xxVerdi \u00c6 og 2zz");
         
-       */
+        url_encoded.clear();
+        url_encoded.decode("Name12=xxVerdi+%2F+og+2zz", "UTF-8");
+        assertEquals("encoded param size",1, url_encoded.size());
+        assertEquals("encoded get", url_encoded.getString("Name12"),"xxVerdi / og 2zz");
         
+        url_encoded.clear();
+        url_encoded.decode("Name14=%GG%+%%+%", "ISO-8859-1");
+        assertEquals("encoded param size",1, url_encoded.size());
+        assertEquals("encoded get", url_encoded.getString("Name14"),"%GG% %% %");
+        
+        url_encoded.clear();
+        url_encoded.decode("Name14=%GG%+%%+%", "UTF-8");
+        assertEquals("encoded param size",1, url_encoded.size());
+        assertEquals("encoded get", url_encoded.getString("Name14"),"%GG% %% %");
+
+        /* Not every jvm supports this encoding */
+        
+        if (java.nio.charset.Charset.isSupported("SJIS"))
+        {
+            url_encoded.clear();
+            url_encoded.decode("Name9=%83e%83X%83g", "SJIS"); // "Test" in Japanese Katakana
+            assertEquals("encoded param size",1, url_encoded.size());
+            assertEquals("encoded get", "\u30c6\u30b9\u30c8", url_encoded.getString("Name9"));   
+        }
+        else
+            assertTrue("Charset SJIS not supported by jvm", true);
     }
     
 
@@ -129,17 +151,37 @@
     public void testUrlEncodedStream()
     	throws Exception
     {
-        ByteArrayInputStream in = new ByteArrayInputStream (
-                "name0=value+%30&name1=&name2&name3=value+3".getBytes());
-        MultiMap m = new MultiMap();
-        UrlEncoded.decodeTo(in, m, null, -1);
-        System.err.println(m);
-        assertEquals("stream length",4,m.size());
-        assertEquals("stream name0","value 0",m.getString("name0"));
-        assertEquals("stream name1","",m.getString("name1"));
-        assertEquals("stream name2","",m.getString("name2"));
-        assertEquals("stream name3","value 3",m.getString("name3"));
+        String [][] charsets = new String[][]
+        {
+           {StringUtil.__UTF8,null},
+           {StringUtil.__ISO_8859_1,StringUtil.__ISO_8859_1},
+           {StringUtil.__UTF8,StringUtil.__UTF8},
+           {StringUtil.__UTF16,StringUtil.__UTF16},
+        };
         
+        for (int i=0;i<charsets.length;i++)
+        {
+            ByteArrayInputStream in = new ByteArrayInputStream("name\n=value+%30&name1=&name2&n\u00e3me3=value+3".getBytes(charsets[i][0]));
+            MultiMap m = new MultiMap();
+            UrlEncoded.decodeTo(in, m, charsets[i][1], -1);
+            System.err.println(m);
+            assertEquals(i+" stream length",4,m.size());
+            assertEquals(i+" stream name\\n","value 0",m.getString("name\n"));
+            assertEquals(i+" stream name1","",m.getString("name1"));
+            assertEquals(i+" stream name2","",m.getString("name2"));
+            assertEquals(i+" stream n\u00e3me3","value 3",m.getString("n\u00e3me3"));
+        }
         
+        
+        if (java.nio.charset.Charset.isSupported("Shift_JIS"))
+        {
+            ByteArrayInputStream in2 = new ByteArrayInputStream ("name=%83e%83X%83g".getBytes());
+            MultiMap m2 = new MultiMap();
+            UrlEncoded.decodeTo(in2, m2, "Shift_JIS", -1);
+            assertEquals("stream length",1,m2.size());
+            assertEquals("stream name","\u30c6\u30b9\u30c8",m2.getString("name"));
+        }
+        else
+            assertTrue("Charset Shift_JIS not supported by jvm", true);
     }
 }
Index: modules/util/src/test/java/org/mortbay/util/Utf8StringBufferTest.java
===================================================================
--- modules/util/src/test/java/org/mortbay/util/Utf8StringBufferTest.java	(revision 5689)
+++ modules/util/src/test/java/org/mortbay/util/Utf8StringBufferTest.java	(working copy)
@@ -20,7 +20,7 @@
     public void testUtfStringBuffer()
         throws Exception
     {
-        String source="abcd012345\n\r\uffff\u0fff\u00ff\u000f";
+        String source="abcd012345\n\r\uffff\u0fff\u00ff\u000f\u0000jetty";
         byte[] bytes = source.getBytes(StringUtil.__UTF8);
         Utf8StringBuffer buffer = new Utf8StringBuffer();
         for (int i=0;i<bytes.length;i++)
Index: modules/util/src/main/java/org/mortbay/log/Log.java
===================================================================
--- modules/util/src/main/java/org/mortbay/log/Log.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/log/Log.java	(working copy)
@@ -14,6 +14,8 @@
 
 package org.mortbay.log;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import org.mortbay.util.Loader;
 
@@ -40,67 +42,81 @@
     public final static String IGNORED_FMT= "IGNORED: {}";
     public final static String NOT_IMPLEMENTED= "NOT IMPLEMENTED ";
     
-    private static String logClass=System.getProperty("org.mortbay.log.class","org.mortbay.log.Slf4jLog");
-    private static boolean verbose = System.getProperty("VERBOSE",null)!=null;
-    private static Logger log;
-   
+    public static String __logClass;
+    public static boolean __verbose;
+    public static boolean __ignored;
+    
+    private static Logger __log;
+    
     static
     {
+        AccessController.doPrivileged(new PrivilegedAction() 
+            {
+                public Object run() 
+                { 
+                    __logClass = System.getProperty("org.mortbay.log.class","org.mortbay.log.Slf4jLog"); 
+                    __verbose = System.getProperty("VERBOSE",null)!=null; 
+                    __ignored = System.getProperty("IGNORED",null)!=null; 
+                    return new Boolean(true); 
+                }
+            });
+   
         Class log_class=null;
         try
         {
-            log_class=Loader.loadClass(Log.class, logClass);
-            log=(Logger) log_class.newInstance();
+            log_class=Loader.loadClass(Log.class, __logClass);
+            __log=(Logger) log_class.newInstance();
         }
-        catch(Exception e)
+        catch(Throwable e)
         {
-            log_class=StdErrLog.class;
-            log=new StdErrLog();
-            if(verbose)
+            log_class = StdErrLog.class;
+            __log = new StdErrLog();
+            __logClass = log_class.getName();
+            if(__verbose)
                 e.printStackTrace();
         }
         
-        log.info("Logging to {} via {}",log,log_class.getName());
+        __log.info("Logging to {} via {}",__log,log_class.getName());
     }
     
     public static void setLog(Logger log)
     {
-        Log.log=log;
+        Log.__log=log;
     }
     
     public static Logger getLog()
     {
-        return log;
+        return __log;
     }
     
     
     public static void debug(Throwable th)
     {
-        if (log==null)
+        if (__log==null || !isDebugEnabled())
             return;
-        log.debug(EXCEPTION,th);
+        __log.debug(EXCEPTION,th);
         unwind(th);
     }
 
     public static void debug(String msg)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.debug(msg,null,null);
+        __log.debug(msg,null,null);
     }
     
     public static void debug(String msg,Object arg)
     {
-        if (log==null)
+        if (__log==null) 
             return;
-        log.debug(msg,arg,null);
+        __log.debug(msg,arg,null);
     }
     
     public static void debug(String msg,Object arg0, Object arg1)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.debug(msg,arg0,arg1);
+        __log.debug(msg,arg0,arg1);
     }
     
     /* ------------------------------------------------------------ */
@@ -110,77 +126,82 @@
      */
     public static void ignore(Throwable th)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        if (verbose)
+	if (__ignored)
+	{
+            __log.warn(IGNORED,th);
+            unwind(th);
+	}
+        else if (__verbose)
         {
-            log.debug(IGNORED,th);
+            __log.debug(IGNORED,th);
             unwind(th);
         }
     }
     
     public static void info(String msg)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.info(msg,null,null);
+        __log.info(msg,null,null);
     }
     
     public static void info(String msg,Object arg)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.info(msg,arg,null);
+        __log.info(msg,arg,null);
     }
     
     public static void info(String msg,Object arg0, Object arg1)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.info(msg,arg0,arg1);
+        __log.info(msg,arg0,arg1);
     }
     
     public static boolean isDebugEnabled()
     {
-        if (log==null)
+        if (__log==null)
             return false;
-        return log.isDebugEnabled();
+        return __log.isDebugEnabled();
     }
     
     public static void warn(String msg)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.warn(msg,null,null);
+        __log.warn(msg,null,null);
     }
     
     public static void warn(String msg,Object arg)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.warn(msg,arg,null);        
+        __log.warn(msg,arg,null);        
     }
     
     public static void warn(String msg,Object arg0, Object arg1)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.warn(msg,arg0,arg1);        
+        __log.warn(msg,arg0,arg1);        
     }
     
     public static void warn(String msg, Throwable th)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.warn(msg,th);
+        __log.warn(msg,th);
         unwind(th);
     }
 
     public static void warn(Throwable th)
     {
-        if (log==null)
+        if (__log==null)
             return;
-        log.warn(EXCEPTION,th);
+        __log.warn(EXCEPTION,th);
         unwind(th);
     }
 
@@ -189,11 +210,11 @@
      */
     public static Logger getLogger(String name)
     {
-        if (log==null)
-            return log;
+        if (__log==null)
+            return __log;
         if (name==null)
-          return log;
-        return log.getLogger(name);
+          return __log;
+        return __log.getLogger(name);
     }
 
     private static void unwind(Throwable th)
@@ -206,7 +227,7 @@
             {
                 Method get_target = th.getClass().getMethod(__nestedEx[i],__noArgs);
                 Throwable th2=(Throwable)get_target.invoke(th,(Object[])null);
-                if (th2!=null)
+                if (th2!=null && th2!=th)
                     warn("Nested in "+th+":",th2);
             }
             catch(Exception ignore){}
Index: modules/util/src/main/java/org/mortbay/log/Slf4jLog.java
===================================================================
--- modules/util/src/main/java/org/mortbay/log/Slf4jLog.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/log/Slf4jLog.java	(working copy)
@@ -15,53 +15,20 @@
 
 package org.mortbay.log;
 
-import java.lang.reflect.Method;
 
 public class Slf4jLog implements Logger
 {
-    private static final String LOGGER="org.slf4j.Logger";
-    private static final String LOGGERFACTORY="org.slf4j.LoggerFactory";
-    private static final Object[] NO_ARGS=new Object[]{};
-    private Method infoSOO;
-    private Method debugSOO;
-    private Method debugST;
-    private Method debugEnabled;
-    private Method warnSOO;
-    private Method warnST;
-    private Method errorST;
-    private Object logger;
-    
+    private org.slf4j.Logger logger;
 
+
     public Slf4jLog() throws Exception
     {
         this("org.mortbay.log");
     }
     
-    public Slf4jLog(String name) throws Exception
+    public Slf4jLog(String name)
     {
-        Class slf4j = null;
-        Class slf4jf = null;
-        try
-        {
-            slf4j=this.getClass().getClassLoader().loadClass(LOGGER);
-            slf4jf=this.getClass().getClassLoader().loadClass(LOGGERFACTORY);
-        }
-        catch(Exception e)
-        {
-            slf4j=Thread.currentThread().getContextClassLoader()==null?Class.forName(LOGGER):Thread.currentThread().getContextClassLoader().loadClass(LOGGER);
-            slf4jf = Thread.currentThread().getContextClassLoader()==null?Class.forName(LOGGERFACTORY):Thread.currentThread().getContextClassLoader().loadClass(LOGGERFACTORY);
-        }
-        
-        infoSOO = slf4j.getMethod("info", new Class[]{String.class,Object.class,Object.class});
-        debugSOO = slf4j.getMethod("debug", new Class[]{String.class,Object.class,Object.class});
-        debugST = slf4j.getMethod("debug", new Class[]{String.class,Throwable.class});
-        debugEnabled = slf4j.getMethod("isDebugEnabled", new Class[]{});
-        warnSOO = slf4j.getMethod("warn", new Class[]{String.class,Object.class,Object.class});
-        warnST = slf4j.getMethod("warn", new Class[]{String.class,Throwable.class});
-        errorST = slf4j.getMethod("error", new Class[]{String.class,Throwable.class});
-        
-        Method getLogger = slf4jf.getMethod("getLogger", new Class[]{String.class});
-        logger=getLogger.invoke(null, new Object[]{name});
+        logger = org.slf4j.LoggerFactory.getLogger( name );
     }
     
     /* ------------------------------------------------------------ */
@@ -70,8 +37,7 @@
      */
     public void debug(String msg, Object arg0, Object arg1)
     {
-        try{debugSOO.invoke(logger, new Object[]{msg,arg0,arg1});}
-        catch (Exception e) {e.printStackTrace();}
+        logger.debug(msg, arg0, arg1);
     }
 
     /* ------------------------------------------------------------ */
@@ -80,8 +46,7 @@
      */
     public void debug(String msg, Throwable th)
     {
-        try{debugST.invoke(logger, new Object[]{msg,th});}
-        catch (Exception e) {e.printStackTrace();}
+        logger.debug(msg, th);
     }
 
     /* ------------------------------------------------------------ */
@@ -90,8 +55,7 @@
      */
     public boolean isDebugEnabled()
     {
-        try{return ((Boolean)debugEnabled.invoke(logger, NO_ARGS)).booleanValue();}
-        catch (Exception e) {e.printStackTrace();return true;}
+        return logger.isDebugEnabled();
     }
 
     /* ------------------------------------------------------------ */
@@ -100,8 +64,7 @@
      */
     public void info(String msg, Object arg0, Object arg1)
     {
-        try{infoSOO.invoke(logger, new Object[]{msg,arg0,arg1});}
-        catch (Exception e) {e.printStackTrace();}
+        logger.info(msg, arg0, arg1);
     }
 
     /* ------------------------------------------------------------ */
@@ -110,8 +73,7 @@
      */
     public void warn(String msg, Object arg0, Object arg1)
     {
-        try{warnSOO.invoke(logger, new Object[]{msg,arg0,arg1});}
-        catch (Exception e) {e.printStackTrace();}
+        logger.warn(msg, arg0, arg1);
     }
 
     /* ------------------------------------------------------------ */
@@ -120,28 +82,19 @@
      */
     public void warn(String msg, Throwable th)
     {
-        try
-        {
-            if (th instanceof RuntimeException || th instanceof Error)
-                errorST.invoke(logger, new Object[]{msg,th});
-            else
-                warnST.invoke(logger, new Object[]{msg,th});
-        }
-        catch (Exception e) {e.printStackTrace();}
+
+        if (th instanceof RuntimeException || th instanceof Error)
+            logger.error(msg, th);
+        else
+            logger.warn(msg,th);
+
     }
 
     /* ------------------------------------------------------------ */
     public Logger getLogger(String name)
     {
-        try
-        {
-            return new Slf4jLog(name);
-        }
-        catch (Exception e)
-        {
-            Log.warn(e);
-            return this;
-        }
+        return new Slf4jLog(name);
+
     }
 
     /* ------------------------------------------------------------ */
Index: modules/util/src/main/java/org/mortbay/log/StdErrLog.java
===================================================================
--- modules/util/src/main/java/org/mortbay/log/StdErrLog.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/log/StdErrLog.java	(working copy)
@@ -26,9 +26,11 @@
 public class StdErrLog implements Logger
 {    
     private static DateCache _dateCache;
-    private static boolean debug = System.getProperty("DEBUG",null)!=null;
-    private String name;
+    private static boolean __debug = System.getProperty("DEBUG",null)!=null;
+    private String _name;
     
+    StringBuffer _buffer = new StringBuffer();
+    
     static
     {
         try
@@ -49,44 +51,59 @@
     
     public StdErrLog(String name)
     {    
-        this.name=name==null?"":name;
+        this._name=name==null?"":name;
     }
     
     public boolean isDebugEnabled()
     {
-        return debug;
+        return __debug;
     }
     
     public void setDebugEnabled(boolean enabled)
     {
-        debug=enabled;
+        __debug=enabled;
     }
     
     public void info(String msg,Object arg0, Object arg1)
     {
         String d=_dateCache.now();
         int ms=_dateCache.lastMs();
-        System.err.println(d+(ms>99?".":(ms>0?".0":".00"))+ms+":"+name+":INFO:  "+format(msg,arg0,arg1));
+        synchronized(_buffer)
+        {
+            tag(d,ms,":INFO:");
+            format(msg,arg0,arg1);
+            System.err.println(_buffer.toString());
+        }
     }
     
     public void debug(String msg,Throwable th)
     {
-        if (debug)
+        if (__debug)
         {
             String d=_dateCache.now();
             int ms=_dateCache.lastMs();
-            System.err.println(d+(ms>99?".":(ms>0?".0":".00"))+ms+":"+name+":DEBUG: "+msg);
-            if (th!=null) th.printStackTrace();
+            synchronized(_buffer)
+            {
+                tag(d,ms,":DBUG:");
+                format(msg);
+                format(th);
+                System.err.println(_buffer.toString());
+            }
         }
     }
     
     public void debug(String msg,Object arg0, Object arg1)
     {
-        if (debug)
+        if (__debug)
         {
             String d=_dateCache.now();
             int ms=_dateCache.lastMs();
-            System.err.println(d+(ms>99?".":(ms>0?".0":".00"))+ms+":"+name+":DEBUG: "+format(msg,arg0,arg1));
+            synchronized(_buffer)
+            {
+                tag(d,ms,":DBUG:");
+                format(msg,arg0,arg1);
+                System.err.println(_buffer.toString());
+            }
         }
     }
     
@@ -94,42 +111,126 @@
     {
         String d=_dateCache.now();
         int ms=_dateCache.lastMs();
-        System.err.println(d+(ms>99?".":(ms>0?".0":".00"))+ms+":"+name+":WARN:  "+format(msg,arg0,arg1));
+        synchronized(_buffer)
+        {
+            tag(d,ms,":WARN:");
+            format(msg,arg0,arg1);
+            System.err.println(_buffer.toString());
+        }
     }
     
     public void warn(String msg, Throwable th)
     {
         String d=_dateCache.now();
         int ms=_dateCache.lastMs();
-        System.err.println(d+(ms>99?".":(ms>0?".0":".00"))+ms+":"+name+":WARN:  "+msg);
-        if (th!=null)
-            th.printStackTrace();
+        synchronized(_buffer)
+        {
+            tag(d,ms,":WARN:");
+            format(msg);
+            format(th);
+            System.err.println(_buffer.toString());
+        }
     }
-
-    private String format(String msg, Object arg0, Object arg1)
+    
+    private void tag(String d,int ms,String tag)
     {
+        _buffer.setLength(0);
+        _buffer.append(d);
+        if (ms>99)
+            _buffer.append('.');
+        else if (ms>9)
+            _buffer.append(".0");
+        else
+            _buffer.append(".00");
+        _buffer.append(ms).append(tag).append(_name).append(':');
+    }
+    
+    private void format(String msg, Object arg0, Object arg1)
+    {
         int i0=msg.indexOf("{}");
         int i1=i0<0?-1:msg.indexOf("{}",i0+2);
         
-        if (arg1!=null && i1>=0)
-            msg=msg.substring(0,i1)+arg1+msg.substring(i1+2);
-        if (arg0!=null && i0>=0)
-            msg=msg.substring(0,i0)+arg0+msg.substring(i0+2);
-        return msg;
+        if (i0>=0)
+        {
+            format(msg.substring(0,i0));
+            format(String.valueOf(arg0));
+            
+            if (i1>=0)
+            {
+                format(msg.substring(i0+2,i1));
+                format(String.valueOf(arg1));
+                format(msg.substring(i1+2));
+            }
+            else
+            {
+                format(msg.substring(i0+2));
+                if (arg1!=null)
+                {
+                    _buffer.append(' ');
+                    format(String.valueOf(arg1));
+                }
+            }
+        }
+        else
+        {
+            format(msg);
+            if (arg0!=null)
+            {
+                _buffer.append(' ');
+                format(String.valueOf(arg0));
+            }
+            if (arg1!=null)
+            {
+                _buffer.append(' ');
+                format(String.valueOf(arg1));
+            }
+        }
     }
     
+    private void format(String msg)
+    {
+        for (int i=0;i<msg.length();i++)
+        {
+            char c=msg.charAt(i);
+            if (Character.isISOControl(c))
+            {
+                if (c=='\n')
+                    _buffer.append('|');
+                else if (c=='\r')
+                    _buffer.append('<');
+                else
+                    _buffer.append('?');
+            }
+            else
+                _buffer.append(c);
+        }
+    }
+    
+    private void format(Throwable th)
+    {
+        _buffer.append('\n');
+        format(th.toString());
+        StackTraceElement[] elements = th.getStackTrace();
+        for (int i=0;elements!=null && i<elements.length;i++)
+        {
+            _buffer.append("\n\tat ");
+            format(elements[i].toString());
+        }
+    }
+    
     public Logger getLogger(String name)
     {
-        if ((name==null && this.name==null) ||
-            (name!=null && name.equals(this.name)))
+        if ((name==null && this._name==null) ||
+            (name!=null && name.equals(this._name)))
             return this;
         return new StdErrLog(name);
     }
     
     public String toString()
     {
-        return "STDERR"+name;
+        return "STDERR"+_name;
     }
+    
 
 }
 
Index: modules/util/src/main/java/org/mortbay/component/LifeCycle.java
===================================================================
--- modules/util/src/main/java/org/mortbay/component/LifeCycle.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/component/LifeCycle.java	(working copy)
@@ -14,6 +14,10 @@
 
 package org.mortbay.component;
 
+import java.util.EventListener;
+
+import org.mortbay.util.LazyList;
+
 /* ------------------------------------------------------------ */
 /**
  * The lifecycle interface for generic components.
@@ -90,4 +94,24 @@
      * @return true if the component has failed to start or has failed to stop.
      */
     public boolean isFailed();
+    
+    /* ------------------------------------------------------------ */
+    public void addLifeCycleListener(LifeCycle.Listener listener);
+
+    /* ------------------------------------------------------------ */
+    public void removeLifeCycleListener(LifeCycle.Listener listener);
+    
+
+    /* ------------------------------------------------------------ */
+    /** Listener.
+     * A listener for Lifecycle events.
+     */
+    public interface Listener extends EventListener
+    {
+        public void lifeCycleStarting(LifeCycle event);
+        public void lifeCycleStarted(LifeCycle event);
+        public void lifeCycleFailure(LifeCycle event,Throwable cause);
+        public void lifeCycleStopping(LifeCycle event);
+        public void lifeCycleStopped(LifeCycle event);
+    }
 }
Index: modules/util/src/main/java/org/mortbay/component/AbstractLifeCycle.java
===================================================================
--- modules/util/src/main/java/org/mortbay/component/AbstractLifeCycle.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/component/AbstractLifeCycle.java	(working copy)
@@ -16,97 +16,180 @@
 package org.mortbay.component;
 
 import org.mortbay.log.Log;
-import org.mortbay.util.MultiException;
+import org.mortbay.util.LazyList;
 
 /**
  * Basic implementation of the life cycle interface for components.
+ * 
  * @author gregw
  */
 public abstract class AbstractLifeCycle implements LifeCycle
 {
-    private final int FAILED=-1,STOPPED=0,STARTING=1,STARTED=2,STOPPING=3;
-    private transient int _state=STOPPED;
-    protected void doStart() throws Exception {}
-    protected void doStop() throws Exception {}
+    private Object _lock = new Object();
+    private final int FAILED = -1, STOPPED = 0, STARTING = 1, STARTED = 2, STOPPING = 3;
+    private transient int _state = STOPPED;
+    protected LifeCycle.Listener[] _listeners;
 
+    protected void doStart() throws Exception
+    {
+    }
 
+    protected void doStop() throws Exception
+    {
+    }
+
     public final void start() throws Exception
     {
-        try
+        synchronized (_lock)
         {
-            if (_state==STARTED)
-                return;
-            _state=STARTING;
-            doStart();
-            Log.debug("started {}",this);
-            _state=STARTED;
+            try
+            {
+                if (_state == STARTED || _state == STARTING)
+                    return;
+                setStarting();
+                doStart();
+                Log.debug("started {}",this);
+                setStarted();
+            }
+            catch (Exception e)
+            {
+                setFailed(e);
+                throw e;
+            }
+            catch (Error e)
+            {
+                setFailed(e);
+                throw e;
+            }
         }
-        catch (Exception e)
-        {
-            Log.warn("failed "+this,e);
-            _state=FAILED;
-            throw e;
-        }
-        catch(Error e)
-        {
-            Log.warn("failed "+this,e);
-            _state=FAILED;
-            throw e;
-        }
     }
 
     public final void stop() throws Exception
     {
-        try
+        synchronized (_lock)
         {
-            if (_state==STOPPING || _state==STOPPED)
-                return;
-            _state=STOPPING;
-            doStop();
-            Log.debug("stopped {}",this);
-            _state=STOPPED;
+            try
+            {
+                if (_state == STOPPING || _state == STOPPED)
+                    return;
+                setStopping();
+                doStop();
+                Log.debug("stopped {}",this);
+                setStopped();
+            }
+            catch (Exception e)
+            {
+                setFailed(e);
+                throw e;
+            }
+            catch (Error e)
+            {
+                setFailed(e);
+                throw e;
+            }
         }
-        catch (Exception e)
-        {
-            Log.warn("failed "+this,e);
-            _state=FAILED;
-            throw e;
-        }
-        catch(Error e)
-        {
-            Log.warn("failed "+this,e);
-            _state=FAILED;
-            throw e;
-        }
     }
 
     public boolean isRunning()
     {
-        return _state==STARTED || _state==STARTING;
+        return _state == STARTED || _state == STARTING;
     }
 
     public boolean isStarted()
     {
-        return _state==STARTED;
+        return _state == STARTED;
     }
 
     public boolean isStarting()
     {
-        return _state==STARTING;
+        return _state == STARTING;
     }
 
     public boolean isStopping()
     {
-        return _state==STOPPING;
+        return _state == STOPPING;
     }
 
     public boolean isStopped()
     {
-        return _state==STOPPED;
+        return _state == STOPPED;
     }
 
     public boolean isFailed()
     {
-        return _state==FAILED;
+        return _state == FAILED;
     }
+
+    public void addLifeCycleListener(LifeCycle.Listener listener)
+    {
+        _listeners = (LifeCycle.Listener[])LazyList.addToArray(_listeners,listener,LifeCycle.Listener.class);
+    }
+
+    public void removeLifeCycleListener(LifeCycle.Listener listener)
+    {
+        LazyList.removeFromArray(_listeners,listener);
+    }
+
+    private void setStarted()
+    {
+        _state = STARTED;
+        if (_listeners != null)
+        {
+            for (int i = 0; i < _listeners.length; i++)
+            {
+                _listeners[i].lifeCycleStarted(this);
+            }
+        }
+    }
+
+    private void setStarting()
+    {
+        _state = STARTING;
+        if (_listeners != null)
+        {
+            for (int i = 0; i < _listeners.length; i++)
+            {
+                _listeners[i].lifeCycleStarting(this);
+            }
+        }
+    }
+
+    private void setStopping()
+    {
+        _state = STOPPING;
+        if (_listeners != null)
+        {
+            for (int i = 0; i < _listeners.length; i++)
+            {
+                _listeners[i].lifeCycleStopping(this);
+            }
+        }
+    }
+
+    private void setStopped()
+    {
+        _state = STOPPED;
+        if (_listeners != null)
+        {
+            for (int i = 0; i < _listeners.length; i++)
+            {
+                _listeners[i].lifeCycleStopped(this);
+            }
+        }
+    }
+
+    private void setFailed(Throwable th)
+    {
+        Log.warn("failed "+this+": "+th);
+        Log.debug(th);
+        _state = FAILED;
+        if (_listeners != null)
+        {
+            for (int i = 0; i < _listeners.length; i++)
+            {
+                _listeners[i].lifeCycleFailure(this,th);
+            }
+        }
+    }
+
 }
Index: modules/util/src/main/java/org/mortbay/servlet/GzipFilter.java
===================================================================
--- modules/util/src/main/java/org/mortbay/servlet/GzipFilter.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/servlet/GzipFilter.java	(working copy)
@@ -42,7 +42,7 @@
  * <li>The filter is mapped to a matching path</li>
  * <li>The response status code is >=200 and <300
  * <li>The content length is unknown or more than the <code>minGzipSize</code> initParameter or the minGzipSize is 0(default)</li>
- * <li>The content-type is in the coma separated list of mimeTypes set in the <code>mimeTypes</code> initParameter or
+ * <li>The content-type is in the comma separated list of mimeTypes set in the <code>mimeTypes</code> initParameter or
  * if no mimeTypes are defined the content-type is not "application/gzip"</li>
  * <li>No content-encoding is specified by the resource</li>
  * </ul>
@@ -110,7 +110,9 @@
         HttpServletResponse response=(HttpServletResponse)res;
 
         String ae = request.getHeader("accept-encoding");
-        if (ae != null && ae.indexOf("gzip")>=0 && !response.containsHeader("Content-Encoding"))
+        Boolean gzip=(Boolean)request.getAttribute("GzipFilter");
+        if (ae != null && ae.indexOf("gzip")>=0 && !response.containsHeader("Content-Encoding") &&
+            (gzip==null || gzip.booleanValue()) && !"HEAD".equalsIgnoreCase(request.getMethod()))
         {
             if (_excluded!=null)
             {
@@ -130,6 +132,13 @@
                 super.doFilter(request,wrappedResponse,chain);
                 exceptional=false;
             }
+            catch(RuntimeException e)
+            {
+                request.setAttribute("GzipFilter",Boolean.FALSE);
+                if (!response.isCommitted())
+                    response.reset();
+                throw e;
+            }
             finally
             {
                 if (exceptional && !response.isCommitted())
@@ -177,13 +186,17 @@
         public void setContentType(String ct)
         {
             super.setContentType(ct);
-            int colon=ct.indexOf(";");
-            if (colon>0)
-                ct=ct.substring(0,colon);
 
+            if (ct!=null)
+            {
+                int colon=ct.indexOf(";");
+                if (colon>0)
+                    ct=ct.substring(0,colon);
+            }
+
             if ((_gzStream==null || _gzStream._out==null) && 
                 (_mimeTypes==null && "application/gzip".equalsIgnoreCase(ct) ||
-                 _mimeTypes!=null && !_mimeTypes.contains(StringUtil.asciiToLowerCase(ct))))
+                 _mimeTypes!=null && (ct==null||!_mimeTypes.contains(StringUtil.asciiToLowerCase(ct)))))
             {
                 noGzip();
             }
@@ -361,7 +374,7 @@
                 }
                 catch (IOException e)
                 {
-                    throw new IllegalStateException(e);
+                    throw new IllegalStateException();
                 }
             }
         }
@@ -564,7 +577,7 @@
             {
                 if (_response.isCommitted() || (_contentLength>=0 && _contentLength<_minGzipSize))
                     doNotGzip();
-                else if (length>=(_bOut.size()-_bOut.getCount()))
+                else if (length>=(_bOut.getBuf().length-_bOut.getCount()))
                     doGzip();
             }
         }
Index: modules/util/src/main/java/org/mortbay/servlet/CGI.java
===================================================================
--- modules/util/src/main/java/org/mortbay/servlet/CGI.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/servlet/CGI.java	(working copy)
@@ -126,6 +126,16 @@
             if (n!=null&&n.startsWith("ENV_"))
                 _env.set(n.substring(4),getInitParameter(n));
         }
+        if(!_env.envMap.containsKey("SystemRoot"))
+        {
+      	    String os = System.getProperty("os.name");
+            if (os!=null && os.toLowerCase().indexOf("windows")!=-1)
+            {
+        	String windir = System.getProperty("windir");
+        	_env.set("SystemRoot", windir!=null ? windir : "C:\\WINDOWS"); 
+            }
+        }   
+      
         _ok=true;
     }
 
@@ -262,6 +272,8 @@
         final OutputStream outToCgi=p.getOutputStream();
         final int inLength=len;
 
+        IO.copyThread(p.getErrorStream(),System.err);
+        
         new Thread(new Runnable()
         {
             public void run()
@@ -347,7 +359,16 @@
         finally
         {
             if( os != null )
-            	os.close();
+            {
+                try
+                {
+                    os.close();
+                }
+            	catch(Exception e)
+            	{
+            	    Log.ignore(e);
+            	}
+            }
             os = null;
             p.destroy();
             // Log.debug("CGI: terminated!");
Index: modules/util/src/main/java/org/mortbay/servlet/ProxyServlet.java
===================================================================
--- modules/util/src/main/java/org/mortbay/servlet/ProxyServlet.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/servlet/ProxyServlet.java	(working copy)
@@ -20,6 +20,7 @@
 import java.io.OutputStream;
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
 import java.net.Socket;
 import java.net.URL;
 import java.net.URLConnection;
@@ -32,6 +33,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
+import javax.servlet.UnavailableException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
@@ -40,13 +42,14 @@
 
 
 /**
- * EXPERIMENTAL Proxy servlet.
- * @author gregw
+ * Proxy Servlet.
+ * <p>
+ * Forward requests to another server either as a standard web proxy (as defined by
+ * RFC2616) or as a transparent proxy.
  *
  */
 public class ProxyServlet implements Servlet
 {
-    private int _tunnelTimeoutMs=300000;
     
     protected HashSet _DontProxyHeaders = new HashSet();
     {
@@ -61,16 +64,16 @@
         _DontProxyHeaders.add("upgrade");
     }
     
-    private ServletConfig config;
-    private ServletContext context;
+    protected ServletConfig _config;
+    protected ServletContext _context;
     
     /* (non-Javadoc)
      * @see javax.servlet.Servlet#init(javax.servlet.ServletConfig)
      */
     public void init(ServletConfig config) throws ServletException
     {
-        this.config=config;
-        this.context=config.getServletContext();
+        this._config=config;
+        this._context=config.getServletContext();
     }
 
     /* (non-Javadoc)
@@ -78,7 +81,7 @@
      */
     public ServletConfig getServletConfig()
     {
-        return config;
+        return _config;
     }
 
     /* (non-Javadoc)
@@ -98,12 +101,12 @@
             String uri=request.getRequestURI();
             if (request.getQueryString()!=null)
                 uri+="?"+request.getQueryString();
-            URL url = new URL(request.getScheme(),
-                    		  request.getServerName(),
-                    		  request.getServerPort(),
-                    		  uri);
             
-            context.log("URL="+url);
+            URL url=proxyHttpURL(request.getScheme(),
+                    request.getServerName(),
+                    request.getServerPort(),
+                    uri);
+            
 
             URLConnection connection = url.openConnection();
             connection.setAllowUserInteraction(false);
@@ -152,7 +155,6 @@
                     if (val!=null)
                     {
                         connection.addRequestProperty(hdr,val);
-                        context.log("req "+hdr+": "+val);
                         xForwardedFor|="X-Forwarded-For".equalsIgnoreCase(hdr);
                     }
                 }
@@ -190,7 +192,7 @@
             }
             catch (Exception e)
             {
-                context.log("proxy",e);
+                _context.log("proxy",e);
             }
             
             InputStream proxy_in = null;
@@ -203,7 +205,6 @@
                 
                 code=http.getResponseCode();
                 response.setStatus(code, http.getResponseMessage());
-                context.log("response = "+http.getResponseCode());
             }
             
             if (proxy_in==null)
@@ -211,7 +212,7 @@
                 try {proxy_in=connection.getInputStream();}
                 catch (Exception e)
                 {
-                    context.log("stream",e);
+                    _context.log("stream",e);
                     proxy_in = http.getErrorStream();
                 }
             }
@@ -229,8 +230,6 @@
                 String lhdr = hdr!=null?hdr.toLowerCase():null;
                 if (hdr!=null && val!=null && !_DontProxyHeaders.contains(lhdr))
                     response.addHeader(hdr,val);
-
-                context.log("res "+hdr+": "+val);
                 
                 h++;
                 hdr=connection.getHeaderFieldKey(h);
@@ -245,16 +244,30 @@
         }
     }
 
-
     /* ------------------------------------------------------------ */
+    /** Resolve requested URL to the Proxied URL
+     * @param scheme The scheme of the received request.
+     * @param serverName The server encoded in the received request(which 
+     * may be from an absolute URL in the request line).
+     * @param serverPort The server port of the received request (which 
+     * may be from an absolute URL in the request line).
+     * @param uri The URI of the received request.
+     * @return The URL to which the request should be proxied.
+     * @throws MalformedURLException
+     */
+    protected URL proxyHttpURL(String scheme, String serverName, int serverPort, String uri)
+        throws MalformedURLException
+    {
+        return new URL(scheme,serverName,serverPort,uri);
+    }
+    
+    /* ------------------------------------------------------------ */
     public void handleConnect(HttpServletRequest request,
                               HttpServletResponse response)
         throws IOException
     {
         String uri = request.getRequestURI();
         
-        context.log("CONNECT: "+uri);
-        
         String port = "";
         String host = "";
         
@@ -282,17 +295,12 @@
             OutputStream out=response.getOutputStream();
             
             Socket socket = new Socket(inetAddress.getAddress(),inetAddress.getPort());
-            context.log("Socket: "+socket);
             
             response.setStatus(200);
             response.setHeader("Connection","close");
             response.flushBuffer();
             
-            
-
-            context.log("out<-in");
             IO.copyThread(socket.getInputStream(),out);
-            context.log("in->out");
             IO.copy(in,socket.getOutputStream());
         }
     }
@@ -315,4 +323,56 @@
     {
 
     }
+    /**
+     * Transparent Proxy.
+     * 
+     * This convenience extension to AsyncProxyServlet configures the servlet
+     * as a transparent proxy.   The servlet is configured with init parameter:<ul>
+     * <li> ProxyTo - a URI like http://host:80/context to which the request is proxied.
+     * <li> Prefix  - a URI prefix that is striped from the start of the forwarded URI.
+     * </ul>
+     * For example, if a request was received at /foo/bar and the ProxyTo was  http://host:80/context
+     * and the Prefix was /foo, then the request would be proxied to http://host:80/context/bar
+     *
+     */
+    public static class Transparent extends ProxyServlet
+    {
+        String _prefix;
+        String _proxyTo;
+        
+        public Transparent()
+        {    
+        }
+        
+        public Transparent(String prefix,String server, int port)
+        {
+            _prefix=prefix;
+            _proxyTo="http://"+server+":"+port;
+        }
+
+        public void init(ServletConfig config) throws ServletException
+        {
+            if (config.getInitParameter("ProxyTo")!=null)
+                _proxyTo=config.getInitParameter("ProxyTo");
+            if (config.getInitParameter("Prefix")!=null)
+                _prefix=config.getInitParameter("Prefix");
+            if (_proxyTo==null)
+                throw new UnavailableException("No ProxyTo");
+            super.init(config);
+            
+            _context.log("Transparent ProxyServlet @ "+(_prefix==null?"-":_prefix)+ " to "+_proxyTo);
+            
+        }
+        
+        protected URL proxyHttpURL(final String scheme, final String serverName, int serverPort, final String uri) throws MalformedURLException
+        {
+            if (_prefix!=null && !uri.startsWith(_prefix))
+                return null;
+            
+            if (_prefix!=null)
+                return new URL(_proxyTo+uri.substring(_prefix.length()));
+            return new URL(_proxyTo+uri);
+        }
+    }
+
 }
Index: modules/util/src/main/java/org/mortbay/servlet/MultiPartFilter.java
===================================================================
--- modules/util/src/main/java/org/mortbay/servlet/MultiPartFilter.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/servlet/MultiPartFilter.java	(working copy)
@@ -14,6 +14,7 @@
 package org.mortbay.servlet;
 
 import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -39,6 +40,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletRequestWrapper;
 
+import org.mortbay.util.LazyList;
 import org.mortbay.util.MultiMap;
 import org.mortbay.util.StringUtil;
 import org.mortbay.util.TypeUtil;
@@ -64,6 +66,7 @@
     private File tempdir;
     private boolean _deleteFiles;
     private ServletContext _context;
+    private int _fileOutputBuffer = 0;
 
     /* ------------------------------------------------------------------------------- */
     /**
@@ -73,6 +76,9 @@
     {
         tempdir=(File)filterConfig.getServletContext().getAttribute("javax.servlet.context.tempdir");
         _deleteFiles="true".equals(filterConfig.getInitParameter("deleteFiles"));
+        String fileOutputBuffer = filterConfig.getInitParameter("fileOutputBuffer");
+        if(fileOutputBuffer!=null)
+            _fileOutputBuffer = Integer.parseInt(fileOutputBuffer);
         _context=filterConfig.getServletContext();
     }
 
@@ -98,7 +104,17 @@
         
         String boundary="--"+value(content_type.substring(content_type.indexOf("boundary=")));
         byte[] byteBoundary=(boundary+"--").getBytes(StringUtil.__ISO_8859_1);
+        
         MultiMap params = new MultiMap();
+        for (Iterator i = request.getParameterMap().entrySet().iterator();i.hasNext();)
+        {
+            Map.Entry entry=(Map.Entry)i.next();
+            Object value=entry.getValue();
+            if (value instanceof String[])
+                params.addValues(entry.getKey(),(String[])value);
+            else
+                params.add(entry.getKey(),value);
+        }
         
         try
         {
@@ -160,7 +176,13 @@
                 {
                     continue;
                 }
-                if(name==null||name.length()==0)
+                
+                //It is valid for reset and submit buttons to have an empty name.
+                //If no name is supplied, the browser skips sending the info for that field.
+                //However, if you supply the empty string as the name, the browser sends the
+                //field, with name as the empty string. So, only continue this loop if we
+                //have not yet seen a name field.
+                if(name==null)
                 {
                     continue;
                 }
@@ -173,8 +195,10 @@
                     {
                         file = File.createTempFile("MultiPart", "", tempdir);
                         out = new FileOutputStream(file);
+                        if(_fileOutputBuffer>0)
+                            out = new BufferedOutputStream(out, _fileOutputBuffer);
                         request.setAttribute(name,file);
-                        params.put(name, filename);
+                        params.add(name, filename);
                         
                         if (_deleteFiles)
                         {
@@ -359,6 +383,9 @@
         public String getParameter(String name)
         {
             Object o=map.get(name);
+            if (!(o instanceof byte[]) && LazyList.size(o)>0)
+                o=LazyList.get(o,0);
+            
             if (o instanceof byte[])
             {
                 try
@@ -371,8 +398,8 @@
                     e.printStackTrace();
                 }
             }
-            else if (o instanceof String)
-                return (String)o;
+            else if (o!=null)
+                return String.valueOf(o);
             return null;
         }
         
@@ -382,7 +409,7 @@
          */
         public Map getParameterMap()
         {
-            return map;
+            return Collections.unmodifiableMap(map.toStringArrayMap());
         }
         
         /* ------------------------------------------------------------------------------- */
Index: modules/util/src/main/java/org/mortbay/thread/BoundedThreadPool.java
===================================================================
--- modules/util/src/main/java/org/mortbay/thread/BoundedThreadPool.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/thread/BoundedThreadPool.java	(working copy)
@@ -35,6 +35,7 @@
  * By default there is no maximum pool size.  Idle threads timeout
  * and terminate until the minimum number of threads are running.
  * <p>
+ * @deprecated Use {@link QueuedThreadPool}
  * @author Greg Wilkins <gregw@mortbay.com>
  * @author Juancarlo Anez <juancarlo@modelistica.com>
  */
@@ -45,10 +46,10 @@
     private int _id;
     private List _idle;
 
+    private final Object _lock = new Object();
     private final Object _joinLock = new Object();
 
     private long _lastShrink;
-    private final Object _lock = new Object();
     private int _maxIdleTimeMs=60000;
     private int _maxThreads=255;
     private int _minThreads=1;
@@ -189,6 +190,14 @@
         return _priority;
     }
 
+    /* ------------------------------------------------------------ */
+    public int getQueueSize()
+    {
+        synchronized(_lock)
+        {
+            return _queue.size();
+        }
+    }
 
     /* ------------------------------------------------------------ */
     /** 
@@ -202,7 +211,7 @@
     /* ------------------------------------------------------------ */
     public boolean isLowOnThreads()
     {
-        synchronized(this)
+        synchronized(_lock)
         {
             // maybe make this volatile?
             return _queue.size()>_lowThreads;
Index: modules/util/src/main/java/org/mortbay/thread/Timeout.java
===================================================================
--- modules/util/src/main/java/org/mortbay/thread/Timeout.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/thread/Timeout.java	(working copy)
@@ -21,9 +21,9 @@
 /* ------------------------------------------------------------ */
 /** Timeout queue.
  * This class implements a timeout queue for timers that are at least as likely to be cancelled as they are to expire.
- * Unlike the util timeout class, the duration of the timouts is shared by all scheduled tasks and if the duration 
+ * Unlike the util timeout class, the duration of the timeouts is shared by all scheduled tasks and if the duration 
  * is changed, this affects all scheduled tasks.
- * 
+ * <p>
  * The nested class Task should be extended by users of this class to obtain call back notification of 
  * expiries. 
  * 
@@ -32,17 +32,26 @@
  */
 public class Timeout
 {
-    
+    private Object _lock;
     private long _duration;
-    private long _now=System.currentTimeMillis();
+    private volatile long _now=System.currentTimeMillis();
     private Task _head=new Task();
-    
+
+    /* ------------------------------------------------------------ */
     public Timeout()
     {
+        _lock=new Object();
         _head._timeout=this;
     }
 
     /* ------------------------------------------------------------ */
+    public Timeout(Object lock)
+    {
+        _lock=lock;
+        _head._timeout=this;
+    }
+
+    /* ------------------------------------------------------------ */
     /**
      * @return Returns the duration.
      */
@@ -61,9 +70,10 @@
     }
 
     /* ------------------------------------------------------------ */
-    public void setNow()
+    public long setNow()
     {
         _now=System.currentTimeMillis();
+        return _now; 
     }
     
     /* ------------------------------------------------------------ */
@@ -79,41 +89,55 @@
     }
 
     /* ------------------------------------------------------------ */
+    /** Get an expired tasks.
+     * This is called instead of {@link #tick()} to obtain the next
+     * expired Task, but without calling it's {@link Task#expire()} or
+     * {@link Task#expired()} methods.
+     * 
+     * @returns the next expired task or null.
+     */
     public Task expired()
     {
-        long _expiry = _now-_duration;
-        
-        if (_head._next!=_head)
+        long now=_now;
+        synchronized (_lock)
         {
-            Task task = _head._next;
-            if (task._timestamp>_expiry)
-                return null;
-            
-            task.unlink();
-            synchronized (task)
+            long _expiry = now-_duration;
+
+            if (_head._next!=_head)
             {
+                Task task = _head._next;
+                if (task._timestamp>_expiry)
+                    return null;
+
+                task.unlink();
                 task._expired=true;
+                return task;
             }
-            return task;
+            return null;
         }
-        return null;
     }
 
     /* ------------------------------------------------------------ */
     public void tick()
     {
-        long _expiry = _now-_duration;
+        final long expiry = _now-_duration;
         
-        while (_head._next!=_head)
+        Task task=null;
+        while (true)
         {
-            Task task = _head._next;
-            if (task._timestamp>_expiry)
-                break;
-            
-            task.unlink();
             try
             {
-                task.doExpire();
+                synchronized (_lock)
+                {
+                    task= _head._next;
+                    if (task==_head || task._timestamp>expiry)
+                        break;
+                    task.unlink();
+                    task._expired=true;
+                    task.expire();
+                }
+                
+                task.expired();
             }
             catch(Throwable th)
             {
@@ -123,53 +147,77 @@
     }
 
     /* ------------------------------------------------------------ */
+    public void tick(long now)
+    {
+        _now=now;
+        tick();
+    }
+
+    /* ------------------------------------------------------------ */
     public void schedule(Task task)
     {
         schedule(task,0L);
     }
     
     /* ------------------------------------------------------------ */
+    /**
+     * @param task
+     * @param delay A delay in addition to the default duration of the timeout
+     */
     public void schedule(Task task,long delay)
     {
-        if (task._timestamp!=0)
+        synchronized (_lock)
         {
-            task.unlink();
-            task._timestamp=0;
+            if (task._timestamp!=0)
+            {
+                task.unlink();
+                task._timestamp=0;
+            }
+            task._timeout=this;
+            task._expired=false;
+            task._delay=delay;
+            task._timestamp = _now+delay;
+
+            Task last=_head._prev;
+            while (last!=_head)
+            {
+                if (last._timestamp <= task._timestamp)
+                    break;
+                last=last._prev;
+            }
+            last.link(task);
         }
-        task._expired=false;
-        task._delay=delay;
-        task._timestamp = _now+delay;
-        
-        Task last=_head._prev;
-        while (last!=_head)
-        {
-            if (last._timestamp <= task._timestamp)
-                break;
-            last=last._prev;
-        }
-        last.setNext(task);
     }
 
 
     /* ------------------------------------------------------------ */
     public void cancelAll()
     {
-        _head._next=_head._prev=_head;
+        synchronized (_lock)
+        {
+            _head._next=_head._prev=_head;
+        }
     }
 
     /* ------------------------------------------------------------ */
     public boolean isEmpty()
     {
-        return _head._next==_head;
+        synchronized (_lock)
+        {
+            return _head._next==_head;
+        }
     }
 
     /* ------------------------------------------------------------ */
     public long getTimeToNext()
     {
-        if (_head._next==_head)
-            return -1;
-        long to_next = _duration+_head._next._timestamp-_now;
-        return to_next<0?0:to_next;
+        synchronized (_lock)
+        {
+            if (_head._next==_head)
+                return -1;
+            long to_next = _duration+_head._next._timestamp-_now;
+            return to_next<0?0:to_next;
+        }
     }
 
     /* ------------------------------------------------------------ */
@@ -210,45 +258,48 @@
         long _timestamp=0;
         boolean _expired=false;
 
+        /* ------------------------------------------------------------ */
         public Task()
         {
             _next=_prev=this;
         }
 
+        /* ------------------------------------------------------------ */
         public long getTimestamp()
         {
             return _timestamp;
         }
-        
+
+        /* ------------------------------------------------------------ */
         public long getAge()
         {
-            Timeout t = _timeout;
-            if (t!=null && t._now!=0 && _timestamp!=0)
-                return t._now-_timestamp;
+            final Timeout t = _timeout;
+            if (t!=null)
+            {
+                final long now=t._now;
+                if (now!=0 && _timestamp!=0)
+                    return now-_timestamp;
+            }
             return 0;
         }
-        
-        public void unlink()
+
+        /* ------------------------------------------------------------ */
+        private void unlink()
         {
             _next._prev=_prev;
             _prev._next=_next;
             _next=_prev=this;
-            _timeout=null;
             _expired=false;
         }
 
-        public void setNext(Task task)
+        /* ------------------------------------------------------------ */
+        private void link(Task task)
         {
-            if (_timeout==null || 
-                task._timeout!=null && task._timeout!=_timeout ||    
-                task._next!=task)
-                throw new IllegalStateException();
             Task next_next = _next;
             _next._prev=task;
             _next=task;
             _next._next=next_next;
             _next._prev=this;   
-            _next._timeout=_timeout;
         }
         
         /* ------------------------------------------------------------ */
@@ -258,7 +309,6 @@
          */
         public void schedule(Timeout timer)
         {
-            unlink();
             timer.schedule(this);
         }
         
@@ -269,20 +319,19 @@
          */
         public void schedule(Timeout timer, long delay)
         {
-            unlink();
             timer.schedule(this,delay);
         }
         
         /* ------------------------------------------------------------ */
         /** Reschedule the task on the current timeout.
-         * The task timeout is rescheduled as if it had been canceled and
+         * The task timeout is rescheduled as if it had been cancelled and
          * scheduled on the current timeout.
          */
         public void reschedule()
         {
-            Timeout timer = _timeout;
-            unlink();
-            timer.schedule(this,_delay);
+            Timeout timeout = _timeout;
+            if (timeout!=null)
+                timeout.schedule(this,_delay);
         }
         
         /* ------------------------------------------------------------ */
@@ -291,27 +340,40 @@
          */
         public void cancel()
         {
-            _timestamp=0;
-            unlink();
+            Timeout timeout = _timeout;
+            if (timeout!=null)
+            {
+                synchronized (timeout._lock)
+                {
+                    unlink();
+                    _timestamp=0;
+                }
+            }
         }
         
+        /* ------------------------------------------------------------ */
         public boolean isExpired() { return _expired; }
+
+        /* ------------------------------------------------------------ */
+	public boolean isScheduled() { return _next!=this; }
         
         /* ------------------------------------------------------------ */
         /** Expire task.
-         * This method is called when the timeout expires.
+         * This method is called when the timeout expires. It is called
+         * in the scope of the synchronize block (on this) that sets 
+         * the {@link #isExpired()} state to true.
+         * @see #expired() For an unsynchronized callback.
+         */
+        public void expire(){}
+
+        /* ------------------------------------------------------------ */
+        /** Expire task.
+         * This method is called when the timeout expires. It is called 
+         * outside of any synchronization scope and may be delayed. 
          * 
          */
-        public void expire(){}
-        
-        private void doExpire()
-        {
-            synchronized (this)
-            {
-                _expired=true;
-                expire();
-            }
-        }
+        public void expired(){}
+
     }
 
 }
Index: modules/util/src/main/java/org/mortbay/util/RolloverFileOutputStream.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/RolloverFileOutputStream.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/RolloverFileOutputStream.java	(working copy)
@@ -113,7 +113,7 @@
         throws IOException
     {
 
-         this(filename,append,retainDays,TimeZone.getDefault(),null,null);
+         this(filename,append,retainDays,zone,null,null);
     }
      
     /* ------------------------------------------------------------ */
@@ -166,7 +166,7 @@
         synchronized(RolloverFileOutputStream.class)
         {
             if (__rollover==null)
-                __rollover=new Timer();
+                __rollover=new Timer(true);
             
             _rollTask=new RollTask();
 
Index: modules/util/src/main/java/org/mortbay/util/DateCache.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/DateCache.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/DateCache.java	(working copy)
@@ -41,8 +41,8 @@
 
 public class DateCache  
 {
+    public static String DEFAULT_FORMAT="EEE MMM dd HH:mm:ss zzz yyyy";
     private static long __hitWindow=60*60;
-    private static long __MaxMisses=10;
     
     private String _formatString;
     private String _tzFormatString;
@@ -70,7 +70,7 @@
      */
     public DateCache()
     {
-        this("EEE MMM dd HH:mm:ss zzz yyyy");
+        this(DEFAULT_FORMAT);
         getFormat().setTimeZone(TimeZone.getDefault());
     }
     
@@ -297,8 +297,7 @@
     public String now()
     {
         long now=System.currentTimeMillis();
-        int n=0xfff&(int)now;
-        _lastMs=n%1000;
+        _lastMs=(int)(now%1000);
         return format(now);
     }
 
Index: modules/util/src/main/java/org/mortbay/util/ajax/ContinuationSupport.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/ajax/ContinuationSupport.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/ajax/ContinuationSupport.java	(working copy)
@@ -30,7 +30,7 @@
         Continuation continuation = (Continuation) request.getAttribute("org.mortbay.jetty.ajax.Continuation");
         if (continuation==null)
             continuation=new WaitingContinuation(lock);
-        else if (continuation instanceof WaitingContinuation && continuation.isNew() && lock!=null)
+        else if (continuation instanceof WaitingContinuation  && lock!=null)
             ((WaitingContinuation)continuation).setMutex(lock);
         return continuation;
     }
Index: modules/util/src/main/java/org/mortbay/util/ajax/AjaxFilter.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/ajax/AjaxFilter.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/ajax/AjaxFilter.java	(working copy)
@@ -30,6 +30,10 @@
 import javax.servlet.http.HttpServletResponse;
 
 
+/**
+ * @author gregw
+ * @deprecated Use Cometd
+ */
 public class AjaxFilter implements Filter
 {
     ServletContext context;
@@ -73,9 +77,7 @@
             out.println("</ajax-response>");
             byte[] ajax = sout.toString().getBytes("UTF-8");
             sresponse.setHeader( "Pragma", "no-cache" );
-            sresponse.addHeader( "Cache-Control", "must-revalidate" );
-            sresponse.addHeader( "Cache-Control", "no-cache" );
-            sresponse.addHeader( "Cache-Control", "no-store" );
+            sresponse.addHeader( "Cache-Control", "must-revalidate,no-cache,no-store" );
             sresponse.setDateHeader("Expires", 0);
             sresponse.setContentType("text/xml; charset=UTF-8");
             sresponse.setContentLength(ajax.length);
Index: modules/util/src/main/java/org/mortbay/util/ajax/JSON.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/ajax/JSON.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/ajax/JSON.java	(working copy)
@@ -1,34 +1,38 @@
-// ========================================================================
-// Copyright 2006 Mort Bay Consulting Pty. Ltd.
-// ------------------------------------------------------------------------
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at 
-// http://www.apache.org/licenses/LICENSE-2.0
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-// ========================================================================
+//========================================================================
+//Copyright 2004-2008 Mort Bay Consulting Pty. Ltd.
+//------------------------------------------------------------------------
+//Licensed under the Apache License, Version 2.0 (the "License");
+//you may not use this file except in compliance with the License.
+//You may obtain a copy of the License at 
+//http://www.apache.org/licenses/LICENSE-2.0
+//Unless required by applicable law or agreed to in writing, software
+//distributed under the License is distributed on an "AS IS" BASIS,
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//See the License for the specific language governing permissions and
+//limitations under the License.
+//========================================================================
 
 package org.mortbay.util.ajax;
 
+import java.io.Externalizable;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.Reader;
 import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 
+import org.mortbay.log.Log;
 import org.mortbay.util.IO;
-import org.mortbay.util.LazyList;
+import org.mortbay.util.Loader;
 import org.mortbay.util.QuotedStringTokenizer;
 import org.mortbay.util.TypeUtil;
 
-
 /** JSON Parser and Generator.
  * 
  * <p>This class provides some static methods to convert POJOs to and from JSON
@@ -52,93 +56,208 @@
  *   Object --> string (dubious!)
  * </pre>
  * </p><p>
+ * The interface {@link JSON.Convertible} may be implemented by classes that wish to externalize and 
+ * initialize specific fields to and from JSON objects.  Only directed acyclic graphs of objects are supported.
+ * </p>
+ * <p>
  * The interface {@link JSON.Generator} may be implemented by classes that know how to render themselves as JSON and
  * the {@link #toString(Object)} method will use {@link JSON.Generator#addJSON(StringBuffer)} to generate the JSON.
  * The class {@link JSON.Literal} may be used to hold pre-gnerated JSON object. 
+ * <p>
+ * The interface {@link Convertor} may be implemented to provide static convertors for objects that may be registered 
+ * with {@link #registerConvertor(Class, org.mortbay.util.ajax.JSON.Convertor)}. These convertors are looked up by class, interface and
+ * super class by {@link #getConvertor(Class)}.
  * </p>
  * @author gregw
  *
  */
 public class JSON
 {
-    private JSON(){}
+    private static JSON __default = new JSON();
+
+    private Map _convertors=Collections.synchronizedMap(new HashMap());
+    private int _stringBufferSize=256;
     
+    
+    public JSON()
+    {
+    }
+    
+    /* ------------------------------------------------------------ */
+    /**
+     * @return the initial stringBuffer size to use when creating JSON strings (default 256)
+     */
+    public int getStringBufferSize()
+    {
+        return _stringBufferSize;
+    }
+
+
+
+    /* ------------------------------------------------------------ */
+    /**
+     * @param stringBufferSize the initial stringBuffer size to use when creating JSON strings (default 256)
+     */
+    public void setStringBufferSize(int stringBufferSize)
+    {
+        _stringBufferSize=stringBufferSize;
+    }
+    
+
+
+
+    /**
+     * Register a {@link Convertor} for a class or interface.
+     * @param forClass The class or interface that the convertor applies to
+     * @param convertor the convertor
+     */
+    public static void registerConvertor(Class forClass, Convertor convertor)
+    {
+        __default.addConvertor(forClass,convertor);
+    }
+
+    public static JSON getDefault()
+    {
+        return __default;
+    }
+
+    public static void setDefault(JSON json)
+    {
+        __default=json;
+    }
+    
     public static String toString(Object object)
     {
-        StringBuffer buffer = new StringBuffer();
-        append(buffer,object);
-        return buffer.toString();
+        StringBuffer buffer=new StringBuffer(__default.getStringBufferSize());
+        synchronized (buffer)
+        {
+            __default.append(buffer,object);
+            return buffer.toString();
+        }
     }
-    
+
     public static String toString(Map object)
     {
-        StringBuffer buffer = new StringBuffer();
-        appendMap(buffer,object);
-        return buffer.toString();
+        StringBuffer buffer=new StringBuffer(__default.getStringBufferSize());
+        synchronized (buffer)
+        {
+            __default.appendMap(buffer,object);
+            return buffer.toString();
+        }
     }
-    
+
     public static String toString(Object[] array)
     {
-        StringBuffer buffer = new StringBuffer();
-        appendArray(buffer,array);
-        return buffer.toString();
+        StringBuffer buffer=new StringBuffer(__default.getStringBufferSize());
+        synchronized (buffer)
+        {
+            __default.appendArray(buffer,array);
+            return buffer.toString();
+        }
     }
 
     /**
      * @param s String containing JSON object or array.
+     * @return A Map, Object array or primitive array parsed from the JSON.
+     */
+    public static Object parse(String s)
+    {
+        return __default.parse(new StringSource(s),false);
+    }
+
+    /**
+     * @param s String containing JSON object or array.
      * @param stripOuterComment If true, an outer comment around the JSON is ignored.
      * @return A Map, Object array or primitive array parsed from the JSON.
      */
-    public static Object parse(String s,boolean stripOuterComment)
+    public static Object parse(String s, boolean stripOuterComment)
     {
-        return parse(new Source(s),stripOuterComment);
+        return __default.parse(new StringSource(s),stripOuterComment);
     }
 
     /**
+     * @param in Reader containing JSON object or array.
+     * @return A Map, Object array or primitive array parsed from the JSON.
+     */
+    public static Object parse(Reader in) throws IOException
+    {
+        return __default.parse(new ReaderSource(in),false);
+    }
+
+    /**
      * @param s Stream containing JSON object or array.
      * @param stripOuterComment If true, an outer comment around the JSON is ignored.
      * @return A Map, Object array or primitive array parsed from the JSON.
      */
-    public static Object parse(InputStream in,boolean stripOuterComment) throws IOException
+    public static Object parse(Reader in, boolean stripOuterComment) throws IOException
     {
-        String s=IO.toString(in);
-        return parse(new Source(s),stripOuterComment);
+        return __default.parse(new ReaderSource(in),stripOuterComment);
     }
-    
+
     /**
-     * @param s String containing JSON object or array.
+     * @deprecated use {@link #parse(Reader)}
+     * @param in Reader containing JSON object or array.
      * @return A Map, Object array or primitive array parsed from the JSON.
      */
-    public static Object parse(String s)
+    public static Object parse(InputStream in) throws IOException
     {
-        return parse(new Source(s),false);
+        return __default.parse(new StringSource(IO.toString(in)),false);
     }
 
     /**
+     * @deprecated use {@link #parse(Reader, boolean)}
      * @param s Stream containing JSON object or array.
+     * @param stripOuterComment If true, an outer comment around the JSON is ignored.
      * @return A Map, Object array or primitive array parsed from the JSON.
      */
-    public static Object parse(InputStream in) throws IOException
+    public static Object parse(InputStream in, boolean stripOuterComment) throws IOException
     {
-        String s=IO.toString(in);
-        return parse(new Source(s),false);
+        return __default.parse(new StringSource(IO.toString(in)),stripOuterComment);
     }
+
+    /* ------------------------------------------------------------ */
+    /** Convert Object to JSON
+     * @param object The object to convert
+     * @return The JSON String
+     */
+    public String toJSON(Object object)
+    {
+        StringBuffer buffer=new StringBuffer(getStringBufferSize());
+        synchronized (buffer)
+        {
+            append(buffer,object);
+            return buffer.toString();
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    /** Convert JSON to Object
+     * @param json The json to convert
+     * @return The object
+     */
+    public Object fromJSON(String json)
+    {
+        Source source = new StringSource(json);
+        return parse(source);
+    }
     
     /**
      * Append object as JSON to string buffer.
      * @param buffer
      * @param object
      */
-    public static void append(StringBuffer buffer, Object object)
+    public void append(StringBuffer buffer, Object object)
     {
         if (object==null)
             buffer.append("null");
+        else if (object instanceof Convertible)
+            appendJSON(buffer,(Convertible)object);
         else if (object instanceof Generator)
-            appendJSON(buffer, (Generator)object);
+            appendJSON(buffer,(Generator)object);
         else if (object instanceof Map)
-            appendMap(buffer, (Map)object);
-        else if (object instanceof List)
-            appendArray(buffer,LazyList.toArray(object,Object.class));
+            appendMap(buffer,(Map)object);
+        else if (object instanceof Collection)
+            appendArray(buffer,(Collection)object);
         else if (object.getClass().isArray())
             appendArray(buffer,object);
         else if (object instanceof Number)
@@ -147,34 +266,129 @@
             appendBoolean(buffer,(Boolean)object);
         else if (object instanceof String)
             appendString(buffer,(String)object);
-        else 
-            // TODO - maybe some bean stuff?
-            appendString(buffer,object.toString());
+        else
+        {
+            Convertor convertor=getConvertor(object.getClass());
+            if (convertor!=null)
+                appendJSON(buffer,convertor,object);
+            else
+                appendString(buffer,object.toString());
+        }
     }
 
-    private static void appendNull(StringBuffer buffer)
+    public void appendNull(StringBuffer buffer)
     {
         buffer.append("null");
     }
 
-    private static void appendJSON(StringBuffer buffer, Generator generator)
+    public void appendJSON(final StringBuffer buffer, final Convertor convertor, final Object object)
     {
+        appendJSON(buffer,new Convertible()
+        {
+            public void fromJSON(Map object)
+            {
+            }
+
+            public void toJSON(Output out)
+            {
+                convertor.toJSON(object,out);
+            }
+        });
+    }
+
+    public void appendJSON(final StringBuffer buffer, Convertible converter)
+    {
+        final char[] c=
+        { '{' };
+        converter.toJSON(new Output()
+        {
+            public void add(Object obj)
+            {
+                if (c[0]==0)
+                    throw new IllegalStateException();
+                append(buffer,obj);
+                c[0]=0;
+            }
+
+            public void addClass(Class type)
+            {
+                if (c[0]==0)
+                    throw new IllegalStateException();
+                buffer.append(c);
+                buffer.append("\"class\":");
+                append(buffer,type.getName());
+                c[0]=',';
+            }
+
+            public void add(String name, Object value)
+            {
+                if (c[0]==0)
+                    throw new IllegalStateException();
+                buffer.append(c);
+                QuotedStringTokenizer.quote(buffer,name);
+                buffer.append(':');
+                append(buffer,value);
+                c[0]=',';
+            }
+
+            public void add(String name, double value)
+            {
+                if (c[0]==0)
+                    throw new IllegalStateException();
+                buffer.append(c);
+                QuotedStringTokenizer.quote(buffer,name);
+                buffer.append(':');
+                appendNumber(buffer,new Double(value));
+                c[0]=',';
+            }
+
+            public void add(String name, long value)
+            {
+                if (c[0]==0)
+                    throw new IllegalStateException();
+                buffer.append(c);
+                QuotedStringTokenizer.quote(buffer,name);
+                buffer.append(':');
+                appendNumber(buffer,TypeUtil.newLong(value));
+                c[0]=',';
+            }
+
+            public void add(String name, boolean value)
+            {
+                if (c[0]==0)
+                    throw new IllegalStateException();
+                buffer.append(c);
+                QuotedStringTokenizer.quote(buffer,name);
+                buffer.append(':');
+                appendBoolean(buffer,value?Boolean.TRUE:Boolean.FALSE);
+                c[0]=',';
+            }
+        });
+
+        if (c[0]=='{')
+            buffer.append("{}");
+        else if (c[0]!=0)
+            buffer.append("}");
+    }
+
+    public void appendJSON(StringBuffer buffer, Generator generator)
+    {
         generator.addJSON(buffer);
     }
-    
-    private static void appendMap(StringBuffer buffer, Map object)
+
+    public void appendMap(StringBuffer buffer, Map object)
     {
         if (object==null)
         {
             appendNull(buffer);
             return;
         }
-        
+
         buffer.append('{');
-        Iterator iter = object.entrySet().iterator();
-        while(iter.hasNext())
+        Iterator iter=object.entrySet().iterator();
+        while (iter.hasNext())
         {
-            Map.Entry entry = (Map.Entry)iter.next();
+            Map.Entry entry=(Map.Entry)iter.next();
             QuotedStringTokenizer.quote(buffer,entry.getKey().toString());
             buffer.append(':');
             append(buffer,entry.getValue());
@@ -184,9 +398,32 @@
 
         buffer.append('}');
     }
-    
-    private static void appendArray(StringBuffer buffer, Object array)
+
+    public void appendArray(StringBuffer buffer, Collection collection)
     {
+        if (collection==null)
+        {
+            appendNull(buffer);
+            return;
+        }
+
+        buffer.append('[');
+        Iterator iter=collection.iterator();
+        boolean first=true;
+        while (iter.hasNext())
+        {
+            if (!first)
+                buffer.append(',');
+
+            first=false;
+            append(buffer,iter.next());
+        }
+
+        buffer.append(']');
+    }
+
+    public void appendArray(StringBuffer buffer, Object array)
+    {
         if (array==null)
         {
             appendNull(buffer);
@@ -194,19 +431,19 @@
         }
 
         buffer.append('[');
-        int length = Array.getLength(array);
-        
-        for (int i=0;i<length;i++)
+        int length=Array.getLength(array);
+
+        for (int i=0; i<length; i++)
         {
-            if(i!=0)
+            if (i!=0)
                 buffer.append(',');
             append(buffer,Array.get(array,i));
         }
-        
+
         buffer.append(']');
     }
 
-    private static void appendBoolean(StringBuffer buffer, Boolean b)
+    public void appendBoolean(StringBuffer buffer, Boolean b)
     {
         if (b==null)
         {
@@ -215,8 +452,8 @@
         }
         buffer.append(b.booleanValue()?"true":"false");
     }
-    
-    private static void appendNumber(StringBuffer buffer, Number number)
+
+    public void appendNumber(StringBuffer buffer, Number number)
     {
         if (number==null)
         {
@@ -225,8 +462,8 @@
         }
         buffer.append(number);
     }
-    
-    private static void appendString(StringBuffer buffer, String string)
+
+    public void appendString(StringBuffer buffer, String string)
     {
         if (string==null)
         {
@@ -237,24 +474,151 @@
         QuotedStringTokenizer.quote(buffer,string);
     }
     
-    private static Object parse(Source source,boolean stripOuterComment)
+    
+    
+    
+    
+    
+    
+    // Parsing utilities
+    
+    protected String toString(char[] buffer,int offset,int length)
     {
-        int comment_state=0;                   // 0=no comment, 1="/", 2="/*", 3="/* *" -1="//"
-        int strip_state=stripOuterComment?1:0; // 0=no strip, 1=wait for /*, 2= wait for */
+        return new String(buffer,offset,length);
+    }
+    
+    protected Map newMap()
+    {
+        return new HashMap();
+    }
+    
+    protected Object[] newArray(int size)
+    {
+        return new Object[size];
+    }
+
+    protected JSON contextForArray()
+    {
+        return this;
+    }
+    
+    protected JSON contextFor(String field)
+    {
+        return this;
+    }
+    
+    protected Object convertTo(Class type,Map map)
+    {
+        if (type!=null&&Convertible.class.isAssignableFrom(type))
+        {
+            try
+            {
+                Convertible conv=(Convertible)type.newInstance();
+                conv.fromJSON(map);
+                return conv;
+            }
+            catch (Exception e)
+            {
+                throw new RuntimeException(e);
+            }
+        }
+
+        Convertor convertor=getConvertor(type);
+        if (convertor!=null)
+        {
+            return convertor.fromJSON(map);
+        }
+        return map;
+    }
+
+
+    /**
+     * Register a {@link Convertor} for a class or interface.
+     * @param forClass The class or interface that the convertor applies to
+     * @param convertor the convertor
+     */
+    public void addConvertor(Class forClass, Convertor convertor)
+    {
+        _convertors.put(forClass.getName(),convertor);
+    }
+    
+    /**
+     * Lookup a convertor for a class.
+     * <p>
+     * If no match is found for the class, then the interfaces for the class are tried. If still no
+     * match is found, then the super class and it's interfaces are tried recursively.
+     * @param forClass The class
+     * @return a {@link Convertor} or null if none were found.
+     */
+    protected Convertor getConvertor(Class forClass)
+    {
+        Class cls=forClass;
+        Convertor convertor=(Convertor)_convertors.get(cls.getName());
+        if (convertor==null && this!=__default)
+            convertor=__default.getConvertor(cls);
         
-        while(source.hasNext())
+        while (convertor==null&&cls!=null&&cls!=Object.class)
         {
+            Class[] ifs=cls.getInterfaces();
+            int i=0;
+            while (convertor==null&&ifs!=null&&i<ifs.length)
+                convertor=(Convertor)_convertors.get(ifs[i++].getName());
+            if (convertor==null)
+            {
+                cls=cls.getSuperclass();
+                convertor=(Convertor)_convertors.get(cls.getName());
+            }
+        }
+        return convertor;
+    }
+
+    /**
+     * Register a {@link Convertor} for a named class or interface.
+     * @param name name of a class or an interface that the convertor applies to
+     * @param convertor the convertor
+     */
+    public void addConvertorFor(String name, Convertor convertor)
+    {
+        _convertors.put(name,convertor);
+    }   
+    
+    /**
+     * Lookup a convertor for a named class.
+     *
+     * @param name name of the class
+     * @return a {@link Convertor} or null if none were found.
+     */
+    public Convertor getConvertorFor(String name)
+    {
+        String clsName=name;
+        Convertor convertor=(Convertor)_convertors.get(clsName);
+        if (convertor==null && this!=__default)
+            convertor=__default.getConvertorFor(clsName);
+        return convertor;
+    }   
+
+    public Object parse(Source source, boolean stripOuterComment)
+    {
+        int comment_state=0; // 0=no comment, 1="/", 2="/*", 3="/* *" -1="//"
+        if (!stripOuterComment)
+            return parse(source);
+        
+        int strip_state=1; // 0=no strip, 1=wait for /*, 2= wait for */
+
+        Object o=null;
+        while (source.hasNext())
+        {
             char c=source.peek();
-            
+
             // handle // or /* comment
-            if(comment_state==1)
+            if (comment_state==1)
             {
-                switch(c)
+                switch (c)
                 {
-                    case '/' : 
-                            comment_state=-1;
-                            break;
-                    case '*' : 
+                    case '/':
+                        comment_state=-1;
+                        break;
+                    case '*':
                         comment_state=2;
                         if (strip_state==1)
                         {
@@ -266,14 +630,18 @@
             // handle /* */ comment
             else if (comment_state>1)
             {
-                switch(c)
+                switch (c)
                 {
-                    case '*' : 
+                    case '*':
                         comment_state=3;
                         break;
-                    case '/' : 
+                    case '/':
                         if (comment_state==3)
+                        {
                             comment_state=0;
+                            if (strip_state==2)
+                                return o;
+                        }
                         else
                             comment_state=2;
                         break;
@@ -284,126 +652,223 @@
             // handle // comment
             else if (comment_state<0)
             {
-                switch(c)
+                switch (c)
                 {
-                    case '\r' : 
-                    case '\n' : 
+                    case '\r':
+                    case '\n':
                         comment_state=0;
+                    default:
                         break;
+                }
+            }
+            // handle unknown
+            else
+            {
+                if (!Character.isWhitespace(c))
+                {
+                    if (c=='/')
+                        comment_state=1;
+                    else if (c=='*')
+                        comment_state=3;
+                    else if (o==null)
+                    {
+                        o=parse(source);
+                        continue;
+                    }
+                }
+            }
+            
+            source.next();
+        }
+
+        return o;
+    }
+
+    
+    public Object parse(Source source)
+    {
+        int comment_state=0; // 0=no comment, 1="/", 2="/*", 3="/* *" -1="//"
+
+        while (source.hasNext())
+        {
+            char c=source.peek();
+
+            // handle // or /* comment
+            if (comment_state==1)
+            {
+                switch (c)
+                {
+                    case '/':
+                        comment_state=-1;
+                        break;
+                    case '*':
+                        comment_state=2;
+                }
+            }
+            // handle /* */ comment
+            else if (comment_state>1)
+            {
+                switch (c)
+                {
+                    case '*':
+                        comment_state=3;
+                        break;
+                    case '/':
+                        if (comment_state==3)
+                            comment_state=0;
+                        else
+                            comment_state=2;
+                        break;
                     default:
+                        comment_state=2;
+                }
+            }
+            // handle // comment
+            else if (comment_state<0)
+            {
+                switch (c)
+                {
+                    case '\r':
+                    case '\n':
+                        comment_state=0;
                         break;
+                    default:
+                        break;
                 }
             }
             // handle unknown
             else
             {
-                switch(c)
+                switch (c)
                 {
-                    case '{' : 
+                    case '{':
                         return parseObject(source);
-                    case '[' : 
+                    case '[':
                         return parseArray(source);
-                    case '"' : 
+                    case '"':
                         return parseString(source);
-                    case '-' : 
+                    case '-':
                         return parseNumber(source);
-                        
-                    case 'n' : 
+
+                    case 'n':
                         complete("null",source);
                         return null;
-                    case 't' : 
+                    case 't':
                         complete("true",source);
                         return Boolean.TRUE;
-                    case 'f' : 
+                    case 'f':
                         complete("false",source);
                         return Boolean.FALSE;
-                    case 'u' : 
+                    case 'u':
                         complete("undefined",source);
                         return null;
-                        
-                    case '/' :
+
+                    case '/':
                         comment_state=1;
                         break;
 
-                    case '*' : 
-                        if (strip_state==2)
-                        {
-                            complete("*/",source);
-                            strip_state=0;
-                        }
-                        return null;
-                        
-                    default : 
+                    default:
                         if (Character.isDigit(c))
                             return parseNumber(source);
                         else if (Character.isWhitespace(c))
                             break;
-
-                        throw new IllegalStateException("unknown char "+c);
+                        return handleUnknown(source, c);
                 }
             }
             source.next();
         }
-        
+
         return null;
     }
     
-    private static Map parseObject(Source source)
+    protected Object handleUnknown(Source source, char c)
     {
+        throw new IllegalStateException("unknown char '"+c+"'("+(int)c+") in "+source);
+    }
+
+    protected Object parseObject(Source source)
+    {
         if (source.next()!='{')
             throw new IllegalStateException();
-        Map map = new HashMap();
+        Map map=newMap();
 
-        char next = seekTo("\"}",source);
-        
-        while(source.hasNext())
-        {   
+        char next=seekTo("\"}",source);
+
+        while (source.hasNext())
+        {
             if (next=='}')
             {
                 source.next();
                 break;
             }
-                
+
             String name=parseString(source);
             seekTo(':',source);
             source.next();
-            
-            Object value=parse(source,false);
+
+            Object value=contextFor(name).parse(source);
             map.put(name,value);
-            
+
             seekTo(",}",source);
             next=source.next();
             if (next=='}')
                 break;
             else
-                next = seekTo("\"}",source);
+                next=seekTo("\"}",source);
         }
-     
+
+        String classname=(String)map.get("class");
+        if (classname!=null)
+        {
+            try
+            {
+                Class c=Loader.loadClass(JSON.class,classname);
+                return convertTo(c,map);
+            }
+            catch (ClassNotFoundException e)
+            {
+                e.printStackTrace();
+            }
+        }
         return map;
     }
     
-    private static Object parseArray(Source source)
+
+    protected Object parseArray(Source source)
     {
         if (source.next()!='[')
             throw new IllegalStateException();
 
-        ArrayList list=new ArrayList();
+        int size=0;
+        ArrayList list=null;
+        Object item=null;
         boolean coma=true;
-        
-        while(source.hasNext())
+
+        while (source.hasNext())
         {
             char c=source.peek();
-            switch(c)
+            switch (c)
             {
                 case ']':
                     source.next();
-                    return list.toArray(new Object[list.size()]);
+                    switch(size)
+                    {
+                        case 0:
+                            return newArray(0);
+                        case 1:
+                            Object array = newArray(1);
+                            Array.set(array,0,item);
+                            return array;
+                        default:
+                            return list.toArray(newArray(list.size()));
+                    }
 
                 case ',':
                     if (coma)
                         throw new IllegalStateException();
                     coma=true;
                     source.next();
+                    break;
 
                 default:
                     if (Character.isWhitespace(c))
@@ -411,7 +876,22 @@
                     else
                     {
                         coma=false;
-                        list.add(parse(source,false));
+                        if (size++==0)
+                            item=contextForArray().parse(source);
+                        else if (list==null)
+                        {
+                            list=new ArrayList();
+                            list.add(item);
+                            item=contextForArray().parse(source);
+                            list.add(item);
+                            item=null;
+                        }
+                        else
+                        {
+                            item=contextForArray().parse(source);
+                            list.add(item);
+                            item=null;
+                        }
                     }
             }
 
@@ -420,73 +900,167 @@
         throw new IllegalStateException("unexpected end of array");
     }
     
-    private static String parseString(Source source)
+
+    protected String parseString(Source source)
     {
         if (source.next()!='"')
             throw new IllegalStateException();
+
+        boolean escape=false;
+
+        StringBuffer b=null;
+        final char[] scratch=source.scratchBuffer();
         
-        boolean escape=false;
-        StringBuffer b = new StringBuffer();
-        while(source.hasNext())
+        if (scratch!=null)
         {
-            char c=source.next();
-
-            if (escape)
+            int i=0;
+            while (source.hasNext())
             {
-                escape=false;
-                switch (c)
+                if(i>=scratch.length)
                 {
-                    case 'n':
-                        b.append('\n');
-                        break;
-                    case 'r':
-                        b.append('\r');
-                        break;
-                    case 't':
-                        b.append('\t');
-                        break;
-                    case 'f':
-                        b.append('\f');
-                        break;
-                    case 'b':
-                        b.append('\b');
-                        break;
-                    case 'u':
-                        b.append((char)(
-                                (TypeUtil.convertHexDigit((byte)source.next())<<24)+
-                                (TypeUtil.convertHexDigit((byte)source.next())<<16)+
-                                (TypeUtil.convertHexDigit((byte)source.next())<<8)+
-                                (TypeUtil.convertHexDigit((byte)source.next()))
-                                ) 
-                        );
-                        break;
-                    default:
-                        b.append(c);
+                    // we have filled the scratch buffer, so we must
+                    // use the StringBuffer for a large string
+                    b=new StringBuffer(scratch.length*2);
+                    b.append(scratch,0,i);
+                    break;
                 }
+
+                char c=source.next();
+
+                if (escape)
+                {
+                    escape=false;
+                    switch (c)
+                    {
+                        case '"':
+                            scratch[i++]='"';
+                            break;
+                        case '\\':
+                            scratch[i++]='\\';
+                            break;
+                        case '/':
+                            scratch[i++]='/';
+                            break;
+                        case 'b':
+                            scratch[i++]='\b';
+                            break;
+                        case 'f':
+                            scratch[i++]='\f';
+                            break;
+                        case 'n':
+                            scratch[i++]='\n';
+                            break;
+                        case 'r':
+                            scratch[i++]='\r';
+                            break;
+                        case 't':
+                            scratch[i++]='\t';
+                            break;
+                        case 'u':
+                            char uc=(char)((TypeUtil.convertHexDigit((byte)source.next())<<12)+
+                                    (TypeUtil.convertHexDigit((byte)source.next())<<8)+
+                                    (TypeUtil.convertHexDigit((byte)source.next())<<4)+
+                                    (TypeUtil.convertHexDigit((byte)source.next())));
+                            scratch[i++]=uc;
+                            break;
+                        default:
+                            scratch[i++]=c;
+                    }
+                }
+                else if (c=='\\')
+                {
+                    escape=true;
+                    continue;
+                }
+                else if (c=='\"')
+                {
+                    // Return string that fits within scratch buffer
+                    return toString(scratch,0,i);
+                }
+                else
+                    scratch[i++]=c;
             }
-            else if (c=='\\')
+            
+            // Missing end quote, but return string anyway ?
+            if (b==null)
+                return toString(scratch,0,i);
+        }
+        else
+            b=new StringBuffer(getStringBufferSize());
+        
+        
+        // parse large string into string buffer
+        synchronized (b)
+        {
+            while (source.hasNext())
             {
-                escape=true;
-                continue;
+                char c=source.next();
+
+                if (escape)
+                {
+                    escape=false;
+                    switch (c)
+                    {
+                        case '"':
+                            b.append('"');
+                            break;
+                        case '\\':
+                            b.append('\\');
+                            break;
+                        case '/':
+                            b.append('/');
+                            break;
+                        case 'b':
+                            b.append('\b');
+                            break;
+                        case 'f':
+                            b.append('\f');
+                            break;
+                        case 'n':
+                            b.append('\n');
+                            break;
+                        case 'r':
+                            b.append('\r');
+                            break;
+                        case 't':
+                            b.append('\t');
+                            break;
+                        case 'u':
+                            char uc=(char)((TypeUtil.convertHexDigit((byte)source.next())<<12)+
+                                    (TypeUtil.convertHexDigit((byte)source.next())<<8)+
+                                    (TypeUtil.convertHexDigit((byte)source.next())<<4)+
+                                    (TypeUtil.convertHexDigit((byte)source.next())));
+                            b.append(uc);
+                            break;
+                        default:
+                            b.append(c);
+                    }
+                }
+                else if (c=='\\')
+                {
+                    escape=true;
+                    continue;
+                }
+                else if (c=='\"')
+                    break;
+                else
+                    b.append(c);
             }
-            else if (c=='\"')
-                break;
-            else
-                b.append(c);
+
+            return b.toString();
         }
-            
-        return b.toString();
     }
-    
-    private static Number parseNumber(Source source)
+
+    public Number parseNumber(Source source)
     {
-        int start=source.index();
-        int end=-1;
-        boolean is_double=false;
-        while(source.hasNext()&&end<0)
+        boolean minus=false;
+        long number=0;
+        StringBuffer buffer=null;
+
+        longLoop: while (source.hasNext())
         {
             char c=source.peek();
-            switch(c)
+            switch (c)
             {
                 case '0':
                 case '1':
@@ -498,36 +1072,79 @@
                 case '7':
                 case '8':
                 case '9':
+                    number=number*10+(c-'0');
+                    source.next();
+                    break;
+
                 case '-':
+                case '+':
+                    if (number!=0)
+                        throw new IllegalStateException("bad number");
+                    minus=true;
                     source.next();
                     break;
-                    
+
                 case '.':
                 case 'e':
                 case 'E':
-                    is_double=true;
+                    buffer=new StringBuffer(16);
+                    if(minus) 
+                        buffer.append('-');
+                    buffer.append(number);
+                    buffer.append(c);
                     source.next();
-                    break;
-                    
+                    break longLoop;
+
                 default:
-                    end=source.index();
+                    break longLoop;
             }
         }
-        String s = end>=0?source.from(start,end):source.from(start);
-        if (is_double)
-            return new Double(s);
-        else
-            return new Long(s);
+
+        if (buffer==null)
+            return TypeUtil.newLong(minus?-1*number:number);
+
+        synchronized (buffer)
+        {
+            doubleLoop: while (source.hasNext())
+            {
+                char c=source.peek();
+                switch (c)
+                {
+                    case '0':
+                    case '1':
+                    case '2':
+                    case '3':
+                    case '4':
+                    case '5':
+                    case '6':
+                    case '7':
+                    case '8':
+                    case '9':
+                    case '-':
+                    case '.':
+                    case '+':
+                    case 'e':
+                    case 'E':
+                        buffer.append(c);
+                        source.next();
+                        break;
+
+                    default:
+                        break doubleLoop;
+                }
+            }
+            return new Double(buffer.toString());
+        }
     }
-    
-    private static void seekTo(char seek, Source source)
+
+    protected void seekTo(char seek, Source source)
     {
-        while(source.hasNext())
+        while (source.hasNext())
         {
             char c=source.peek();
             if (c==seek)
                 return;
-            
+
             if (!Character.isWhitespace(c))
                 throw new IllegalStateException("Unexpected '"+c+" while seeking '"+seek+"'");
             source.next();
@@ -535,17 +1152,17 @@
 
         throw new IllegalStateException("Expected '"+seek+"'");
     }
-    
-    private static char seekTo(String seek, Source source)
+
+    protected char seekTo(String seek, Source source)
     {
-        while(source.hasNext())
+        while (source.hasNext())
         {
             char c=source.peek();
-            if(seek.indexOf(c)>=0)
+            if (seek.indexOf(c)>=0)
             {
                 return c;
             }
-            
+
             if (!Character.isWhitespace(c))
                 throw new IllegalStateException("Unexpected '"+c+"' while seeking one of '"+seek+"'");
             source.next();
@@ -553,68 +1170,208 @@
 
         throw new IllegalStateException("Expected one of '"+seek+"'");
     }
-    
-    private static void complete(String seek, Source source)
+
+    protected static void complete(String seek, Source source)
     {
         int i=0;
-        while(source.hasNext()&& i<seek.length())
+        while (source.hasNext()&&i<seek.length())
         {
             char c=source.next();
-            if(c!=seek.charAt(i++))
+            if (c!=seek.charAt(i++))
                 throw new IllegalStateException("Unexpected '"+c+" while seeking  \""+seek+"\"");
         }
 
         if (i<seek.length())
             throw new IllegalStateException("Expected \""+seek+"\"");
     }
+
     
-    
-    private static class Source
+    public interface Source
     {
+        boolean hasNext();
+
+        char next();
+
+        char peek();
+        
+        char[] scratchBuffer();
+    }
+
+    public static class StringSource implements Source
+    {
         private final String string;
         private int index;
-        
-        Source(String s)
+        private char[] scratch;
+
+        public StringSource(String s)
         {
             string=s;
         }
-        
-        boolean hasNext()
+
+        public boolean hasNext()
         {
-            return (index<string.length());
+            if (index<string.length())
+                return true;
+            scratch=null;
+            return false;
         }
-        
-        char next()
+
+        public char next()
         {
             return string.charAt(index++);
         }
-        
-        char peek()
+
+        public char peek()
         {
             return string.charAt(index);
         }
         
-        int index()
+        public String toString()
         {
-            return index;
+            return string.substring(0,index)+"|||"+string.substring(index);
         }
-        
-        String from(int mark)
+
+        public char[] scratchBuffer()
         {
-            return string.substring(mark,index);
+            if (scratch==null)
+                scratch=new char[string.length()];
+            return scratch;
         }
+    }
+
+    public static class ReaderSource implements Source
+    {
+        private Reader _reader;
+        private int _next=-1;
+        private char[] scratch;
+
+        public ReaderSource(Reader r)
+        {
+            _reader=r;
+        }
         
-        String from(int mark,int end)
+        public void setReader(Reader reader)
         {
-            return string.substring(mark,end);
+            _reader=reader;
+            _next=-1;
         }
+
+        public boolean hasNext()
+        {
+            getNext();
+            if (_next<0)
+            {
+                scratch=null;
+                return false;
+            }
+            return true;
+        }
+
+        public char next()
+        {
+            getNext();
+            char c=(char)_next;
+            _next=-1;
+            return c;
+        }
+
+        public char peek()
+        {
+            getNext();
+            return (char)_next;
+        }
+
+        private void getNext()
+        {
+            if (_next<0)
+            {
+                try
+                {
+                    _next=_reader.read();
+                }
+                catch (IOException e)
+                {
+                    throw new RuntimeException(e);
+                }
+            }
+        }
+
+        public char[] scratchBuffer()
+        {
+            if (scratch==null)
+                scratch=new char[1024];
+            return scratch;
+        }
+
     }
-    
+
+    /* ------------------------------------------------------------ */
+    /** 
+     * JSON Output class for use by {@link Convertible}.
+     */
+    public interface Output
+    {
+        public void addClass(Class c);
+
+        public void add(Object obj);
+
+        public void add(String name, Object value);
+
+        public void add(String name, double value);
+
+        public void add(String name, long value);
+
+        public void add(String name, boolean value);
+    }
+
+    /* ------------------------------------------------------------ */
+    /* ------------------------------------------------------------ */
+    /** JSON Convertible object.
+     * Object can implement this interface in a similar way to the 
+     * {@link Externalizable} interface is used to allow classes to
+     * provide their own serialization mechanism.
+     * <p>
+     * A JSON.Convertible object may be written to a JSONObject 
+     * or initialized from a Map of field names to values.
+     * <p>
+     * If the JSON is to be convertible back to an Object, then
+     * the method {@link Output#addClass(Class)} must be called from within toJSON()
+     *
+     */
+    public interface Convertible
+    {
+        public void toJSON(Output out);
+
+        public void fromJSON(Map object);
+    }
+
+    /* ------------------------------------------------------------ */
+    /** Static JSON Convertor.
+     * <p>
+     * may be implemented to provide static convertors for objects that may be registered 
+     * with {@link JSON#registerConvertor(Class, org.mortbay.util.ajax.JSON.Convertor). 
+     * These convertors are looked up by class, interface and
+     * super class by {@link JSON#getConvertor(Class)}.   Convertors should be used when the
+     * classes to be converted cannot implement {@link Convertible} or {@link Generator}.
+     */
+    public interface Convertor
+    {
+        public void toJSON(Object obj, Output out);
+
+        public Object fromJSON(Map object);
+    }
+
+    /* ------------------------------------------------------------ */
+    /** JSON Generator.
+     * A class that can add it's JSON representation directly to a StringBuffer.
+     * This is useful for object instances that are frequently converted and wish to 
+     * avoid multiple Conversions
+     */
     public interface Generator
     {
         public void addJSON(StringBuffer buffer);
     }
-    
+
     /* ------------------------------------------------------------ */
     /** A Literal JSON generator
      * A utility instance of {@link JSON.Generator} that holds a pre-generated string on JSON text.
@@ -622,21 +1379,24 @@
     public static class Literal implements Generator
     {
         private String _json;
+
         /* ------------------------------------------------------------ */
         /** Construct a literal JSON instance for use by {@link JSON#toString(Object)}.
-         * @param json A literal JSON string that will be parsed to check validity.
+         * If {@link Log#isDebugEnabled()} is true, the JSON will be parsed to check validity
+         * @param json A literal JSON string. 
          */
         public Literal(String json)
         {
-            parse(json);
+            if (Log.isDebugEnabled())
+                parse(json);
             _json=json;
         }
-        
+
         public String toString()
         {
             return _json;
         }
-        
+
         public void addJSON(StringBuffer buffer)
         {
             buffer.append(_json);
Index: modules/util/src/main/java/org/mortbay/util/ajax/WaitingContinuation.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/ajax/WaitingContinuation.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/ajax/WaitingContinuation.java	(working copy)
@@ -15,6 +15,8 @@
 
 package org.mortbay.util.ajax;
 
+import org.mortbay.log.Log;
+
 public class WaitingContinuation implements org.mortbay.util.ajax.Continuation
 {
     Object _mutex;
@@ -77,7 +79,7 @@
             }
             catch (InterruptedException e)
             {
-                e.printStackTrace();
+                Log.ignore(e);
             }
             finally
             {
@@ -123,7 +125,7 @@
 
     public void setMutex(Object mutex)
     {
-        if (!_new && _mutex!=this)
+        if (_pending && mutex!=_mutex)
             throw new IllegalStateException();
         _mutex = mutex==null ? this : mutex; 
     }
@@ -138,4 +140,4 @@
             (_resumed?",resumed":"");
         }
     }
-}
\ No newline at end of file
+}
Index: modules/util/src/main/java/org/mortbay/util/StringUtil.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/StringUtil.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/StringUtil.java	(working copy)
@@ -32,26 +32,27 @@
     public static final String __LINE_SEPARATOR=
         System.getProperty("line.separator","\n");
     
-    public static String __ISO_8859_1;
+    public static final String __ISO_8859_1;
     static
     {
         String iso=System.getProperty("ISO_8859_1");
-        if (iso!=null)
-            __ISO_8859_1=iso;
-        else
+        if (iso==null)
         {
             try{
                 new String(new byte[]{(byte)20},"ISO-8859-1");
-                __ISO_8859_1="ISO-8859-1";
+                iso="ISO-8859-1";
             }
             catch(java.io.UnsupportedEncodingException e)
             {
-                __ISO_8859_1="ISO8859_1";
+                iso="ISO8859_1";
             }        
         }
+        __ISO_8859_1=iso;
     }
     
     public final static String __UTF8="UTF-8";
+    public final static String __UTF8Alt="UTF8";
+    public final static String __UTF16="UTF-16";
     
     
     private static char[] lowercases = {
@@ -337,7 +338,7 @@
     /* ------------------------------------------------------------ */
     public static boolean isUTF8(String charset)
     {
-        return charset==__UTF8 || __UTF8.equalsIgnoreCase(charset);
+        return charset==__UTF8||__UTF8.equalsIgnoreCase(charset)||__UTF8Alt.equalsIgnoreCase(charset);
     }
 
 
Index: modules/util/src/main/java/org/mortbay/util/IO.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/IO.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/IO.java	(working copy)
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.PrintWriter;
 import java.io.Reader;
 import java.io.Writer;
 import java.io.StringWriter;
@@ -234,6 +235,17 @@
                 out.write(buffer,0,len);
             }
         }
+        else if (out instanceof PrintWriter)
+        {
+            PrintWriter pout=(PrintWriter)out;
+            while (!pout.checkError())
+            {
+                len=in.read(buffer,0,bufferSize);
+                if (len==-1)
+                    break;
+                out.write(buffer,0,len);
+            }
+        }
         else
         {
             while (true)
Index: modules/util/src/main/java/org/mortbay/util/Utf8StringBuffer.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/Utf8StringBuffer.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/Utf8StringBuffer.java	(working copy)
@@ -34,12 +34,12 @@
     int _bits;
     boolean _errors;
     
-    Utf8StringBuffer()
+    public Utf8StringBuffer()
     {
         _buffer=new StringBuffer();
     }
     
-    Utf8StringBuffer(int capacity)
+    public Utf8StringBuffer(int capacity)
     {
         _buffer=new StringBuffer(capacity);
     }
@@ -53,7 +53,7 @@
     
     public void append(byte b)
     {
-        if (b>0)
+        if (b>=0)
         {
             if (_more>0)
             {
Index: modules/util/src/main/java/org/mortbay/util/MultiPartOutputStream.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/MultiPartOutputStream.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/MultiPartOutputStream.java	(working copy)
@@ -52,24 +52,18 @@
     
     /* ------------------------------------------------------------ */
     public MultiPartOutputStream(OutputStream out)
-         throws IOException
+    throws IOException
     {
         super(out);
-        try
-        {
-            boundary = "jetty"+System.identityHashCode(this)+
-                Long.toString(System.currentTimeMillis(),36);
-            boundaryBytes=boundary.getBytes(StringUtil.__ISO_8859_1);
-        }
-        catch (Exception e)
-        {
-            e.printStackTrace(); System.exit(1);
-        }
-        
+
+        boundary = "jetty"+System.identityHashCode(this)+
+        Long.toString(System.currentTimeMillis(),36);
+        boundaryBytes=boundary.getBytes(StringUtil.__ISO_8859_1);
+
         inPart=false;
     }
+
     
-    
 
     /* ------------------------------------------------------------ */
     /** End the current part.
Index: modules/util/src/main/java/org/mortbay/util/TypeUtil.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/TypeUtil.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/TypeUtil.java	(working copy)
@@ -166,6 +166,10 @@
     private static Integer[] integerCache = new Integer[intCacheSize];
     private static String[] integerStrCache = new String[intCacheSize];
     private static Integer minusOne = new Integer(-1);
+    private static int longCacheSize=
+        Integer.getInteger("org.mortbay.util.TypeUtil.LongCacheSize",64).intValue();
+    private static Long[] longCache = new Long[longCacheSize];
+    private static Long minusOneL = new Long(-1);
     
     /* ------------------------------------------------------------ */
     /** Class from a canonical name for a type.
@@ -258,6 +262,22 @@
             return minusOne;
         return new Integer(i);
     }
+    
+    /* ------------------------------------------------------------ */
+    /** Convert int to Integer using cache. 
+     */
+    public static Long newLong(long i)
+    {
+        if (i>=0 && i<longCacheSize)
+        {
+            if (longCache[(int)i]==null)
+                longCache[(int)i]=new Long(i);
+            return longCache[(int)i];
+        }
+        else if (i==-1)
+            return minusOneL;
+        return new Long(i);
+    }
 
     
     /* ------------------------------------------------------------ */
Index: modules/util/src/main/java/org/mortbay/util/QuotedStringTokenizer.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/QuotedStringTokenizer.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/QuotedStringTokenizer.java	(working copy)
@@ -316,46 +316,104 @@
         synchronized(buf)
         {
             buf.append('"');
-            for (int i=0;i<s.length();i++)
+            char[] chars = null;
+            int i=0;
+            loop:
+            for (;i<s.length();i++)
             {
                 char c = s.charAt(i);
                 switch(c)
                 {
                     case '"':
+                        chars = s.toCharArray();
+                        buf.append(chars,0,i);
                         buf.append("\\\"");
-                        continue;
+                        break loop;
                     case '\\':
+                        chars = s.toCharArray();
+                        buf.append(chars,0,i);
                         buf.append("\\\\");
-                        continue;
+                        break loop;
                     case '\n':
+                        chars = s.toCharArray();
+                        buf.append(chars,0,i);
                         buf.append("\\n");
-                        continue;
+                        break loop;
                     case '\r':
+                        chars = s.toCharArray();
+                        buf.append(chars,0,i);
                         buf.append("\\r");
-                        continue;
+                        break loop;
                     case '\t':
+                        chars = s.toCharArray();
+                        buf.append(chars,0,i);
                         buf.append("\\t");
-                        continue;
+                        break loop;
                     case '\f':
+                        chars = s.toCharArray();
+                        buf.append(chars,0,i);
                         buf.append("\\f");
-                        continue;
+                        break loop;
                     case '\b':
+                        chars = s.toCharArray();
+                        buf.append(chars,0,i);
                         buf.append("\\b");
-                        continue;
+                        break loop;
                         
                     default:
-                        buf.append(c);
                         continue;
                 }
             }
+            if (chars==null)
+                buf.append(s);
+            else
+            {
+                i++;
+                for (;i<s.length();i++)
+                {
+                    char c = s.charAt(i);
+                    switch(c)
+                    {
+                        case '"':
+                            buf.append("\\\"");
+                            continue;
+                        case '\\':
+                            buf.append("\\\\");
+                            continue;
+                        case '\n':
+                            buf.append("\\n");
+                            continue;
+                        case '\r':
+                            buf.append("\\r");
+                            continue;
+                        case '\t':
+                            buf.append("\\t");
+                            continue;
+                        case '\f':
+                            buf.append("\\f");
+                            continue;
+                        case '\b':
+                            buf.append("\\b");
+                            continue;
+
+                        default:
+                            buf.append(c);
+                        continue;
+                    }
+                }
+            }
+            
             buf.append('"');
-        } 
+        }     
     }
 
     
     /* ------------------------------------------------------------ */
     /** Quote a string into a StringBuffer.
-     * The characters ", \, \n, \r, \t, \f and \b are escaped
+     * The characters ", \, \n, \r, \t, \f, \b are escaped.
+     * Quotes are forced if any escaped characters are present or there
+     * is a ", ', space, +, =, ; or % character.
+     * 
      * @param buf The StringBuffer
      * @param s The String to quote.
      */
@@ -377,7 +435,11 @@
                     case '\t':
                     case '\f':
                     case '\b':
+                    case '%':
+                    case '+':
                     case ' ':
+                    case ';':
+                    case '=':
                         e=i;
                         buf.append('"');
                         // TODO when 1.4 support is dropped: buf.append(s,0,e);
Index: modules/util/src/main/java/org/mortbay/util/UrlEncoded.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/UrlEncoded.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/UrlEncoded.java	(working copy)
@@ -16,6 +16,8 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
 import java.util.Iterator;
 import java.util.Map;
@@ -240,9 +242,17 @@
      */
     public static void decodeUtf8To(byte[] raw,int offset, int length, MultiMap map)
     {
+        decodeUtf8To(raw,offset,length,map,new Utf8StringBuffer());
+    }
+
+    /* -------------------------------------------------------------- */
+    /** Decoded parameters to Map.
+     * @param data the byte[] containing the encoded parameters
+     */
+    public static void decodeUtf8To(byte[] raw,int offset, int length, MultiMap map,Utf8StringBuffer buffer)
+    {
         synchronized(map)
         {
-            Utf8StringBuffer buffer = new Utf8StringBuffer();
             String key = null;
             String value = null;
             
@@ -304,6 +314,86 @@
             }
         }
     }
+
+    /* -------------------------------------------------------------- */
+    /** Decoded parameters to Map.
+     * @param in InputSteam to read
+     * @param map MultiMap to add parameters to
+     * @param maxLength maximum length of content to read 0r -1 for no limit
+     */
+    public static void decode88591To(InputStream in, MultiMap map, int maxLength)
+    throws IOException
+    {
+        synchronized(map)
+        {
+            StringBuffer buffer = new StringBuffer();
+            String key = null;
+            String value = null;
+            
+            int b;
+
+            // TODO cache of parameter names ???
+            int totalLength=0;
+            while ((b=in.read())>=0)
+            {
+                switch ((char) b)
+                {
+                    case '&':
+                        value = buffer.length()==0?"":buffer.toString();
+                        buffer.setLength(0);
+                        if (key != null)
+                        {
+                            map.add(key,value);
+                        }
+                        else if (value!=null&&value.length()>0)
+                        {
+                            map.add(value,"");
+                        }
+                        key = null;
+                        value=null;
+                        break;
+                        
+                    case '=':
+                        if (key!=null)
+                        {
+                            buffer.append((char)b);
+                            break;
+                        }
+                        key = buffer.toString();
+                        buffer.setLength(0);
+                        break;
+                        
+                    case '+':
+                        buffer.append((char)' ');
+                        break;
+                        
+                    case '%':
+                        int dh=in.read();
+                        int dl=in.read();
+                        if (dh<0||dl<0)
+                            break;
+                        buffer.append((char)((TypeUtil.convertHexDigit((byte)dh)<<4) + TypeUtil.convertHexDigit((byte)dl)));
+                        break;
+                    default:
+                        buffer.append((char)b);
+                    break;
+                }
+                if (maxLength>=0 && (++totalLength > maxLength))
+                    throw new IllegalStateException("Form too large");
+            }
+            
+            if (key != null)
+            {
+                value = buffer.length()==0?"":buffer.toString();
+                buffer.setLength(0);
+                map.add(key,value);
+            }
+            else if (buffer.length()>0)
+            {
+                map.add(buffer.toString(), "");
+            }
+        }
+    }
     
     /* -------------------------------------------------------------- */
     /** Decoded parameters to Map.
@@ -386,21 +476,49 @@
     }
     
     /* -------------------------------------------------------------- */
+    public static void decodeUtf16To(InputStream in, MultiMap map, int maxLength) throws IOException
+    {
+        InputStreamReader input = new InputStreamReader(in,StringUtil.__UTF16);
+        StringBuffer buf = new StringBuffer();
+
+        int c;
+        int length=0;
+        if (maxLength<0)
+            maxLength=Integer.MAX_VALUE;
+        while ((c=input.read())>0 && length++<maxLength)
+            buf.append((char)c);
+        decodeTo(buf.toString(),map,StringUtil.__UTF8);
+    }
+    
+    /* -------------------------------------------------------------- */
     /** Decoded parameters to Map.
      * @param in the stream containing the encoded parameters
      */
     public static void decodeTo(InputStream in, MultiMap map, String charset, int maxLength)
     throws IOException
     {
+
         if (charset==null || StringUtil.__UTF8.equalsIgnoreCase(charset))
         {
             decodeUtf8To(in,map,maxLength);
             return;
         }
         
+        if (StringUtil.__ISO_8859_1.equals(charset))
+        {
+            decode88591To(in,map,maxLength);
+            return;
+        }
+
+        if (StringUtil.__UTF16.equalsIgnoreCase(charset)) // Should be all 2 byte encodings
+        {
+            decodeUtf16To(in,map,maxLength);
+            return;
+        }
+        
+
         synchronized(map)
         {
-            ByteArrayOutputStream2 buf=new ByteArrayOutputStream2(256);
             String key = null;
             String value = null;
             
@@ -408,79 +526,76 @@
             int digit=0;
             int digits=0;
             
-            // TODO cache of parameter names ???
-            byte[] bytes=new byte[256]; // TODO Configure ?? size??? tune??? // reuse???
-            int l=-1;
             int totalLength = 0;
-            while ((l=in.read(bytes))>=0)
+            ByteArrayOutputStream2 output = new ByteArrayOutputStream2();
+            
+            int size=0;
+            
+            while ((c=in.read())>0)
             {
-                for (int i=0;i<l;i++)
+                switch ((char) c)
                 {
-                    c=bytes[i];
-                    switch ((char) c)
-                    {
-                        case '&':
-                            value = buf.size()==0?"":new String(buf.getBuf(), 0, buf.size(), charset);
-                            buf.reset();
-                            if (key != null)
-                            {
-                                map.add(key,value);
-                            }
-                            else if (value!=null&&value.length()>0)
-                            {
-                                map.add(value,"");
-                            }
-                            key = null;
-                            value=null;
+                    case '&':
+                        size=output.size();
+                        value = size==0?"":output.toString(charset);
+                        output.setCount(0);
+                        if (key != null)
+                        {
+                            map.add(key,value);
+                        }
+                        else if (value!=null&&value.length()>0)
+                        {
+                            map.add(value,"");
+                        }
+                        key = null;
+                        value=null;
+                        break;
+                    case '=':
+                        if (key!=null)
+                        {
+                            output.write(c);
                             break;
-                        case '=':
-                            if (key!=null)
-                            {
-                                buf.write(c);
-                                break;
-                            }
-                            key = new String(buf.getBuf(), 0, buf.size(), charset);
-                            buf.reset();
-                            break;
-                        case '+':
-                            buf.write(' ');
-                            break;
-                        case '%':
-                            digits=2;
-                            break;
-                        default:
-                            if (digits==2)
-                            {
-                                digit=TypeUtil.convertHexDigit((byte)c);
-                                digits=1;
-                            }
-                            else if (digits==1)
-                            {
-                                buf.write((digit<<4) + TypeUtil.convertHexDigit((byte)c));
-                                digits=0;
-                            }
-                            else
-                                buf.write(c);
+                        }
+                        size=output.size();
+                        key = size==0?"":output.toString(charset);
+                        output.setCount(0);
                         break;
-                    }
+                    case '+':
+                        output.write(' ');
+                        break;
+                    case '%':
+                        digits=2;
+                        break;
+                    default:
+                        if (digits==2)
+                        {
+                            digit=TypeUtil.convertHexDigit((byte)c);
+                            digits=1;
+                        }
+                        else if (digits==1)
+                        {
+                            output.write((digit<<4) + TypeUtil.convertHexDigit((byte)c));
+                            digits=0;
+                        }
+                        else
+                            output.write(c);
+                    break;
                 }
                 
-                totalLength += l;
+                totalLength++;
                 if (maxLength>=0 && totalLength > maxLength)
                     throw new IllegalStateException("Form too large");
             }
-            
+
+            size=output.size();
             if (key != null)
             {
-                value = buf.size()==0?"":new String(buf.getBuf(), 0, buf.size(), charset);
-                buf.reset();
+                value = size==0?"":output.toString(charset);
+                output.setCount(0);
                 map.add(key,value);
             }
-            else if (buf.size()>0)
-            {
-                map.add(new String(buf.getBuf(), 0, buf.size(), charset),"");
-            }
-
+            else if (size>0)
+                map.add(output.toString(charset),"");
         }
     }
     
@@ -491,76 +606,176 @@
      */
     public static String decodeString(String encoded,int offset,int length,String charset)
     {
-        if (charset==null)
-            charset=StringUtil.__UTF8;
-        byte[] bytes=null;
-        int n=0;
-        
-        for (int i=0;i<length;i++)
+        if (charset==null || StringUtil.isUTF8(charset))
         {
-            char c = encoded.charAt(offset+i);
-            if (c<0||c>0xff)
-                throw new IllegalArgumentException("Not encoded");
-            
-            if (c=='+')
+            Utf8StringBuffer buffer=null;
+
+            for (int i=0;i<length;i++)
             {
-                if (bytes==null)
+                char c = encoded.charAt(offset+i);
+                if (c<0||c>0xff)
                 {
-                    bytes=new byte[length*2];
-                    encoded.getBytes(offset, offset+i, bytes, 0);
-                    n=i;
+                    if (buffer==null)
+                    {
+                        buffer=new Utf8StringBuffer(length);
+                        buffer.getStringBuffer().append(encoded.substring(offset,offset+i+1));
+                    }
+                    else
+                        buffer.getStringBuffer().append(c);
                 }
-                bytes[n++] = (byte) ' ';
+                else if (c=='+')
+                {
+                    if (buffer==null)
+                    {
+                        buffer=new Utf8StringBuffer(length);
+                        buffer.getStringBuffer().append(encoded.substring(offset,offset+i));
+                    }
+                    
+                    buffer.getStringBuffer().append(' ');
+                }
+                else if (c=='%' && (i+2)<length)
+                {
+                    if (buffer==null)
+                    {
+                        buffer=new Utf8StringBuffer(length);
+                        buffer.getStringBuffer().append(encoded.substring(offset,offset+i));
+                    }
+
+                    while(c=='%' && (i+2)<length)
+                    {
+                        try
+                        {
+                            byte b=(byte)TypeUtil.parseInt(encoded,offset+i+1,2,16);
+                            buffer.append(b);
+                            i+=3;
+                        }
+                        catch(NumberFormatException nfe)
+                        {
+                            buffer.getStringBuffer().append('%');
+                            for(char next; ((next=encoded.charAt(++i+offset))!='%');)
+                                buffer.getStringBuffer().append((next=='+' ? ' ' : next));
+                        }
+
+                        if (i<length)
+                            c = encoded.charAt(offset+i);
+                    }
+                    i--;
+                }
+                else if (buffer!=null)
+                    buffer.getStringBuffer().append(c);
             }
-            else if (c=='%' && (i+2)<length)
+
+            if (buffer==null)
             {
-                byte b;
-                char cn = encoded.charAt(offset+i+1);
-                if (cn>='a' && cn<='z')
-                    b=(byte)(10+cn-'a');
-                else if (cn>='A' && cn<='Z')
-                    b=(byte)(10+cn-'A');
-                else
-                    b=(byte)(cn-'0');
-                cn = encoded.charAt(offset+i+2);
-                if (cn>='a' && cn<='z')
-                    b=(byte)(b*16+10+cn-'a');
-                else if (cn>='A' && cn<='Z')
-                    b=(byte)(b*16+10+cn-'A');
-                else
-                    b=(byte)(b*16+cn-'0');
+                if (offset==0 && encoded.length()==length)
+                    return encoded;
+                return encoded.substring(offset,offset+length);
+            }
 
-                if (bytes==null)
+            return buffer.toString();
+        }
+        else
+        {
+            StringBuffer buffer=null;
+
+            try
+            {
+                for (int i=0;i<length;i++)
                 {
-                    bytes=new byte[length];
-                    encoded.getBytes(offset, offset+i, bytes, 0);
-                    n=i;
+                    char c = encoded.charAt(offset+i);
+                    if (c<0||c>0xff)
+                    {
+                        if (buffer==null)
+                        {
+                            buffer=new StringBuffer(length);
+                            buffer.append(encoded.substring(offset,offset+i+1));
+                        }
+                        else
+                            buffer.append(c);
+                    }
+                    else if (c=='+')
+                    {
+                        if (buffer==null)
+                        {
+                            buffer=new StringBuffer(length);
+                            buffer.append(encoded.substring(offset,offset+i));
+                        }
+                        
+                        buffer.append(' ');
+                    }
+                    else if (c=='%' && (i+2)<length)
+                    {
+                        if (buffer==null)
+                        {
+                            buffer=new StringBuffer(length);
+                            buffer.append(encoded.substring(offset,offset+i));
+                        }
+
+                        byte[] ba=new byte[length];
+                        int n=0;
+                        while(c>=0 && c<=0xff)
+                        {
+                            if (c=='%')
+                            {   
+                                if(i+2<length)
+                                {
+                                    try
+                                    {
+                                        ba[n++]=(byte)TypeUtil.parseInt(encoded,offset+i+1,2,16);
+                                        i+=3;
+                                    }
+                                    catch(NumberFormatException nfe)
+                                    {                                        
+                                        ba[n-1] = (byte)'%';                                    
+                                        for(char next; ((next=encoded.charAt(++i+offset))!='%');)
+                                            ba[n++] = (byte)(next=='+' ? ' ' : next);
+                                    }
+                                }
+                                else
+                                {
+                                    ba[n++] = (byte)'%';
+                                    i++;
+                                }
+                            }
+                            else if (c=='+')
+                            {
+                                ba[n++]=(byte)' ';
+                                i++;
+                            }
+                            else
+                            {
+                                ba[n++]=(byte)c;
+                                i++;
+                            }
+                            
+                            if (i>=length)
+                                break;
+                            c = encoded.charAt(offset+i);
+                        }
+
+                        i--;
+                        buffer.append(new String(ba,0,n,charset));
+
+                    }
+                    else if (buffer!=null)
+                        buffer.append(c);
                 }
-                i+=2;
-                bytes[n++]=b;
+
+                if (buffer==null)
+                {
+                    if (offset==0 && encoded.length()==length)
+                        return encoded;
+                    return encoded.substring(offset,offset+length);
+                }
+
+                return buffer.toString();
             }
-            else if (n>0)
-                bytes[n++] = (byte) c;
+            catch (UnsupportedEncodingException e)
+            {
+                throw new RuntimeException(e);
+            }
         }
-
-        if (bytes==null)
-        {
-            if (offset==0 && encoded.length()==length)
-                return encoded;
-            return encoded.substring(offset,offset+length);
-        }
         
-        try
-        {
-            return new String(bytes,0,n,charset);
-        }
-        catch (UnsupportedEncodingException e)
-        {
-            Log.warn(e.toString());
-            Log.debug(e);
-            return new String(bytes,0,n);
-        }
-        
     }
     
     /* ------------------------------------------------------------ */
Index: modules/util/src/main/java/org/mortbay/util/Scanner.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/Scanner.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/Scanner.java	(working copy)
@@ -21,7 +21,6 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -45,17 +44,18 @@
 public class Scanner
 {
     private int _scanInterval;
-
-    
     private List _listeners = Collections.synchronizedList(new ArrayList());
-    private Map _prevScan = Collections.EMPTY_MAP;
+    private Map _prevScan = new HashMap();
+    private Map _currentScan = new HashMap();
     private FilenameFilter _filter;
     private List _scanDirs;
     private volatile boolean _running = false;
     private boolean _reportExisting = true;
     private Timer _timer;
     private TimerTask _task;
+    private boolean _recursive=true;
 
+
     /**
      * Listener
      * 
@@ -102,13 +102,8 @@
      */
     public synchronized void setScanInterval(int scanInterval)
     {
-        if (_running)
-            _task.cancel();
-        
         this._scanInterval = scanInterval;
-        
-        if (_running && _scanInterval >0)
-            _timer.scheduleAtFixedRate(_task,1000L*getScanInterval(),1000L*getScanInterval());
+        schedule();
     }
 
     /**
@@ -142,6 +137,15 @@
         return _scanDirs;
     }
     
+    public void setRecursive (boolean recursive)
+    {
+        _recursive=recursive;
+    }
+    
+    public boolean getRecursive ()
+    {
+        return _recursive;
+    }
     /**
      * Apply a filter to files found in the scan directory.
      * Only files matching the filter will be reported as added/changed/removed.
@@ -180,7 +184,6 @@
     {
         if (listener == null)
             return;
-
         _listeners.add(listener);   
     }
 
@@ -216,21 +219,41 @@
         else
         {
             //just register the list of existing files and only report changes
-            _prevScan = scanFiles();
+            scanFiles();
+            _prevScan.putAll(_currentScan);
         }
+        schedule();
+    }
 
-        _timer = new Timer();
-        _task = new TimerTask()
+    public TimerTask newTimerTask ()
+    {
+        return new TimerTask()
         {
             public void run() { scan(); }
         };
+    }
 
-        if (getScanInterval()>0)
-            _timer.scheduleAtFixedRate(_task,1000L*getScanInterval(),1000L*getScanInterval());
-        
+    public Timer newTimer ()
+    {
+        return new Timer(true);
     }
-
-
+    
+    public void schedule ()
+    {  
+        if (_running)
+        {
+            if (_timer!=null)
+                _timer.cancel();
+            if (_task!=null)
+                _task.cancel();
+            if (getScanInterval() > 0)
+            {
+                _timer = newTimer();
+                _task = newTimerTask();
+                _timer.schedule(_task, 1000L*getScanInterval(),1000L*getScanInterval());
+            }
+        }
+    }
     /**
      * Stop the scanning.
      */
@@ -239,7 +262,10 @@
         if (_running)
         {
             _running = false; 
-            _task.cancel();
+            if (_timer!=null)
+                _timer.cancel();
+            if (_task!=null)
+                _task.cancel();
             _task=null;
             _timer=null;
         }
@@ -250,31 +276,30 @@
      */
     public void scan ()
     {
-        Map currentScan = scanFiles();
-        reportDifferences(currentScan, _prevScan);
-        _prevScan = currentScan;     
+        scanFiles();
+        reportDifferences(_currentScan, _prevScan);
+        _prevScan.clear();
+        _prevScan.putAll(_currentScan);
     }
 
     /**
      * Recursively scan all files in the designated directories.
      * @return Map of name of file to last modified time
      */
-    public Map scanFiles ()
+    public void scanFiles ()
     {
         if (_scanDirs==null)
-            return Collections.EMPTY_MAP;
+            return;
         
-        HashMap scanInfo = new HashMap();
+        _currentScan.clear();
         Iterator itor = _scanDirs.iterator();
         while (itor.hasNext())
         {
             File dir = (File)itor.next();
             
             if ((dir != null) && (dir.exists()))
-                scanFile(dir, scanInfo);
+                scanFile(dir, _currentScan);
         }
-        
-        return scanInfo;
     }
 
 
@@ -350,7 +375,7 @@
                     scanInfoMap.put(name, new Long(lastModified));
                 }
             }
-            else if (f.isDirectory())
+            else if (f.isDirectory() && (_recursive || _scanDirs.contains(f)))
             {
                 File[] files = f.listFiles();
                 for (int i=0;i<files.length;i++)
@@ -363,6 +388,11 @@
         }
     }
 
+    private void warn(Object listener,String filename,Throwable th)
+    {
+        Log.warn(th);
+        Log.warn(listener+" failed on '"+filename);
+    }
 
     /**
      * Report a file addition to the registered FileAddedListeners
@@ -373,19 +403,19 @@
         Iterator itor = _listeners.iterator();
         while (itor.hasNext())
         {
+            Object l = itor.next();
             try
             {
-                Object l = itor.next();
                 if (l instanceof DiscreteListener)
                     ((DiscreteListener)l).fileAdded(filename);
             }
             catch (Exception e)
             {
-                Log.warn(e);
+                warn(l,filename,e);
             }
             catch (Error e)
             {
-                Log.warn(e);
+                warn(l,filename,e);
             }
         }
     }
@@ -400,19 +430,19 @@
         Iterator itor = _listeners.iterator();
         while (itor.hasNext())
         {
+            Object l = itor.next();
             try
             {
-                Object l = itor.next();
                 if (l instanceof DiscreteListener)
                     ((DiscreteListener)l).fileRemoved(filename);
             }
             catch (Exception e)
             {
-                Log.warn(e);
+                warn(l,filename,e);
             }
             catch (Error e)
             {
-                Log.warn(e);
+                warn(l,filename,e);
             }
         }
     }
@@ -427,19 +457,19 @@
         Iterator itor = _listeners.iterator();
         while (itor.hasNext())
         {
+            Object l = itor.next();
             try
             {
-                Object l = itor.next();
                 if (l instanceof DiscreteListener)
                     ((DiscreteListener)l).fileChanged(filename);
             }
             catch (Exception e)
             {
-                Log.warn(e);
+                warn(l,filename,e);
             }
             catch (Error e)
             {
-                Log.warn(e);
+                warn(l,filename,e);
             }
         }
     }
@@ -449,19 +479,19 @@
         Iterator itor = _listeners.iterator();
         while (itor.hasNext())
         {
+            Object l = itor.next();
             try
             {
-                Object l = itor.next();
                 if (l instanceof BulkListener)
                     ((BulkListener)l).filesChanged(filenames);
             }
             catch (Exception e)
             {
-                Log.warn(e);
+                warn(l,filenames.toString(),e);
             }
             catch (Error e)
             {
-                Log.warn(e);
+                warn(l,filenames.toString(),e);
             }
         }
     }
Index: modules/util/src/main/java/org/mortbay/util/URIUtil.java
===================================================================
--- modules/util/src/main/java/org/mortbay/util/URIUtil.java	(revision 5689)
+++ modules/util/src/main/java/org/mortbay/util/URIUtil.java	(working copy)
@@ -76,13 +76,17 @@
                 char c=path.charAt(i);
                 switch(c)
                 {
-                  case '%':
-                  case '?':
-                  case ';':
-                  case '#':
-                  case ' ':
-                      buf=new StringBuffer(path.length()<<1);
-                      break loop;
+                    case '%':
+                    case '?':
+                    case ';':
+                    case '#':
+                    case '\'':
+                    case '"':
+                    case '<':
+                    case '>':
+                    case ' ':
+                        buf=new StringBuffer(path.length()<<1);
+                        break loop;
                 }
             }
             if (buf==null)
@@ -108,6 +112,18 @@
                   case '#':
                       buf.append("%23");
                       continue;
+                  case '"':
+                      buf.append("%22");
+                      continue;
+                  case '\'':
+                      buf.append("%27");
+                      continue;
+                  case '<':
+                      buf.append("%3C");
+                      continue;
+                  case '>':
+                      buf.append("%3E");
+                      continue;
                   case ' ':
                       buf.append("%20");
                       continue;
@@ -278,19 +294,10 @@
             
             bytes[n++]=b;
         }
-        
-        try
-        {
-            if (bytes==null)
-                return new String(buf,offset,length,__CHARSET);
-            return new String(bytes,0,n,__CHARSET);
-        }
-        catch(UnsupportedEncodingException e)
-        {
-            if (bytes==null)
-                return new String(buf,offset,length);
-            return new String(bytes,0,n);
-        }
+
+        if (bytes==null)
+            return StringUtil.toString(buf,offset,length,__CHARSET);
+        return StringUtil.toString(bytes,0,n,__CHARSET);
     }
 
     
@@ -298,8 +305,8 @@
     /** Add two URI path segments.
      * Handles null and empty paths, path and query params (eg ?a=b or
      * ;JSESSIONID=xxx) and avoids duplicate '/'
-     * @param p1 URI path segment 
-     * @param p2 URI path segment
+     * @param p1 URI path segment (should be encoded)
+     * @param p2 URI path segment (should be encoded)
      * @return Legally combined path segments.
      */
     public static String addPaths(String p1, String p2)
@@ -549,7 +556,8 @@
             return path;
         
         StringBuffer buf = new StringBuffer(path.length());
-        buf.append(path,0,i);
+        char[] chars = path.toCharArray();
+        buf.append(chars,0,i);
         
         loop2:
         while (i<end)
@@ -558,7 +566,7 @@
             switch(c)
             {
                 case '?':
-                    buf.append(path,i,end);
+                    buf.append(chars,i,end-i);
                     break loop2;
                 case '/':
                     if (state++==0)
Index: modules/util/pom.xml
===================================================================
--- modules/util/pom.xml	(revision 5689)
+++ modules/util/pom.xml	(working copy)
@@ -9,20 +9,8 @@
   <groupId>org.mortbay.jetty</groupId>
   <artifactId>jetty-util</artifactId>
   <name>Jetty Utilities</name>
-  <url>http://jetty.mortbay.org</url>
   <description>Utility classes for Jetty</description>
   <build>
-    <defaultGoal>install</defaultGoal>
-    <resources>
-      <resource>
-        <directory>src/main/java</directory>
-        <includes>
-          <include>org/mortbay/**/*.properties</include>
-          <include>org/mortbay/**/*.dtd</include>
-          <include>org/mortbay/**/*.xml</include>
-        </includes>
-      </resource>
-    </resources>
     <testResources>
       <testResource>
         <directory>src/test/java</directory>
@@ -48,6 +36,7 @@
             <configuration>
               <tasks>
                 <delete failonerror="false" file="../../lib/${project.artifactId}-${project.version}.${project.packaging}" />
+                <delete failonerror="false" file="../../etc/jetty-logging.xml" />
               </tasks>
             </configuration>
           </execution>
@@ -60,42 +49,12 @@
             <configuration>
               <tasks>
                 <copy failonerror="false" file="target/${project.artifactId}-${project.version}.${project.packaging}" todir="../../lib/" />
+                <copy failonerror="false" file="src/main/config/etc/jetty-logging.xml" todir="../../etc" />
               </tasks>
             </configuration>
           </execution>
         </executions>
       </plugin>
-      <plugin>
-        <groupId>org.apache.felix</groupId>
-        <artifactId>maven-bundle-plugin</artifactId>
-        <version>1.4.2</version>
-        <extensions>true</extensions>
-        <executions>
-          <execution>
-            <goals>
-              <goal>manifest</goal>
-            </goals>
-            <configuration>
-              <instructions>
-                <Bundle-SymbolicName>org.mortbay.jetty.util</Bundle-SymbolicName>
-                <Bundle-RequiredExcutionEnvironment>J2SE-1.4</Bundle-RequiredExcutionEnvironment>
-                <Import-Package>!org.mortbay.*,*</Import-Package>
-                <Bundle-DocURL>http://jetty.mortbay.org</Bundle-DocURL>
-              </instructions>
-            </configuration>
-           </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>2.1</version>
-        <configuration>
-          <archive>
-            <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
-          </archive>
-        </configuration>
-      </plugin>
     </plugins>
   </build>
   <dependencies>
@@ -106,9 +65,14 @@
     </dependency>
     <dependency>
       <groupId>org.mortbay.jetty</groupId>
-      <artifactId>servlet-api-2.5</artifactId>
-      <version>${project.version}</version>
+      <artifactId>servlet-api</artifactId>
+      <version>${servlet-version}</version>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-api</artifactId>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
 </project>
Index: etc/keystore
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: etc/jetty.xml
===================================================================
--- etc/jetty.xml	(revision 5689)
+++ etc/jetty.xml	(working copy)
@@ -16,18 +16,18 @@
     <!-- Server Thread Pool                                          -->
     <!-- =========================================================== -->
     <Set name="ThreadPool">
-      <!-- Default bounded blocking threadpool 
-      -->
-      <New class="org.mortbay.thread.BoundedThreadPool">
+
+      <New class="org.mortbay.thread.QueuedThreadPool">
         <Set name="minThreads">10</Set>
-        <Set name="maxThreads">250</Set>
-        <Set name="lowThreads">25</Set>
+        <Set name="maxThreads">200</Set>
+        <Set name="lowThreads">20</Set>
+        <Set name="SpawnOrShrinkAt">2</Set>
       </New>
 
       <!-- Optional Java 5 bounded threadpool with job queue 
       <New class="org.mortbay.thread.concurrent.ThreadPool">
-        <Set name="corePoolSize">250</Set>
-        <Set name="maximumPoolSize">250</Set>
+        <Set name="corePoolSize">50</Set>
+        <Set name="maximumPoolSize">50</Set>
       </New>
       -->
     </Set>
@@ -46,6 +46,7 @@
     <Call name="addConnector">
       <Arg>
           <New class="org.mortbay.jetty.nio.SelectChannelConnector">
+            <Set name="host"><SystemProperty name="jetty.host" /></Set>
             <Set name="port"><SystemProperty name="jetty.port" default="8080"/></Set>
             <Set name="maxIdleTime">30000</Set>
             <Set name="Acceptors">2</Set>
@@ -57,7 +58,7 @@
       </Arg>
     </Call>
 
-    <!-- Use this connector if NIO is not available.
+    <!-- Use this connector if NIO is not available. 
     <Call name="addConnector">
       <Arg>
           <New class="org.mortbay.jetty.bio.SocketConnector">
@@ -74,6 +75,14 @@
     <!-- see jetty-ssl.xml to add an ssl connector. use                  -->
     <!-- java -jar start.jar etc/jetty.xml etc/jetty-ssl.xml             -->
     <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
+
+    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
+    <!-- To allow Jetty to be started from xinetd                        -->
+    <!-- mixin jetty-xinetd.xml:                                         -->
+    <!--   java -jar start.jar etc/jetty.xml etc/jetty-xinetd.xml        -->
+    <!--                                                                 -->
+    <!-- See jetty-xinetd.xml for further instructions.                  -->
+    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
     
     <!-- =========================================================== -->
     <!-- Set up global session ID manager                            -->
@@ -123,7 +132,7 @@
         <New class="org.mortbay.jetty.deployer.ContextDeployer">
           <Set name="contexts"><Ref id="Contexts"/></Set>
           <Set name="configurationDir"><SystemProperty name="jetty.home" default="."/>/contexts</Set>
-          <Set name="scanInterval">1</Set>
+          <Set name="scanInterval">5</Set>
         </New>
       </Arg>
     </Call>
@@ -163,14 +172,13 @@
     <!-- =========================================================== -->
     <Set name="UserRealms">
       <Array type="org.mortbay.jetty.security.UserRealm">
-        <!--
         <Item>
           <New class="org.mortbay.jetty.security.HashUserRealm">
             <Set name="name">Test Realm</Set>
             <Set name="config"><SystemProperty name="jetty.home" default="."/>/etc/realm.properties</Set>
+            <Set name="refreshInterval">0</Set>
           </New>
         </Item>
-	-->
       </Array>
     </Set>
 
@@ -188,7 +196,7 @@
           <Set name="filenameDateFormat">yyyy_MM_dd</Set>
           <Set name="retainDays">90</Set>
           <Set name="append">true</Set>
-          <Set name="extended">true</Set>
+          <Set name="extended">false</Set>
           <Set name="logCookies">false</Set>
           <Set name="LogTimeZone">GMT</Set>
         </New>
