Index: modules/jetty/src/main/java/org/mortbay/jetty/security/SslSelectChannelConnector.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/SslSelectChannelConnector.java	(revision 0)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/SslSelectChannelConnector.java	(revision 0)
@@ -0,0 +1,163 @@
+package org.mortbay.jetty.security;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+import java.security.KeyStore;
+
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.TrustManagerFactory;
+
+import org.mortbay.jetty.nio.HttpChannelEndPoint;
+import org.mortbay.jetty.nio.SelectChannelConnector;
+import org.mortbay.log.Log;
+import org.mortbay.resource.Resource;
+
+/* ------------------------------------------------------------ */
+/** SslSelectChannelConnector.
+ *
+ * @author Nik Gonzalez <ngonzalez@exist.com>
+ * @author Greg Wilkins <gregw@mortbay.com>
+ */
+public class SslSelectChannelConnector extends SelectChannelConnector
+{
+    /** Default value for the cipher Suites. */
+    private String _cipherSuites[] = null;
+
+    /** Default value for the keystore location path. */
+    public static final String DEFAULT_KEYSTORE = System.getProperty("user.home") + File.separator + ".keystore";
+
+    /** String name of keystore password property. */
+    public static final String PASSWORD_PROPERTY = "jetty.ssl.password";
+
+    /** String name of key password property. */
+    public static final String KEYPASSWORD_PROPERTY = "jetty.ssl.keypassword";
+
+    private String _keystore = DEFAULT_KEYSTORE;
+    private transient Password _password;
+    private transient Password _keypassword;
+    private String _protocol = "TLS";
+    private String _algorithm = "SunX509"; // cert algorithm
+    private String _keystoreType = "JKS"; // type of the key store
+    private String _provider;
+
+    /* ------------------------------------------------------------ */
+    public String[] getCipherSuites()
+    {
+        return _cipherSuites;
+    }
+
+    /* ------------------------------------------------------------ */
+    /**
+     * @author Tony Jiang
+     */
+    public void setCipherSuites(String[] cipherSuites)
+    {
+        this._cipherSuites = cipherSuites;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setPassword(String password)
+    {
+        _password = Password.getPassword(PASSWORD_PROPERTY, password, null);
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setKeyPassword(String password)
+    {
+        _keypassword = Password.getPassword(KEYPASSWORD_PROPERTY, password, null);
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getAlgorithm()
+    {
+        return (this._algorithm);
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setAlgorithm(String algorithm)
+    {
+        this._algorithm = algorithm;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getProtocol()
+    {
+        return _protocol;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setProtocol(String protocol)
+    {
+        _protocol = protocol;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setKeystore(String keystore)
+    {
+        _keystore = keystore;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getKeystore()
+    {
+        return _keystore;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getKeystoreType()
+    {
+        return (_keystoreType);
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setKeystoreType(String keystoreType)
+    {
+        _keystoreType = keystoreType;
+    }
+
+    /* ------------------------------------------------------------ */
+    public String getProvider()
+    {
+        return _provider;
+    }
+
+    /* ------------------------------------------------------------ */
+    public void setProvider(String _provider)
+    {
+        this._provider = _provider;
+    }
+
+    /* ------------------------------------------------------------ */
+    public HttpChannelEndPoint newHttpChannelEndPoint(SelectChannelConnector connector, SocketChannel channel, SelectChannelConnector.SelectSet selectSet, SelectionKey sKey) throws IOException
+    {
+        return new SslHttpChannelEndPoint(connector, channel, selectSet, sKey, createSSLEngine());
+    }
+
+    /* ------------------------------------------------------------ */
+    protected SSLEngine createSSLEngine() throws IOException
+    {
+        SSLEngine engine = null;
+        try
+        {
+            SSLContext context = _provider == null ? SSLContext.getInstance(_protocol) : SSLContext.getInstance(_protocol, _provider);
+            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(_algorithm);
+            KeyStore keyStore = KeyStore.getInstance(_keystoreType);
+            keyStore.load(Resource.newResource(_keystore).getInputStream(), _password.toString().toCharArray());
+            keyManagerFactory.init(keyStore, _keypassword.toString().toCharArray());
+            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(_algorithm);
+            trustManagerFactory.init(keyStore);
+            context.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new java.security.SecureRandom());
+            engine = context.createSSLEngine();
+        }
+        catch (Exception e)
+        {
+            Log.debug(e);
+        }
+
+        return engine;
+    }
+}
Index: modules/jetty/src/main/java/org/mortbay/jetty/security/SslHttpChannelEndPoint.java
===================================================================
--- modules/jetty/src/main/java/org/mortbay/jetty/security/SslHttpChannelEndPoint.java	(revision 0)
+++ modules/jetty/src/main/java/org/mortbay/jetty/security/SslHttpChannelEndPoint.java	(revision 0)
@@ -0,0 +1,378 @@
+package org.mortbay.jetty.security;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLEngineResult;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSession;
+
+import org.mortbay.io.Buffer;
+import org.mortbay.io.nio.NIOBuffer;
+import org.mortbay.jetty.nio.HttpChannelEndPoint;
+import org.mortbay.jetty.nio.SelectChannelConnector;
+import org.mortbay.jetty.nio.SelectChannelConnector.SelectSet;
+import org.mortbay.log.Log;
+
+/* ------------------------------------------------------------ */
+/**
+ * SslHttpChannelEndPoint.
+ * 
+ * @author Nik Gonzalez <ngonzalez@exist.com>
+ * @author Greg Wilkins <gregw@mortbay.com>
+ */
+public class SslHttpChannelEndPoint extends HttpChannelEndPoint implements Runnable
+{
+    private final SSLEngine _engine;
+    private ByteBuffer _handshakeBuffer;
+    private SSLEngineResult.HandshakeStatus _handshakeStatus;
+    private boolean _initialHandshake = false;
+    private final NIOBuffer _outNIOBuffer;
+    private final ByteBuffer _outBuffer;
+    private final ByteBuffer _peerAppData;
+    
+    // ssl
+    private final SSLSession _session;
+    private SSLEngineResult.Status _status = null;
+
+    /* ------------------------------------------------------------ */
+    public SslHttpChannelEndPoint(SelectChannelConnector connector, SocketChannel channel, SelectSet selectSet, SelectionKey key, SSLEngine engine) throws SSLException, IOException
+    {
+        super(connector, channel, selectSet, key);
+
+        // ssl
+        _engine = engine;
+        _engine.setUseClientMode(false);
+        _session = engine.getSession();
+        _peerAppData = ByteBuffer.allocate(_session.getApplicationBufferSize());
+        _peerAppData.position(_peerAppData.limit());
+
+        _outNIOBuffer = new NIOBuffer(_session.getPacketBufferSize(), true);
+        _outBuffer = _outNIOBuffer.getByteBuffer();
+        _outBuffer.limit(_outBuffer.capacity());
+        _outBuffer.position(_outBuffer.capacity());
+        
+        // begin handshake
+        _engine.beginHandshake();
+        _handshakeStatus = _engine.getHandshakeStatus();
+        _initialHandshake = true;
+        _handshakeBuffer = ByteBuffer.allocate(_session.getApplicationBufferSize());
+        doHandshake();
+    }
+
+    /* ------------------------------------------------------------ */
+    private void doHandshake() throws IOException
+    {
+        while (true)
+        {
+            SSLEngineResult result;
+            if (_handshakeStatus.equals(SSLEngineResult.HandshakeStatus.FINISHED))
+            {
+                if (_initialHandshake)
+                {
+                    _initialHandshake = false;
+                }
+                return;
+            }
+            else if (_handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_TASK))
+            {
+                doTasks();
+            }
+            else if (_handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_UNWRAP))
+            {
+                if (_channel.read(_handshakeBuffer) < 0)
+                {
+                    _engine.closeInbound();
+                }
+                _peerAppData.clear();
+                _handshakeBuffer.flip();
+                do
+                {
+                    result = _engine.unwrap(_handshakeBuffer, _peerAppData);
+                }
+                while (result.getStatus() == SSLEngineResult.Status.OK && result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP && result.bytesProduced() == 0);
+
+                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED)
+                {
+                    _initialHandshake = false;
+                }
+
+                // If no data was produced, and the status is still ok, try to read once more
+                if (_peerAppData.position() == 0 && result.getStatus() == SSLEngineResult.Status.OK && _handshakeBuffer.hasRemaining())
+                {
+                    result = _engine.unwrap(_handshakeBuffer, _peerAppData);
+                }
+
+                _status = result.getStatus();
+                _handshakeStatus = result.getHandshakeStatus();
+
+                _handshakeBuffer.compact();
+                _peerAppData.flip();
+            }
+            else if (_handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_WRAP))
+            {
+                if (!_outBuffer.hasRemaining())
+                {
+                    // Prepare to write
+                    _outBuffer.clear();
+                    result = _engine.wrap(_handshakeBuffer, _outBuffer);
+                    _handshakeStatus = result.getHandshakeStatus();
+                    _outBuffer.flip();
+                }
+                _channel.write(_outBuffer);
+            }
+            else if (_handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)) { return; }
+        }
+
+    }
+
+    /* ------------------------------------------------------------ */
+    private void doTasks()
+    {
+        Runnable task;
+        while ((task = _engine.getDelegatedTask()) != null)
+        {
+            task.run();
+        }
+        _handshakeStatus = _engine.getHandshakeStatus();
+    }
+
+    /* ------------------------------------------------------------ */
+    private ByteBuffer extractByteBuffer(Buffer buffer)
+    {
+        ByteBuffer src = null;
+        NIOBuffer nBuf = null;
+        synchronized (buffer)
+        {
+            // TODO - expensive to do this all the time - need to reuse this buffer!
+            if (buffer.buffer() instanceof NIOBuffer)
+            {
+                nBuf = (NIOBuffer) buffer.buffer();
+                src = nBuf.getByteBuffer();
+            }
+            else
+            {
+                Log.debug("allocate another bytebuffer: " + buffer.getClass().getName());
+                src = ByteBuffer.allocate(buffer.length());
+                for (int i = 0; i < buffer.length(); i++)
+                {
+                    src.put(buffer.peek(i));
+                }
+            }
+        }
+
+        if (src != null)
+        {
+            synchronized (buffer)
+            {
+                // TODO... do you need to reset this buffer afterwards? See ChannelEndPoint flush
+                // I am pretty sure this would be why it is not working 100%
+                src.position(buffer.getIndex());
+                src.limit(buffer.putIndex());
+            }
+        }
+
+        return src;
+    }
+
+    /* ------------------------------------------------------------ */
+    /* 
+     */
+    public int fill(Buffer buffer) throws IOException
+    {
+        if (_initialHandshake) { return 0; }
+
+        int l = super.fill(buffer);
+        if (l < 0) { return l; }
+
+        buffer.setGetIndex(0);
+        buffer.setPutIndex(l);
+        return unWrap((NIOBuffer) buffer);
+    }
+
+    /* ------------------------------------------------------------ */
+    public int flush(Buffer buffer) throws IOException
+    {
+        return flush(buffer, null, null);
+    }
+
+    /* ------------------------------------------------------------ */
+    private void flushOutBuffer() throws IOException
+    {
+        try
+        {
+            _outNIOBuffer.setPutIndex(_outBuffer.limit());
+            _outNIOBuffer.setGetIndex(_outBuffer.position());
+            super.flush(_outNIOBuffer);
+        }
+        finally
+        {
+            _outBuffer.limit(_outNIOBuffer.putIndex());
+            _outBuffer.position(_outNIOBuffer.getIndex());
+        }
+    }
+
+    /* ------------------------------------------------------------ */
+    /*
+     */
+    public int flush(Buffer header, Buffer buffer, Buffer trailer) throws IOException
+    {
+        if (_initialHandshake) { return 0; }
+
+        if (_outBuffer.hasRemaining())
+        {
+            flushOutBuffer();
+            return 0;
+        }
+
+        int len = 0;
+        _outBuffer.clear();
+
+        try
+        {
+            synchronized (_outBuffer)
+            {
+                if (header != null && header.length() > 0)
+                    len += wrap(header);
+                
+                if (_outBuffer.hasRemaining() && buffer != null && buffer.length() > 0)
+                    len += wrap(buffer);
+                
+                if (_outBuffer.hasRemaining() && trailer != null && trailer.length() > 0)
+                    len += wrap(trailer);
+            }
+        }
+        finally
+        {
+            _outBuffer.flip();
+            flushOutBuffer();
+        }
+
+        return len;
+    }
+
+
+
+    /* ------------------------------------------------------------ */
+    private int unWrap(NIOBuffer buffer) throws IOException
+    {
+        ByteBuffer bBuf = buffer.getByteBuffer();
+        bBuf.position(buffer.getIndex());
+        bBuf.limit(buffer.putIndex());
+
+        _peerAppData.clear();
+        SSLEngineResult result;
+
+        do
+        {
+            result = _engine.unwrap(bBuf, _peerAppData);
+        }
+        while (result.getStatus() == SSLEngineResult.Status.OK && result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP && result.bytesProduced() == 0);
+
+        if (_peerAppData.position() == 0 && result.getStatus() == SSLEngineResult.Status.OK && bBuf.hasRemaining())
+        {
+            result = _engine.unwrap(bBuf, _peerAppData);
+        }
+
+        _status = result.getStatus();
+        _handshakeStatus = result.getHandshakeStatus();
+
+        // copy unencrypted data to the buffer
+        int l = _peerAppData.position();
+        bBuf.clear();
+
+        _peerAppData.flip();
+        for (int i = 0; i < l; i++)
+        {
+            bBuf.put(_peerAppData.get(i));
+        }
+
+        buffer.setGetIndex(0);
+        buffer.setPutIndex(bBuf.position());
+        bBuf.position(0);
+
+        if (_handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK || _handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP || _handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED)
+        {
+            doHandshake();
+        }
+
+        return result.bytesProduced();
+    }
+
+    /* ------------------------------------------------------------ */
+    private int wrap(Buffer buffer) throws SSLException, IOException
+    {
+        SSLEngineResult result = null;
+        int total_written = 0;
+        ByteBuffer src = extractByteBuffer(buffer);
+        try
+        {
+            synchronized (_outBuffer)
+            {
+                result = _engine.wrap(src, _outBuffer);
+
+                _status = result.getStatus();
+                _handshakeStatus = result.getHandshakeStatus();
+                if (_status == SSLEngineResult.Status.CLOSED)
+                {
+                    throw new IOException("SSLEngine closed");
+                }
+                else if (_status == SSLEngineResult.Status.OK)
+                {
+                    // TODO: check for rehandshake
+                }
+
+                total_written = result.bytesConsumed();
+            }
+        }
+        finally
+        {
+            src.position(0);
+            src.limit(src.capacity());
+
+            // set buffer length to 0
+            buffer.setGetIndex(buffer.getIndex() + total_written);
+        }
+
+        _status = result.getStatus();
+        _handshakeStatus = result.getHandshakeStatus();
+        
+        return total_written;
+    }
+
+    public void close() throws IOException
+    {
+        _engine.closeOutbound();
+        if (_outBuffer.hasRemaining())
+        {
+            flushOutBuffer();
+            
+            if(_outBuffer.hasRemaining())
+            {   
+                // TODO - what if all data is not flushed???
+                throw new IllegalStateException("TODO???");
+            }
+        }
+        
+        /*
+         * By RFC 2616, we can "fire and forget" our close_notify message, so that's what we'll do
+         * here.
+         */
+        _outBuffer.clear();
+        SSLEngineResult result = _engine.wrap(_handshakeBuffer, _outBuffer);
+        if (result.getStatus() != SSLEngineResult.Status.CLOSED) { throw new SSLException("Improper closed state."); }
+        _outBuffer.flip();
+        flushOutBuffer();
+        
+        if(_outBuffer.hasRemaining())
+        {   
+            // TODO - what if all data is not flushed???
+            throw new IllegalStateException("TODO???");
+        }
+
+        super.close();
+    }
+}
Index: modules/jetty/pom.xml
===================================================================
--- modules/jetty/pom.xml	(revision 666)
+++ modules/jetty/pom.xml	(working copy)
@@ -23,6 +23,13 @@
     </testResources>
     <plugins>
       <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+      <plugin>
         <artifactId>maven-antrun-plugin</artifactId>
         <executions>
           <execution>
Index: etc/jetty.xml
===================================================================
--- etc/jetty.xml	(revision 662)
+++ etc/jetty.xml	(working copy)
@@ -60,6 +60,16 @@
         <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
         <!-- Add a HTTPS SSL listener on port 8443                           -->
         <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
+        <Item>
+          <New class="org.mortbay.jetty.security.SslSelectChannelConnector">
+            <Set name="Port">8443</Set>
+            <Set name="maxIdleTime">30000</Set>
+            <Set name="Keystore"><SystemProperty name="jetty.home" default="." />/etc/keystore</Set>
+            <Set name="Password">OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4</Set>
+            <Set name="KeyPassword">OBF:1u2u1wml1z7s1z7a1wnl1u2g</Set>
+          </New>
+        </Item>
+        
         <!--
         <Item>
           <New class="org.mortbay.jetty.security.SslSocketConnector">
